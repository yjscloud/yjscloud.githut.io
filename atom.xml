<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>戏子登台</title>
  <subtitle>唱一曲词，戏子登台，人生若只初相见，卖弄风骚为谁演。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yjscloud.com/"/>
  <updated>2018-02-07T11:14:52.000Z</updated>
  <id>http://yjscloud.com/</id>
  
  <author>
    <name>Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python当歌（九）：模块</title>
    <link href="http://yjscloud.com/2018/01/22/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9D%97/"/>
    <id>http://yjscloud.com/2018/01/22/Python当歌（九）：模块/</id>
    <published>2018-01-22T09:37:20.000Z</published>
    <updated>2018-02-07T11:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块-amp-包"><a href="#模块-amp-包" class="headerlink" title="模块&amp;包"></a>模块&amp;包</h1><h2 id="模块-modue-的概念："><a href="#模块-modue-的概念：" class="headerlink" title="模块(modue)的概念："></a>模块(modue)的概念：</h2><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</p>
<p>使用模块有什么好处？<br>最大的好处是大大提高了代码的可维护性。</p>
<p>其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。<br>所以，模块一共三种：</p>
<ul>
<li>python标准库</li>
<li>第三方模块</li>
<li>应用程序自定义模块</li>
</ul>
<p>另外，使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。</p>
<h2 id="模块导入方法"><a href="#模块导入方法" class="headerlink" title="模块导入方法"></a>模块导入方法</h2><p>（1）import语法</p>
<pre><code>import module1[, module2[,... moduleN]
</code></pre><p>（2）from…import语句</p>
<pre><code>from modname import name1[, name2[, ... nameN]]
</code></pre><p>（3）From…import* 语句</p>
<pre><code>from modname import *
</code></pre><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义</p>
<p>（4）运行本质</p>
<pre><code>import test
from test import add
</code></pre><p>无论1还是2，首先通过sys.path找到test.py,然后执行test脚本（全部执行），区别是1会将test这个变量名加载到名字空间，而2只会将add这个变量名加载进来。　</p>
<h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><p>如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p>
<p>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。</p>
<p>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-1.png" alt="9-1"></p>
<p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，view.py模块的名字就变成了hello_django.app01.views，类似的，manage.py的模块名则是hello_django.manage。</p>
<p>请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录(文件夹)，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是对应包的名字。</p>
<p>调用包就是执行包下的__init__.py文件</p>
<h2 id="注意点（important）"><a href="#注意点（important）" class="headerlink" title="注意点（important）"></a>注意点（important）</h2><p>1、——————-</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-2.png" alt="9-2"></p>
<p>在nod1里import  hello是找不到的，有同学说可以找到呀，那是因为你的pycharm为你把myapp这一层路径加入到了sys.path里面，所以可以找到，然而程序一旦在命令行运行，则报错。有同学问那怎么办？简单啊，自己把这个路径加进去不就OK啦：</p>
<pre><code>import sys,os
BASE_DIR=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(BASE_DIR)
import hello
hello.hello1()
</code></pre><p>2、————————–</p>
<pre><code>if __name__==&apos;__main__&apos;:
    print(&apos;ok&apos;)

“Make a .py both importable and executable”
</code></pre><p>如果我们是直接执行某个.py文件的时候，该文件中那么”__name__ == ‘__main__’“是True,但是我们如果从另外一个.py文件通过import导入该文件的时候，这时__name__的值就是我们这个py文件的名字而不是__main__。</p>
<p>这个功能还有一个用处：调试代码的时候，在”if __name__ == ‘__main__’“中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！</p>
<h1 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h1><p>三种时间表示</p>
<p>在Python中，通常有这几种方式来表示时间：</p>
<p>（1）时间戳(timestamp)：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</p>
<p>（2）格式化的时间字符串</p>
<p>（3）元组(struct_time)：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天，夏令时)<br>import time</p>
<p>#    1 time() :返回当前时间的时间戳</p>
<p>time.time()  #1473525444.037215</p>
<p>#———————————————————-</p>
<p># 2 localtime([secs])</p>
<p># 将一个时间戳转换为当前时区的struct_time。secs参数未提供，则以当前时间为准。</p>
<p>time.localtime() #time.struct_time(tm_year=2016, tm_mon=9, tm_mday=11, tm_hour=0,</p>
<p># tm_min=38, tm_sec=39, tm_wday=6, tm_yday=255, tm_isdst=0)</p>
<p>time.localtime(1473525444.037215)</p>
<p>#———————————————————-</p>
<p># 3 gmtime([secs]) 和localtime()方法类似，gmtime()方法是将一个时间戳转换为UTC时区（0时区）的struct_time。</p>
<p>#———————————————————-</p>
<p># 4 mktime(t) : 将一个struct_time转化为时间戳。</p>
<p>print(time.mktime(time.localtime()))#1473525749.0</p>
<p>#———————————————————-</p>
<p># 5 asctime([t]) : 把一个表示时间的元组或者struct_time表示为这种形式：’Sun Jun 20 23:21:05 1993’。</p>
<p># 如果没有参数，将会将time.localtime()作为参数传入。</p>
<p>print(time.asctime())#Sun Sep 11 00:43:43 2016</p>
<p>#———————————————————-</p>
<p># 6 ctime([secs]) : 把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果参数未给或者为None的时候，将会默认time.time()为参数。它的作用相当于time.asctime(time.localtime(secs))。</p>
<p>print(time.ctime())  # Sun Sep 11 00:46:38 2016</p>
<p>print(time.ctime(time.time()))  # Sun Sep 11 00:46:38 2016</p>
<p>#———————————————————-</p>
<p># 7 strftime(format[, t]) : 把一个代表时间的元组或者struct_time（如由time.localtime()和time.gmtime()返回）转化为格式化的时间字符串。如果t未指定，将传入<br>time.localtime()。如果元组中任何一个元素越界，ValueError的错误将会被抛出。</p>
<p>print(time.strftime(“%Y-%m-%d %X”, time.localtime()))#2016-09-11 00:49:56</p>
<p>#———————————————————-</p>
<p># 8 time.strptime(string[, format])</p>
<p># 把一个格式化时间字符串转化为struct_time。实际上它和strftime()是逆操作。</p>
<p>print(time.strptime(‘2011-05-05 16:37:06’, ‘%Y-%m-%d %X’))</p>
<p># time.struct_time(tm_year=2011, tm_mon=5, tm_mday=5, tm_hour=16, tm_min=37, tm_sec=6,</p>
<p>#  tm_wday=3, tm_yday=125, tm_isdst=-1)</p>
<p># 在这个函数中，format默认为：”%a %b %d %H:%M:%S %Y”。</p>
<p>#———————————————————-</p>
<p># 9 sleep(secs)<br># 线程推迟指定的时间运行，单位为秒。</p>
<p>#———————————————————-</p>
<p># 10 clock()<br># 这个需要注意，在不同的系统上含义不同。在UNIX系统上，它返回的是“进程时间”，它是用秒表示的浮点数（时间戳）。而在WINDOWS中，第一次调用，返回的是进程运行的实际时间。而第二次之后的调用是自第一次调用以后到现在的运行时间，即两次时间差。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-3.png" alt="9-3"><br><img src="http://p3q1rwnbl.bkt.clouddn.com/9-4.png" alt="9-4"></p>
<h1 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h1><pre><code>import random

print(random.random())    #(0,1)----float

print(random.randint(1,3))  #[1,3]

print(random.randrange(1,3)) #[1,3)

print(random.choice([1,&apos;23&apos;,[4,5]]))     #23

print(random.sample([1,&apos;23&apos;,[4,5]],2))  #[[4, 5], &apos;23&apos;]

print(random.uniform(1,3))  #1.927109612082716


item=[1,3,5,7,9]
random.shuffle(item)
print(item)
</code></pre><p>随机验证码代码:</p>
<pre><code>import random

def v_code():

    code = &apos;&apos;
    for i in range(5):

        num=random.randint(0,9)
        alf=chr(random.randint(65,90))
        add=random.choice([num,alf])
        code += str(add)
    return code

print(v_code())
</code></pre><h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><p>os模块是与操作系统交互的一个接口</p>
<p>os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</p>
<p>os.chdir(“dirname”)  改变当前脚本工作目录；相当于shell下cd</p>
<p>os.curdir  返回当前目录: (‘.’)</p>
<p>os.pardir  获取当前目录的父目录字符串名：(‘..’)</p>
<p>os.makedirs(‘dirname1/dirname2’)    可生成多层递归目录</p>
<p>os.removedirs(‘dirname1’)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</p>
<p>os.mkdir(‘dirname’)    生成单级目录；相当于shell中mkdir dirname</p>
<p>os.rmdir(‘dirname’)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</p>
<p>os.listdir(‘dirname’)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</p>
<p>os.remove()  删除一个文件</p>
<p>os.rename(“oldname”,”newname”)  重命名文件/目录</p>
<p>os.stat(‘path/filename’)  获取文件/目录信息</p>
<p>os.sep    输出操作系统特定的路径分隔符，win下为”\“,Linux下为”/“</p>
<p>os.linesep    输出当前平台使用的行终止符，win下为”\t\n”,Linux下为”\n”</p>
<p>os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</p>
<p>os.name    输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’</p>
<p>os.system(“bash command”)  运行shell命令，直接显示</p>
<p>os.environ  获取系统环境变量</p>
<p>os.path.abspath(path)  返回path规范化的绝对路径</p>
<p>os.path.split(path)  将path分割成目录和文件名二元组返回</p>
<p>os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</p>
<p>os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</p>
<p>os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</p>
<p>os.path.isabs(path)  如果path是绝对路径，返回True</p>
<p>os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</p>
<p>os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</p>
<p>os.path.join(path1[, path2[, …]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</p>
<p>os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</p>
<p>os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</p>
<h1 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h1><p>sys.argv           命令行参数List，第一个元素是程序本身路径</p>
<p>sys.exit(n)        退出程序，正常退出时exit(0)</p>
<p>sys.version        获取Python解释程序的版本信息</p>
<p>sys.maxint         最大的Int值</p>
<p>sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</p>
<p>sys.platform       返回操作系统平台名称</p>
<p>进度条代码：</p>
<pre><code>import sys,time
for i in range(10):
    sys.stdout.write(&apos;#&apos;)
    time.sleep(1)
    sys.stdout.flush()
</code></pre><h1 id="json-amp-pickle"><a href="#json-amp-pickle" class="headerlink" title="json&amp;pickle"></a>json&amp;pickle</h1><p>用eval内置方法可以将一个字符串转成python对象，不过，eval方法是有局限性的，对于普通的数据类型，json.loads和eval都能用，但遇到特殊类型的时候，eval就不管用了,所以eval的重点还是通常用来执行一个字符串表达式，并返回表达式的值。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-5.png" alt="9-5"></p>
<h2 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h2><p>我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。<br>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-6.png" alt="9-6"></p>
<p>#—————————-序列化</p>
<pre><code>import json

dic={&apos;name&apos;:&apos;alvin&apos;,&apos;age&apos;:23,&apos;sex&apos;:&apos;male&apos;}
print(type(dic))#&lt;class &apos;dict&apos;&gt;

j=json.dumps(dic)
print(type(j))#&lt;class &apos;str&apos;&gt;

f=open(&apos;序列化对象&apos;,&apos;w&apos;)
f.write(j)  #-------------------等价于json.dump(dic,f)
f.close()
</code></pre><p>#—————————–反序列化<br></p>
<pre><code>import json
f=open(&apos;序列化对象&apos;)
data=json.loads(f.read())#  等价于data=json.load(f)
</code></pre><p>注意：</p>
<pre><code>import json
#dct=&quot;{&apos;1&apos;:111}&quot;#json 不认单引号
#dct=str({&quot;1&quot;:111})#报错,因为生成的数据还是单引号:{&apos;one&apos;: 1}

dct=&apos;{&quot;1&quot;:&quot;111&quot;}&apos;
print(json.loads(dct))

#conclusion:
#无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads
</code></pre><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><p>#—————————-序列化</p>
<pre><code>import pickle

dic={&apos;name&apos;:&apos;alvin&apos;,&apos;age&apos;:23,&apos;sex&apos;:&apos;male&apos;}

print(type(dic))#&lt;class &apos;dict&apos;&gt;

j=pickle.dumps(dic)
print(type(j))#&lt;class &apos;bytes&apos;&gt;

f=open(&apos;序列化对象_pickle&apos;,&apos;wb&apos;)#注意是w是写入str,wb是写入bytes,j是&apos;bytes&apos;
f.write(j)  #-------------------等价于pickle.dump(dic,f)

f.close()
</code></pre><p>#————————-反序列化</p>
<pre><code>import pickle
f=open(&apos;序列化对象_pickle&apos;,&apos;rb&apos;)

data=pickle.loads(f.read())#  等价于data=pickle.load(f)

print(data[&apos;age&apos;])  
</code></pre><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>
<h1 id="xml模块"><a href="#xml模块" class="headerlink" title="xml模块"></a>xml模块</h1><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，在json还没诞生的黑暗年代，大家只能选择用xml，至今很多传统公司如金融行业的很多系统的接口还主要是xml。</p>
<p>xml的格式如下，就是通过&lt;&gt;节点来区别数据结构的:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;data&gt;
    &lt;country name=&quot;Liechtenstein&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;2&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;
        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;
    &lt;/country&gt;
    &lt;country name=&quot;Singapore&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;5&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;
    &lt;/country&gt;
    &lt;country name=&quot;Panama&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;69&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor name=&quot;Costa Rica&quot; direction=&quot;W&quot;/&gt;
        &lt;neighbor name=&quot;Colombia&quot; direction=&quot;E&quot;/&gt;
    &lt;/country&gt;
&lt;/data&gt;
</code></pre><p>xml协议在各个语言里的都 是支持的，在python中可以用以下模块操作xml：</p>
<pre><code>import xml.etree.ElementTree as ET 
tree = ET.parse(&quot;xmltest.xml&quot;)
root = tree.getroot()
print(root.tag)
</code></pre><p>#遍历xml文档</p>
<pre><code>for child in root:
    print(child.tag, child.attrib)
    for i in child:
        print(i.tag,i.text)
</code></pre><p>#只遍历year 节点</p>
<pre><code>for node in root.iter(&apos;year&apos;):
    print(node.tag,node.text)
</code></pre><p>#—————————————</p>
<pre><code>import xml.etree.ElementTree as ET

tree = ET.parse(&quot;xmltest.xml&quot;)
root = tree.getroot()
</code></pre><p>#修改</p>
<pre><code>for node in root.iter(&apos;year&apos;):
    new_year = int(node.text) + 1
    node.text = str(new_year)
    node.set(&quot;updated&quot;,&quot;yes&quot;)

tree.write(&quot;xmltest.xml&quot;)
</code></pre><p>#删除node</p>
<pre><code>for country in root.findall(&apos;country&apos;):
    rank = int(country.find(&apos;rank&apos;).text)
    if rank &gt; 50:
     root.remove(country)

tree.write(&apos;output.xml&apos;)
</code></pre><p>自己创建xml文档：</p>
<pre><code>import xml.etree.ElementTree as ET

new_xml = ET.Element(&quot;namelist&quot;)
name = ET.SubElement(new_xml,&quot;name&quot;,attrib={&quot;enrolled&quot;:&quot;yes&quot;})
age = ET.SubElement(name,&quot;age&quot;,attrib={&quot;checked&quot;:&quot;no&quot;})
sex = ET.SubElement(name,&quot;sex&quot;)
sex.text = &apos;33&apos;
name2 = ET.SubElement(new_xml,&quot;name&quot;,attrib={&quot;enrolled&quot;:&quot;no&quot;})
age = ET.SubElement(name2,&quot;age&quot;)
age.text = &apos;19&apos;

et = ET.ElementTree(new_xml) #生成文档对象
et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;,xml_declaration=True)

ET.dump(new_xml) #打印生成的格式
</code></pre><h1 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h1><p>(1)简单应用</p>
<pre><code>import logging  
logging.debug(&apos;debug message&apos;)  
logging.info(&apos;info message&apos;)  
logging.warning(&apos;warning message&apos;)  
logging.error(&apos;error message&apos;)  
logging.critical(&apos;critical message&apos;)
</code></pre><p>输出：</p>
<pre><code>WARNING:root:warning message
ERROR:root:error message
CRITICAL:root:critical message
</code></pre><p>可见，默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET），默认的日志格式为日志级别：Logger名称：用户输出消息。</p>
<p>（2)灵活配置日志级别，日志格式，输出位置</p>
<pre><code>import logging

logging.basicConfig(level=logging.DEBUG,
format=&apos;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;,
datefmt=&apos;%a, %d %b %Y %H:%M:%S&apos;,
filename=&apos;test.log&apos;,
filemode=&apos;w&apos;)

logging.debug(&apos;debug message&apos;)
logging.info(&apos;info message&apos;)
logging.warning(&apos;warning message&apos;)
logging.error(&apos;error message&apos;)
logging.critical(&apos;critical message&apos;)
</code></pre><p>查看输出：</p>
<pre><code>Wed, 24 Jan 2018 16:48:57 logging_test.py[line:11] DEBUG debug message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:12] INFO info message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:13] WARNING warning message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:14] ERROR error message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:15] CRITICAL critical message
</code></pre><p>可见在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有:</p>
<p>filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。</p>
<p>filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。</p>
<p>format：指定handler使用的日志显示格式。 </p>
<p>datefmt：指定日期时间格式。 </p>
<p>level：设置rootlogger（后边会讲解具体概念）的日志级别 </p>
<p>stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</p>
<p>format参数中可能用到的格式化串：</p>
<p>%(name)s Logger的名字</p>
<p>%(levelno)s 数字形式的日志级别</p>
<p>%(levelname)s 文本形式的日志级别</p>
<p>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</p>
<p>%(filename)s 调用日志输出函数的模块的文件名</p>
<p>%(module)s 调用日志输出函数的模块名</p>
<p>%(funcName)s 调用日志输出函数的函数名</p>
<p>%(lineno)d 调用日志输出函数的语句所在的代码行</p>
<p>%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</p>
<p>%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</p>
<p>%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</p>
<p>%(thread)d 线程ID。可能没有</p>
<p>%(threadName)s 线程名。可能没有</p>
<p>%(process)d 进程ID。可能没有</p>
<p>%(message)s用户输出的消息</p>
<p>（3)logger对象</p>
<p>上述几个例子中我们了解到了logging.debug()、logging.info()、logging.warning()、logging.error()、logging.critical()（分别用以记录不同级别的日志信息），logging.basicConfig()（用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到root logger（根Logger）中）这几个logging模块级别的函数，另外还有一个模块级别的函数是logging.getLogger([name])（返回一个logger对象，如果没有指定名字将返回root logger）</p>
<p>先看一个最简单的过程：</p>
<pre><code>import logging

logger = logging.getLogger()
# 创建一个handler，用于写入日志文件
fh = logging.FileHandler(&apos;test.log&apos;)

# 再创建一个handler，用于输出到控制台
ch = logging.StreamHandler()

formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;)

fh.setFormatter(formatter)
ch.setFormatter(formatter)

logger.addHandler(fh) #logger对象可以添加多个fh和ch对象
logger.addHandler(ch)

logger.debug(&apos;logger debug message&apos;)
logger.info(&apos;logger info message&apos;)
logger.warning(&apos;logger warning message&apos;)
logger.error(&apos;logger error message&apos;)
logger.critical(&apos;logger critical message&apos;)
</code></pre><p>先简单介绍一下，logging库提供了多个组件：Logger、Handler、Filter、Formatter。Logger对象提供应用程序可直接使用的接口，Handler发送日志到适当的目的地，Filter提供了过滤日志信息的方法，Formatter指定日志显示格式。</p>
<p>Logger是一个树形层级结构，输出信息之前都要获得一个Logger（如果没有显示的获取则自动创建并使用root Logger，如第一个例子所示）。</p>
<p>logger = logging.getLogger()返回一个默认的Logger也即root Logger，并应用默认的日志级别、Handler和Formatter设置。</p>
<p>当然也可以通过Logger.setLevel(lel)指定最低的日志级别，可用的日志级别有logging.DEBUG、logging.INFO、logging.WARNING、logging.ERROR、logging.CRITICAL。</p>
<p>Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()输出不同级别的日志，只有日志等级大于或等于设置的日志级别的日志才会被输出。</p>
<pre><code>logger.debug(&apos;logger debug message&apos;)  
logger.info(&apos;logger info message&apos;)  
logger.warning(&apos;logger warning message&apos;)  
logger.error(&apos;logger error message&apos;)  
logger.critical(&apos;logger critical message&apos;)  
</code></pre><p>只输出了</p>
<pre><code>2018-01-24 12:54:43,222 - root - WARNING - logger warning message
2018-01-24 12:54:43,223 - root - ERROR - logger error message
2018-01-24 12:54:43,224 - root - CRITICAL - logger critical message
</code></pre><p>从这个输出可以看出logger = logging.getLogger()返回的Logger名为root。这里没有用logger.setLevel(logging.Debug)显示的为logger设置日志级别，所以使用默认的日志级别WARNIING，故结果只输出了大于等于WARNIING级别的信息。</p>
<p>如果我们再创建两个logger对象：</p>
<pre><code>logger1 = logging.getLogger(&apos;mylogger&apos;)
logger1.setLevel(logging.DEBUG)

logger2 = logging.getLogger(&apos;mylogger&apos;)
logger2.setLevel(logging.INFO)

logger1.addHandler(fh)
logger1.addHandler(ch)

logger2.addHandler(fh)
logger2.addHandler(ch)

logger1.debug(&apos;logger1 debug message&apos;)
logger1.info(&apos;logger1 info message&apos;)
logger1.warning(&apos;logger1 warning message&apos;)
logger1.error(&apos;logger1 error message&apos;)
logger1.critical(&apos;logger1 critical message&apos;)

logger2.debug(&apos;logger2 debug message&apos;)
logger2.info(&apos;logger2 info message&apos;)
logger2.warning(&apos;logger2 warning message&apos;)
logger2.error(&apos;logger2 error message&apos;)
logger2.critical(&apos;logger2 critical message&apos;)
</code></pre><p>结果：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-7.png" alt="9-7"></p>
<p>这里有两个个问题：</p>
<p><1>我们明明通过logger1.setLevel(logging.DEBUG)将logger1的日志级别设置为了DEBUG，为何显示的时候没有显示出DEBUG级别的日志信息，而是从INFO级别的日志开始显示呢？</1></p>
<p>原来logger1和logger2对应的是同一个Logger实例，只要logging.getLogger（name）中名称参数name相同则返回的Logger实例就是同一个，且仅有一个，也即name与Logger实例一一对应。在logger2实例中通过logger2.setLevel(logging.INFO)设置mylogger的日志级别为logging.INFO，所以最后logger1的输出遵从了后来设置的日志级别。</p>
<p><2>为什么logger1、logger2对应的每个输出分别显示两次?</2></p>
<p>这是因为我们通过logger = logging.getLogger()显示的创建了root Logger，而logger1 = logging.getLogger(‘mylogger’)创建了root Logger的孩子(root.)mylogger,logger2同样。而孩子,孙子，重孙……既会将消息分发给他的handler进行处理也会传递给所有的祖先Logger处理。</p>
<p>ok,那么现在我们把</p>
<p># logger.addHandler(fh)<br># logger.addHandler(ch)  注释掉，我们再来看效果：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-8.png" alt="9-8"></p>
<p>因为我们注释了logger对象显示的位置，所以才用了默认方式，即标准输出方式。因为它的父级没有设置文件显示方式，所以在这里只打印了一次。孩子,孙子，重孙……可逐层继承来自祖先的日志级别、Handler、Filter设置，也可以通过Logger.setLevel(lel)、Logger.addHandler(hdlr)、Logger.removeHandler(hdlr)、Logger.addFilter(filt)、Logger.removeFilter(filt)。设置自己特别的日志级别、Handler、Filter。若不设置则使用继承来的值。</p>
<p><3>Filter</3></p>
<p>限制只有满足过滤规则的日志才会输出。</p>
<p>比如我们定义了filter = logging.Filter(‘a.b.c’),并将这个Filter添加到了一个Handler上，则使用该Handler的Logger中只有名字带 a.b.c前缀的Logger才能输出其日志。</p>
<pre><code>filter = logging.Filter(&apos;mylogger&apos;) 

logger.addFilter(filter)
</code></pre><p>这是只对logger这个对象进行筛选,如果想对所有的对象进行筛选，则：</p>
<pre><code>filter = logging.Filter(&apos;mylogger&apos;) 

fh.addFilter(filter)

ch.addFilter(filter)
</code></pre><p> 这样，所有添加fh或者ch的logger对象都会进行筛选。</p>
<h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>就其本质而言，正则表达式（或 RE）是一种小型的、高度专业化的编程语言，（在Python中）它内嵌在Python中，并通过 re 模块实现。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。</p>
<p>字符匹配（普通字符，元字符）：</p>
<p>（1）普通字符：大多数字符和字母都会和自身匹配</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-9.png" alt="9-9"></p>
<p>(2)元字符：<code>. ^ $ * + ? { } [ ] | ( ) \</code></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-10.png" alt="9-10"></p>
<p>注意：前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配</p>
<p>（3）元字符之字符集［］：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-11.png" alt="9-11"></p>
<p>在字符集里有功能的符号: - ^ \</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-12.png" alt="9-12"></p>
<p>（4)元字符之转义符\</p>
<p>反斜杠后边跟元字符去除特殊功能,比如.</p>
<p>反斜杠后边跟普通字符实现特殊功能,比如\d</p>
<p>\d  匹配任何十进制数；它相当于类 [0-9]。</p>
<p>\D 匹配任何非数字字符；它相当于类 [^0-9]。</p>
<p>\s  匹配任何空白字符；它相当于类 [ \t\n\r\f\v]。</p>
<p>\S 匹配任何非空白字符；它相当于类 [^ \t\n\r\f\v]。</p>
<p>\w 匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。</p>
<p>\W 匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]</p>
<p>\b  匹配一个特殊字符边界，比如空格 ，&amp;，＃等</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-13.png" alt="9-13"></p>
<p>一个小坑：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-14.png" alt="9-14"></p>
<p>选择\b是因为\b在ASCII表中是有意义的</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-15.png" alt="9-15"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-16.png" alt="9-16"></p>
<p>（5)元字符之分组()</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-17.png" alt="9-17"></p>
<p>(6)元字符之｜</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-18.png" alt="9-18"></p>
<p>(7)re模块下的常用方法</p>
<pre><code>import  re

#1
re.findall(&apos;a&apos;,&apos;alvin yuan&apos;)    #返回所有满足匹配条件的结果,放在列表里

#2
re.search(&apos;a&apos;,&apos;alvin yuan&apos;).group()  #函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以
# 通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。

#3
re.match(&apos;a&apos;,&apos;abc&apos;).group()     #同search,不过尽在字符串开始处进行匹配

#4
ret=re.split(&apos;[ab]&apos;,&apos;abcd&apos;)     #先按&apos;a&apos;分割得到&apos;&apos;和&apos;bcd&apos;,在对&apos;&apos;和&apos;bcd&apos;分别按&apos;b&apos;分割
print(ret)#[&apos;&apos;, &apos;&apos;, &apos;cd&apos;]

#5
ret=re.sub(&apos;\d&apos;,&apos;abc&apos;,&apos;alvin5yuan6&apos;,1)
print(ret)#alvinabcyuan6
ret=re.subn(&apos;\d&apos;,&apos;abc&apos;,&apos;alvin5yuan6&apos;)
print(ret)#(&apos;alvinabcyuanabc&apos;, 2)

#6
obj=re.compile(&apos;\d{3}&apos;)
ret=obj.search(&apos;abc123eeee&apos;)
print(ret.group())#123

#7
ret=re.finditer(&apos;\d&apos;,&apos;ds3sy4784a&apos;)
print(ret)        #&lt;callable_iterator object at 0x10195f940&gt;
print(next(ret).group())
print(next(ret).group())

注意：
import re

ret=re.findall(&apos;www.(baidu|163).com&apos;,&apos;www.baidu.com&apos;)
print(ret)#[&apos;baidu&apos;]     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可

ret=re.findall(&apos;www.(?:baidu|163.com&apos;,&apos;www.163.com&apos;)
print(ret)#[&apos;www.163.com&apos;]
</code></pre><p>PS: Python支持的正则表达式元字符和语法汇总表</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-19.png" alt="9-19"></p>
<p>(8)正则表达式使用总结：</p>
<p>1、用法</p>
<p>^ 匹配字符串的开始。</p>
<p>$ 匹配字符串的结尾。</p>
<p>\b 匹配一个单词的边界。</p>
<p>\d 匹配任意数字。</p>
<p>\D 匹配任意非数字字符。</p>
<p>x? 匹配一个可选的 x 字符 (换言之，它匹配 1 次或者 0 次 x 字符)。</p>
<p>x* 匹配0次或者多次 x 字符。</p>
<p>x+ 匹配1次或者多次 x 字符。</p>
<p>x{n,m} 匹配 x 字符，至少 n 次，至多 m 次。</p>
<p>(a|b|c) 要么匹配 a，要么匹配 b，要么匹配 c。</p>
<p>(x) 一般情况下表示一个记忆组 (remembered group)。你可以利用 re.search 函数返回对象的 groups() 函数获取它的值。</p>
<p>正则表达式中的点号通常意味着 “匹配任意单字符”</p>
<p>2、解题思路：</p>
<p>匹配出所有的整数：1-2*(60+(-40.35/5)-(-4*3))</p>
<p>A、既然是提取数字，那么数字的形式一般是：整数，小数，整数加小数；</p>
<p>B、所以一般是形如：—-.—–或者就是—-</p>
<p>C、根据上述正则表达式的含义，可写出如下的表达式：“-?\d+.\d*|(-?\d+) “；</p>
<p>D、-？\d+匹配1次或者0次负号；.这个是匹配小数点的；\d*这个是匹配小数点之后的数字的，所以是0个或者多个；|表示左右表达式任意匹配一个 ；</p>
<p>3.代码</p>
<pre><code>import  re
ret=re.findall(r&quot;-?\d+\.\d*|(-?\d+)&quot;,&quot;1-2*(60+(-40.35/5)-(-4*3))&quot;)
ret.remove(&quot;&quot;)
print(ret)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模块-amp-包&quot;&gt;&lt;a href=&quot;#模块-amp-包&quot; class=&quot;headerlink&quot; title=&quot;模块&amp;amp;包&quot;&gt;&lt;/a&gt;模块&amp;amp;包&lt;/h1&gt;&lt;h2 id=&quot;模块-modue-的概念：&quot;&gt;&lt;a href=&quot;#模块-modue-的概念：&quot; c
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（八）：装饰器</title>
    <link href="http://yjscloud.com/2018/01/21/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yjscloud.com/2018/01/21/Python当歌（八）：装饰器/</id>
    <published>2018-01-21T08:04:24.000Z</published>
    <updated>2018-02-07T11:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>讲 Python 装饰器前，我想先举个例子，虽有点污，但跟装饰器这个话题很贴切。每个人都有的内裤主要功能是用来遮羞，但是到了冬天它没法为我们防风御寒，咋办？我们想到的一个办法就是把内裤改造一下，让它变得更厚更长，这样一来，它不仅有遮羞功能，还能提供保暖，不过有个问题，这个内裤被我们改造成了长裤后，虽然还有遮羞功能，但本质上它不再是一条真正的内裤了。于是聪明的人们发明长裤，在不影响内裤的前提下，直接把长裤套在了内裤外面，这样内裤还是内裤，有了长裤后宝宝再也不冷了。装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。</p>
<p>谈装饰器前，还要先要明白一件事，Python 中的函数和 Java、C++不太一样，Python 中的函数可以像普通变量一样当做参数传递给另外一个函数，例如：</p>
<pre><code>def foo():
    print(&quot;foo&quot;)

def bar(func):
    func()

bar(foo)
</code></pre><p>正式回到我们的主题。装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：时间计算、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<p>先来看一个简单例子：</p>
<pre><code>import time

def foo():
    time.sleep(3)
    print(&quot;运行时间是%s&quot; %(stop_time - start_time))
</code></pre><p>现在有一个新的需求，希望可以记录下函数运行的时间，于是在代码中添加计算时间的代码：</p>
<pre><code>import time

def foo():
    start_time = time.time()
    time.sleep(3)
    stop_time = time.time()
    print(&quot;运行时间是%s&quot; %(stop_time - start_time))
</code></pre><p>如果函数 bar()、bar2() 也有类似的需求，怎么做？再写一个 类似的代码在 bar 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门计算函数运行时间 ，时间计算完成之后再执行真正的业务代码。</p>
<pre><code>import time

def timmer(func): #func=test
    start_time=time.time()
    func() #就是在运行test()
    stop_time = time.time()
    print(&apos;运行时间是%s&apos; %(stop_time-start_time))

def test():
     time.sleep(3)
     print(&apos;test函数运行完毕&apos;)

timmer(test)
</code></pre><p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑test函数，而是换成了timmer函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个test函数作为参数传递给test函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>
<h1 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h1><pre><code>import time
def timmer(func): #func=test
    def wrapper():
        start_time=time.time()
        func() #就是在运行test()
        stop_time = time.time()
        print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper

def test():
    time.sleep(3)
print(&apos;test函数运行完毕&apos;)

test = timmer(test)  #因为装饰器 timmer(test) 返回的时函数对象 wrapper，这条语句相当于test = wrapper
test()    #执行test()就相当与执行wrapper()
</code></pre><p>timmer就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 test 被 timmer 装饰了一样，timmer返回的也是一个函数，这个函数的名字叫 wrapper。在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为面向切面的编程。</p>
<h1 id="语法糖"><a href="#语法糖" class="headerlink" title="@ 语法糖"></a>@ 语法糖</h1><p>如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。</p>
<pre><code>import time
def timmer(func): #func=test
    def wrapper():
        start_time=time.time()
        func() #就是在运行test()
        stop_time = time.time()
        print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper

@timmer
def test():
    time.sleep(3)
print(&apos;test函数运行完毕&apos;)

test()
</code></pre><p>如上所示，有了 @ ，我们就可以省去test = timmer(test)这一句了，直接调用 test() 即可得到想要的结果。你们看到了没有，test() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>
<p>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p>
<h1 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="*args、**kwargs"></a>*args、**kwargs</h1><p>如果我的业务逻辑函数 foo 需要参数怎么办？比如：</p>
<pre><code>def test(name):
    time.sleep(3)
    print(“test函数运行完毕,名字是【%s】” %name)
</code></pre><p>我们可以在定义 wrapper 函数的时候指定参数：</p>
<pre><code>def wrapper(name):
    start_time=time.time()
    func(name)        
     stop_time = time.time()
     print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper
</code></pre><p>这样 test的参数就可以定义在 wrapper 函数中。如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，就多个。当装饰器不知道 test个参数时，我们可以用 * args 来代替：</p>
<pre><code>def wrapper(*args):
    start_time=time.time()
    func(*args)        
    stop_time = time.time()
    print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper
</code></pre><p>如此一来，甭管 test定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 test的业务逻辑了。这时还有读者会问，如果 test函数还定义了一些关键字参数呢？比如：</p>
<pre><code>def test(name,age,gender):
    time.sleep(1)
    print(&apos;test1函数运行完毕,名字是【%s】 年龄是【%s】 性别【%s】&apos; %(name,age,gender))
    return &apos;这是test的返回值&apos;
</code></pre><p>这时，你就可以把 wrapper 函数指定关键字函数：</p>
<pre><code>def wrapper(*args,**kwargs):
    start_time=time.time()
    func(*args,**kwargs)
    stop_time = time.time()
    print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper
</code></pre><h1 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h1><p>装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数test 。装饰器的语法允许我们在调用时，提供其它参数，比如@timmer()。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定如何计算时间，因为不同业务函数可能需要的计算时间方式是不一样的。</p>
<pre><code>import time

def cal_time(timing):
    def timmer(func):
        def wrapper(*args, **kwargs):
                start_time = time.time()
                func(*args, **kwargs)
                stop_time = time.time()
                if timing == &quot;True&quot;:
                    print(&quot;运行时间是%s&quot; %(stop_time - start_time))
                else:
                    print(&quot;鬼知道他运行了多长时间&quot;)
        return wrapper
    return timmer

@cal_time(timing=&quot;True&quot;)
def test():
    time.sleep(3)
    print(&quot;test函数运行完毕&quot;)

test()
</code></pre><p>上面的cal_time是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用@cal_time(timing=”True”)调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。</p>
<p> @cal_time(timing=”True”等价于@timmer</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;讲 Python 装饰器前，我想先举个例子，虽有点污，但跟装饰器这个话题很贴切。每个人都有的内裤主要功能是用来遮羞，但是到了冬天它没法为我们
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（七）：闭包</title>
    <link href="http://yjscloud.com/2018/01/20/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85/"/>
    <id>http://yjscloud.com/2018/01/20/Python当歌（七）：闭包/</id>
    <published>2018-01-20T07:54:22.000Z</published>
    <updated>2018-02-07T11:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是程序运行时变量可被访问的范围，定义在函数内的变量是局部变量，局部变量的作用范围只能是函数内部范围内，它不能在函数外引用。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-1.png" alt="7-1"></p>
<p>定义在模块最外层的变量是全局变量，它是全局范围内可见的，当然在函数里面也可以读取到全局变量的。例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-2.png" alt="7-2"></p>
<h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><p>函数不仅可以定义在模块的最外层，还可以定义在另外一个函数的内部，像这种定义在函数里面的函数称之为嵌套函数（nested function）例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-3.png" alt="7-3"></p>
<p>对于嵌套函数，它可以访问到其外层作用域中声明的非局部（non-local）变量，比如代码示例中的变量 msg 可以被嵌套函数 printer 正常访问。</p>
<p>那么有没有一种可能即使脱离了函数本身的作用范围，局部变量还可以被访问得到呢？答案是闭包。</p>
<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>函数身为第一类对象，它可以作为函数的返回值返回，现在我们来考虑如下的例子：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-4.png" alt="7-4"></p>
<p>这段代码和前面例子的效果完全一样，同样输出 “python”。不同的地方在于内部函数 printer 直接作为返回值返回了。</p>
<p>一般情况下，函数中的局部变量仅在函数的执行期间可用，一旦 print_msg() 执行过后，我们会认为 msg变量将不再可用。然而，在这里我们发现 print_msg 执行完之后，在调用 another 的时候 msg 变量的值正常输出了，这就是闭包的作用，闭包使得局部变量在函数外被访问成为可能。<br>这里的 another 就是一个闭包，闭包本质上是一个函数，它有两部分组成，printer 函数和变量 msg。闭包使得这些变量的值始终保存在内存中。</p>
<p>闭包，顾名思义，就是一个封闭的包裹，里面包裹着自由变量，就像在类里面定义的属性值一样，自由变量的可见范围随同包裹，哪里可以访问到这个包裹，哪里就可以访问到这个自由变量。</p>
<h1 id="为什么要使用闭包"><a href="#为什么要使用闭包" class="headerlink" title="为什么要使用闭包"></a>为什么要使用闭包</h1><p>闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。这一点与面向对象编程是非常类似的，在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。一般来说，当对象中只有一个方法时，这时使用闭包是更好的选择。来看一个例子：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-5.png" alt="7-5"></p>
<p>这比用类来实现更优雅，此外装饰器也是基于闭包的一中应用场景。<br>所有函数都有一个 <strong>closure</strong>属性，如果这个函数是一个闭包的话，那么它返回的是一个由 cell 对象 组成的元组对象。cell 对象的cell_contents 属性就是闭包中的自由变量。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-6.png" alt="7-6"></p>
<p>这解释了为什么局部变量脱离函数之后，还可以在函数之外被访问的原因的，因为它存储在了闭包的 cell_contents中了。</p>
<p>原文地址：<a href="https://foofish.net/python-closure.html" target="_blank" rel="external">一步一步教你认识Python闭包</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念。&lt;/p&gt;
&lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;p&gt;作用域是程序运行时变
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（六）：迭代器、生成器</title>
    <link href="http://yjscloud.com/2018/01/19/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yjscloud.com/2018/01/19/Python当歌（六）：迭代器、生成器/</id>
    <published>2018-01-19T03:15:23.000Z</published>
    <updated>2018-02-07T11:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="迭代的概念"><a href="#迭代的概念" class="headerlink" title="迭代的概念"></a>迭代的概念</h2><p>迭代器即迭代的工具，那什么是迭代呢？</p>
<p>迭代是一个重复的过程，每次重复即一次迭代，并且每次迭代的结果都是下一次迭代的初始值</p>
<pre><code>while True: #只是单纯地重复，因而不是迭代
    print(&apos;===&gt;&apos;) 

l=[1,2,3]
count=0
while count &lt; len(l): #迭代
    print(l[count])
count+=1
</code></pre><h2 id="理解迭代器"><a href="#理解迭代器" class="headerlink" title="理解迭代器"></a>理解迭代器</h2><p>(1)为何要有迭代器？</p>
<p>对于序列类型：字符串、列表、元组，我们可以使用索引的方式迭代取出其包含的元素。但对于字典、集合、文件等类型是没有索引的，若还想取出其内部包含的元素，则必须找出一种不依赖于索引的迭代方式，这就是迭代器</p>
<p>(2)什么是可迭代对象？</p>
<p>可迭代对象指的是内置有<strong>iter</strong>方法的对象，即obj.<strong>iter</strong>，如下</p>
<pre><code>&apos;hello&apos;.__iter__
(1,2,3).__iter__
[1,2,3].__iter__
{&apos;a&apos;:1}.__iter__
{&apos;a&apos;,&apos;b&apos;}.__iter__
open(&apos;a.txt&apos;).__iter__
</code></pre><p>（3）什么是迭代器对象？</p>
<p>可迭代对象执行obj.<strong>iter</strong>()得到的结果就是迭代器对象</p>
<p>而迭代器对象指的是即内置有<strong>iter</strong>又内置有<strong>next</strong>方法的对象</p>
<p>文件类型是迭代器对象</p>
<pre><code>open(&apos;a.txt&apos;).__iter__()
open(&apos;a.txt&apos;).__next__()
</code></pre><p>（4）注意：</p>
<p>迭代器对象一定是可迭代对象，而可迭代对象不一定是迭代器对象</p>
<h2 id="迭代器对象的使用"><a href="#迭代器对象的使用" class="headerlink" title="迭代器对象的使用"></a>迭代器对象的使用</h2><pre><code>dic={&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3}
iter_dic=dic.__iter__() #得到迭代器对象，迭代器对象即有__iter__又有__next__，
</code></pre><p>但是：迭代器.<strong>iter</strong>()得到的仍然是迭代器本身</p>
<pre><code>iter_dic.__iter__() is iter_dic #True
print(iter_dic.__next__()) #等同于next(iter_dic)
print(iter_dic.__next__()) #等同于next(iter_dic)
print(iter_dic.__next__()) #等同于next(iter_dic)
print(iter_dic.__next__()) #抛出异常StopIteration，或者说结束标志
</code></pre><p>有了迭代器，我们就可以不依赖索引迭代取值了</p>
<pre><code>iter_dic=dic.__iter__()
while 1:
    try:
        k=next(iter_dic)
        print(dic[k])
    except StopIteration:
        break
</code></pre><p>这么写太丑陋了，需要我们自己捕捉异常，控制next，python这么牛逼，能不能帮我解决呢？能，请看for循环</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>基于for循环，我们可以完全不再依赖索引去取值了</p>
<pre><code>dic={&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3}
for k in dic:
    print(dic[k])
</code></pre><p>for循环的工作原理</p>
<p>1：执行in后对象的dic.<strong>iter</strong>()方法，得到一个迭代器对象iter_dic</p>
<p>2: 执行next(iter_dic),将得到的值赋值给k,然后执行循环体代码</p>
<p>3: 重复过程2，直到捕捉到异常StopIteration,结束循环</p>
<h2 id="迭代器的优缺点"><a href="#迭代器的优缺点" class="headerlink" title="迭代器的优缺点"></a>迭代器的优缺点</h2><p>优点：</p>
<ul>
<li>提供一种统一的、不依赖于索引的迭代方式</li>
<li>惰性计算，节省内存</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法获取长度（只有在next完毕才知道到底有几个值）</li>
<li>一次性的，只能往后走，不能往前退</li>
</ul>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h2><p>通函数用 return 返回一个值，和 Java 等其他语言是一样的，然而在 Python 中还有一种函数，用关键字 yield 来返回值，这种函数叫生成器函数，函数被调用时会返回一个生成器对象，生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁。</p>
<p>最简单的生成器函数：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-1.png" alt="6-1"></p>
<p>func 就是一个生成器函数，调用该函数时返回对象就是生成器 g ，这个生成器对象的行为和迭代器是非常相似的，可以用在 for 循环等场景中。注意 yield 对应的值在函数被调用时不会立刻返回，而是调用next方法时（本质上 for 循环也是调用 next 方法）才返回</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-2.png" alt="6-2"></p>
<p>那为什么要用生成器呢？显然，用生成器在逼格上要比迭代器高几个等级，它没有那么多冗长代码了，而且性能上一样的高效，为什么不用呢？来看看用生成器实现斐波那契数列有多简单。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-3.png" alt="6-3"></p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，但是它返回的是一个生成器对象而不是列表对象。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-4.png" alt="6-4"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h1&gt;&lt;h2 id=&quot;迭代的概念&quot;&gt;&lt;a href=&quot;#迭代的概念&quot; class=&quot;headerlink&quot; title=&quot;迭代的概念&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（五）：文件读写</title>
    <link href="http://yjscloud.com/2018/01/18/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://yjscloud.com/2018/01/18/Python当歌（五）：文件读写/</id>
    <published>2018-01-18T02:40:14.000Z</published>
    <updated>2018-02-07T11:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>计算机系统分为：计算机硬件，操作系统，应用程序三部分。</p>
<p>我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。<br>有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程：</p>
<ol>
<li>打开文件，得到文件句柄并赋值给一个变量</li>
<li>通过句柄对文件进行操作</li>
<li>关闭文件</li>
</ol>
<h1 id="在python中"><a href="#在python中" class="headerlink" title="在python中"></a>在python中</h1><p>(1)打开文件，得到文件句柄并赋值给一个变量</p>
<p>f=open(‘a.txt’,’r’,encoding=’utf-8’) #默认打开模式就为r</p>
<p>(2) 通过句柄对文件进行操作</p>
<p>data=f.read()</p>
<p>(3) 关闭文件</p>
<p>f.close()</p>
<p>分析一下f=open(‘a.txt’,’r’)过程：</p>
<p>1、由应用程序向操作系统发起系统调用open(…)</p>
<p>2、操作系统打开该文件，并返回一个文件句柄给应用程序</p>
<p>3、应用程序将文件句柄赋值给变量f</p>
<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p>1、强调第一点：</p>
<p>打开一个文件包含两部分资源：操作系统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源一个不落地回收，回收方法为：</p>
<p>（1）f.close() #回收操作系统级打开的文件</p>
<p>（2）del f #回收应用程序级的变量</p>
<p>其中del f一定要发生在f.close()之后，否则就会导致操作系统打开的文件还没有关闭，白白占用资源，而python自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close()。</p>
<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>
<pre><code>with open(&apos;a.txt&apos;,&apos;w&apos;) as f:
    pass

with open(&apos;a.txt&apos;,&apos;r&apos;) as read_f,open(&apos;b.txt&apos;,&apos;w&apos;) as write_f:
    data=read_f.read()
write_f.write(data)
</code></pre><p>2、强调第二点：</p>
<p>f=open(…)是由操作系统打开文件，那么如果我们没有为open指定编码，那么打开文件的默认编码很明显是操作系统说了算了，操作系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。若要保证不乱码，文件以什么方式存的，就要以什么方式打开。<br>f=open(‘a.txt’,’r’,encoding=’utf-8’)</p>
<p>3、强调第三点</p>
<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
<pre><code>try:
    f = open(&apos;/path/to/file&apos;, &apos;r&apos;)
    print(f.read())
finally:
    if f:
        f.close()
</code></pre><h1 id="打开文件的模式"><a href="#打开文件的模式" class="headerlink" title="打开文件的模式"></a>打开文件的模式</h1><p>（1）打开文件的模式有(默认为文本模式)：</p>
<ul>
<li>r ，只读模式【默认模式，文件必须存在，不存在则抛出异常】</li>
<li>w，只写模式【不可读；不存在则创建；存在则清空内容】</li>
<li>a， 之追加写模式【不可读；不存在则创建；存在则只追加内容】</li>
</ul>
<p>（2）对于非文本文件，我们只能使用b模式，”b”表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式）</p>
<ul>
<li>rb </li>
<li>wb</li>
<li>ab</li>
</ul>
<p>注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码</p>
<p>（3）了解部分</p>
<ul>
<li>“+” 表示可以同时读写某个文件</li>
<li>r+， 读写【可读，可写】</li>
<li>w+，写读【可读，可写】</li>
<li>a+， 写读【可读，可写】</li>
<li>x， 只写模式【不可读；不存在则创建，存在则报错】</li>
<li>x+ ，写读【可读，可写】</li>
</ul>
<h1 id="操作文件的方法"><a href="#操作文件的方法" class="headerlink" title="操作文件的方法"></a>操作文件的方法</h1><p>（1）掌握</p>
<ul>
<li>f.read() #读取所有内容,光标移动到文件末尾</li>
<li>f.readline() #读取一行内容,光标移动到第二行首部</li>
<li>f.readlines() #读取每一行内容,存放于列表中</li>
<li>f.write(‘1111\n222\n’) #针对文本模式的写,需要自己写换行符</li>
<li>f.write(‘1111\n222\n’.encode(‘utf-8’)) #针对b模式的写,需要自己写换行符</li>
<li>f.writelines([‘333\n’,’444\n’]) #文件模式</li>
<li>f.writelines([bytes(‘333\n’,encoding=’utf-8’),’444\n’.encode(‘utf-8’)]) #b模式</li>
</ul>
<p>（2）了解</p>
<ul>
<li>f.readable() #文件是否可读</li>
<li>f.writable() #文件是否可读</li>
<li>f.closed #文件是否关闭</li>
<li>f.encoding #如果文件打开模式为b,则没有该属性</li>
<li>f.flush() #立刻将文件内容从内存刷到硬盘</li>
<li>f.name</li>
</ul>
<h1 id="文件内光标移动"><a href="#文件内光标移动" class="headerlink" title="文件内光标移动"></a>文件内光标移动</h1><p>（1）read(3)：</p>
<ul>
<li>文件打开方式为文本模式时，代表读取3个字符</li>
<li>文件打开方式为b模式时，代表读取3个字节</li>
</ul>
<p>（2）其余的文件内光标移动都是以字节为单位如seek，tell，truncate</p>
<p>注意：</p>
<ul>
<li>seek有三种移动方式0，1，2，其中1和2必须在b模式下进行，但无论哪种模式，都是以bytes为单位移动的</li>
<li><p>truncate是截断文件，所以文件的打开方式必须可写，但是不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果：</p>
<pre><code>import time
with open(&apos;test.txt&apos;,&apos;rb&apos;) as f:
    f.seek(0,2)
while True:
    line=f.readline()
    if line:
        print(line.decode(&apos;utf-8&apos;))
    else:
        time.sleep(0.2)
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;计算机系统分为：计算机硬件，操作系统，应用程序三部分。&lt;/p&gt;
&lt;p&gt;我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（四）：函数</title>
    <link href="http://yjscloud.com/2018/01/17/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yjscloud.com/2018/01/17/Python当歌（四）：函数/</id>
    <published>2018-01-17T01:49:07.000Z</published>
    <updated>2018-02-07T11:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><p>函数是什么?</p>
<p>想象生活中的例子，修理工需要实现准备好工具箱里面放好锤子，扳手，钳子等工具，然后遇到锤钉子的场景，拿来锤子用就可以，而无需临时再制造一把锤子。</p>
<p>修理工===&gt;程序员</p>
<p>具备某一功能的工具===&gt;函数</p>
<p>要想使用工具，需要事先准备好，然后拿来就用且可以重复使用要想用函数，需要先定义，再使用。</p>
<h1 id="函数分类"><a href="#函数分类" class="headerlink" title="函数分类"></a>函数分类</h1><p>（1）内置函数</p>
<p>为了方便我们的开发，针对一些简单的功能，python解释器已经为我们定义好了的函数即内置函数。对于内置函数，我们可以拿来就用而无需事先定义，如len(),sum(),max()</p>
<p>（2）自定义函数</p>
<p>很明显内置函数所能提供的功能是有限的，这就需要我们自己根据需求，事先定制好我们自己的函数来实现某种功能，以后，在遇到应用场景时，调用自定义的函数即可。</p>
<p>（3）如何自定义函数？</p>
<pre><code>语法：
    def 函数名(参数1,参数2,参数3,...):
        &apos;&apos;&apos;注释&apos;&apos;&apos;
        函数体
        return 返回的值
</code></pre><p>ps:函数名要能反映其意义</p>
<p>（4）函数使用的原则：先定义，再调用</p>
<p>函数即“变量”，“变量”必须先定义后引用。未定义而直接引用函数，就相当于在引用一个不存在的变量名</p>
<p>测试一：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-1.png" alt="3-1"></p>
<p>测试二：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-2.png" alt="3-2"></p>
<p>结论:函数的使用,必须遵循原则:先定义,后调用；我们在使用函数时,一定要明确地区分定义阶段和调用阶段。</p>
<pre><code>#定义阶段
def foo():
    print(&apos;from foo&apos;)
    bar()
def bar():
    print(&apos;from bar&apos;)
#调用阶段
foo()
</code></pre><p>ps:函数在定义阶段只检测语法，不执行代码。也就说，语法错误在函数定义阶段就会检测出来，而代码的逻辑错误只有在执行时才会知道</p>
<p>(5)定义函数的三种形式</p>
<p>1、无参：应用场景仅仅只是执行一些操作，比如与用户交互，打印</p>
<p>2、有参：需要根据外部传进来的参数，才能执行相应的逻辑，比如统计长度，求最大值最小值</p>
<p>3、空函数：设计代码结构</p>
<p>例子：<br>    <img src="http://p3q1rwnbl.bkt.clouddn.com/3-3.png" alt="3-3"></p>
<p>结论：定义时无参，意味着调用时也无需传入参数；定义时有参，意味着调用时则必须传入参数</p>
<p>（6)调用函数</p>
<p>函数的调用：函数名加括号</p>
<ul>
<li><p>先找到名字</p>
</li>
<li><p>根据名字调用代码</p>
</li>
</ul>
<p>函数调用的三种形式：</p>
<ul>
<li><p>语句形式：foo()</p>
</li>
<li><p>表达式形式：3*len(‘hello’)</p>
</li>
<li><p>当中另外一个函数的参数：range(len(‘hello’))</p>
</li>
</ul>
<p>函数返回值：</p>
<ul>
<li><p>无return-&gt;None</p>
</li>
<li><p>return 1个值-&gt;返回1个值</p>
</li>
<li><p>return 逗号分隔多个值-&gt;元组</p>
</li>
</ul>
<p>什么时候该有返回值？</p>
<p>调用函数，经过一系列的操作，最后要拿到一个明确的结果，则必须要有返回值（通常有参函数需要有返回值，输入参数，经过计算，得到一个最终的结果）</p>
<p>什么时候不需要有返回值？</p>
<p>调用函数，仅仅只是执行一系列的操作，最后不需要得到什么结果，则无需有返回值（通常无参函数不需要有返回值）</p>
<p>（7）函数的参数<br>形参即变量名，实参即变量值，函数调用时，将值绑定到变量名上，函数调用结束，解除绑定。</p>
<p>1、位置参数：按照从左到右的顺序定义的参数</p>
<p>   位置形参：必选参数</p>
<p>   位置实参：按照位置给形参传值</p>
<p>2、关键字参数：按照key=value的形式定义的实参</p>
<p>   无需按照位置为形参传值</p>
<p>   注意的问题：</p>
<ul>
<li>关键字实参必须在位置实参右面</li>
<li>对同一个形参不能重复传值</li>
</ul>
<p>3、默认参数：形参在定义时就已经为其赋值</p>
<p>可以传值也可以不传值，经常需要变得参数定义成位置形参，变化较小的参数定义成默认参数（形参）</p>
<p> 注意的问题：</p>
<ul>
<li>只在定义时赋值一次</li>
<li>默认参数的定义应该在位置形参右面</li>
<li>默认参数通常应该定义成不可变类型</li>
</ul>
<p>4、可变长参数：</p>
<p>  可变长指的是实参值的个数不固定</p>
<p>  而实参有按位置和按关键字两种形式定义，针对这两种形式的可变长，形参对应有两种解决方案来完整地存放它们，分别是<em>args（列表），*</em>kwargs（字典）</p>
<p>测试：*args</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-4.png" alt="3-4"></p>
<p>测试：**kwargs</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-5.png" alt="3-5"></p>
<p>5、命名关键字参数：*后定义的参数，必须被传值（有默认值的除外），且必须按照关键字实参的形式传递可以保证，传入的参数中一定包含某些关键字。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-6.png" alt="3-6"></p>
<h1 id="函数的变量、递归以及内置函数"><a href="#函数的变量、递归以及内置函数" class="headerlink" title="函数的变量、递归以及内置函数"></a>函数的变量、递归以及内置函数</h1><h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>在子程序中定义的变量称为局部变量，在程序的一开始定义的变量称为全局变量。</p>
<p>全局变量作用域是整个程序，局部变量作用域是定义该变量的子程序。</p>
<p>当全局变量与局部变量同名时：在定义局部变量的子程序内，局部变量起作用；在其它地方全局变量起作用。</p>
<pre><code>name=&apos;xwq&apos;
def change_name():
    print(&apos;我的名字&apos;,name)    #全局变量起作用
change_name()

def change_name():
    name=&apos;帅了一笔&apos;
    print(&apos;我的名字&apos;,name)        #局部变量起作用
    change_name()
print(name)

def change_name():
    global name
    name=&apos;帅了一笔&apos;
    print(&apos;我的名字&apos;,name)        #因为global参数全局变量变为‘帅了一笔’而非xwq,
change_name()
</code></pre><p>ps：nonlocal参数</p>
<pre><code>name = &quot;lf&quot;
def weihou():
    name = &quot;xwq&quot;
    def weiweihou():
        nonlocal name   # nonlocal，指定上一级变量，如果没有就继续往上直到找到为止
        name = &quot;冷静&quot;    
    weiweihou()
    print(name)
print(name)
weihou()
print(name)
</code></pre><p>运行结果为：</p>
<pre><code>lf
冷静
lf
</code></pre><h2 id="嵌套函数和作用域"><a href="#嵌套函数和作用域" class="headerlink" title="嵌套函数和作用域"></a>嵌套函数和作用域</h2><pre><code>name = &quot;xwq&quot;

def change_name():
    name = &quot;xwq2&quot;

    def change_name2():
        name = &quot;xwq3&quot;
        print(&quot;第3层打印&quot;,name)

    change_name2() #调用内层函数
    print(&quot;第2层打印&quot;,name)

change_name()
print(&quot;最外层打印&quot;,name)
</code></pre><p>此时，在最外层调用change_name2()会出现什么效果？没错，出错了， 为什么呢？<br>作用域在定义函数时就已经固定住了，不会随着调用位置的改变而改变。</p>
<p>例一：</p>
<pre><code>name=&apos;alex&apos;

def foo():
    name=&apos;lhf&apos;
    def bar():
        print(name)
    return bar

func=foo()
func()
</code></pre><p>例二：</p>
<pre><code>name=&apos;alex&apos;

def foo():
    name=&apos;lhf&apos;
    def bar():
        name=&apos;wupeiqi&apos;
        def tt():
            print(name)
        return tt
    return bar

func=foo()
func()()
</code></pre><h2 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h2><p>在函数内部，可以调用其他函数。如果在调用一个函数的过程中直接或间接调用自身本身</p>
<pre><code>def calc(n):
    print(n)
    if int(n/2) ==0:
        return n
    return calc(int(n/2))

calc(10)
</code></pre><p>输出：</p>
<pre><code>10
5
2
1
</code></pre><p>递归特性:</p>
<ul>
<li>必须有一个明确的结束条件</li>
<li>每次进入更深一层递归时，问题规模相比上次递归都应有所减少</li>
<li>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）</li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>（1）zip()函数</p>
<p>zip()函数接受0个或多个序列作为参数，返回一个tuple列表。 </p>
<p>zip()函数具体的工作机制是，将每个列表中同一位置的元素取出来组成一个元组，存放到一个列表中，然后返回这个列表。举例说明：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-7.png" alt="3-7"></p>
<p>对于长度不同的seq，zip()函数处理;</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-8.png" alt="3-8"><br>从上面的例子可以看出，当seq的长度不一致时，zip()会以最短的那个seq为主，进行处理，然后将多余的舍弃掉.</p>
<p>zip()对只有一个seq的处理：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-9.png" alt="3-9"></p>
<p>(2)map()函数</p>
<p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。举例说明：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-10.png" alt="3-10"></p>
<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p>
<p>map（）可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-11.png" alt="3-11"></p>
<p>(3)reduce()函数</p>
<p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。举例说明：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-12.png" alt="3-12"></p>
<p>(4)filter()函数</p>
<p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
<p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-13.png" alt="3-13"></p>
<p>把一个序列中的空字符串删掉，可以这么写：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-14.png" alt="3-14"></p>
<p>可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。</p>
<p>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p>
<p>(5)sorted() 函数对所有可迭代的对象进行排序操作。</p>
<p>sort 与 sorted 区别：sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-15.png" alt="3-15"></p>
<p>此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-16.png" alt="3-16"></p>
<p>(6)max()/min()函数</p>
<p>max(iterable, key, default) 求迭代器的最大值，其中iterable 为迭代器，max会for i in … 遍历一遍这个迭代器，然后将迭代器的每一个返回值当做参数传给key=func 中的func(一般用lambda表达式定义) ，然后将func的执行结果传给key，然后以key为标准进行大小的判断。</p>
<p>以下根据不同的判断条件返回最大值也不同</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-17.png" alt="3-17"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;函数基础&quot;&gt;&lt;a href=&quot;#函数基础&quot; class=&quot;headerlink&quot; title=&quot;函数基础&quot;&gt;&lt;/a&gt;函数基础&lt;/h1&gt;&lt;p&gt;函数是什么?&lt;/p&gt;
&lt;p&gt;想象生活中的例子，修理工需要实现准备好工具箱里面放好锤子，扳手，钳子等工具，然后遇到锤钉子的场景
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（三）：字符串格式化</title>
    <link href="http://yjscloud.com/2018/01/17/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>http://yjscloud.com/2018/01/17/Python当歌（三）：字符串格式化/</id>
    <published>2018-01-17T01:13:30.000Z</published>
    <updated>2018-02-07T11:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python的字符串格式化有两种方式: 百分号方式、format方式。</p>
<p>百分号的方式相对来说比较老，而format方式则是比较先进的方式，企图替换古老的方式，目前两者并存。</p>
<h1 id="百分号方式"><a href="#百分号方式" class="headerlink" title="百分号方式"></a>百分号方式</h1><p>格式：%[(name)][flags][width].[precision]typecode</p>
<p>（1）(name)     可选，用于选择指定的key</p>
<p>（2）flags       可选，可供选择的值有:</p>
<ul>
<li>“+”       右对齐；正数前加正好，负数前加负号；</li>
<li>“-“        左对齐；正数前无符号，负数前加负号；</li>
<li>空格    右对齐；正数前加空格，负数前加负号；</li>
<li>0    右对齐；正数前无符号，负数前加负号；用0填充空白处</li>
</ul>
<p>（3）    width         可选，占有宽度</p>
<p>（4）    precision   可选，小数点后保留的位数</p>
<p>（5） typecode    必选</p>
<ul>
<li>s，获取传入对象的<strong>str</strong>方法的返回值，并将其格式化到指定位置</li>
<li>r，获取传入对象的<strong>repr</strong>方法的返回值，并将其格式化到指定位置</li>
<li>c，整数：将数字转换成其unicode对应的值，10进制范围为 0 &lt;= i &lt;= 1114111（py27则只支持0-255）；字符：将字符添加到指定位置</li>
<li>o，将整数转换成 八  进制表示，并将其格式化到指定位置</li>
<li>x，将整数转换成十六进制表示，并将其格式化到指定位置</li>
<li>d，将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置</li>
<li>e，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e）</li>
<li>E，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E）</li>
<li>f， 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位）</li>
<li>F，同上</li>
<li>g，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；）</li>
<li>G，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；）</li>
<li>%，当字符串中存在格式化标志时，需要用 %%表示一个百分号</li>
</ul>
<p>注：Python中百分号格式化是不存在自动将整数转换成二进制表示的方式</p>
<p>常用格式化：</p>
<pre><code>tpl = &quot;i am %s&quot; % &quot;alex&quot; 

tpl = &quot;i am %s age %d&quot; % (&quot;alex&quot;, 18)

tpl = &quot;i am %(name)s age %(age)d&quot; % {&quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18}

tpl = &quot;percent %.2f&quot; % 99.97623

tpl = &quot;i am %(pp).2f&quot; % {&quot;pp&quot;: 123.425556, }

tpl = &quot;i am %.2f %%&quot; % {&quot;pp&quot;: 123.425556, }
</code></pre><h1 id="Format方式"><a href="#Format方式" class="headerlink" title="Format方式"></a>Format方式</h1><p>格式：[[fill]align][sign][#][0][width][,][.precision][type]</p>
<p>（1）fill    【可选】空白处填充的字符</p>
<p>（2）align   【可选】对齐方式（需配合width使用）</p>
<ul>
<li>“&lt;”，内容左对齐</li>
<li>“&gt;”，内容右对齐(默认)</li>
<li>“＝”，内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。 即使：符号+填充物+数字</li>
<li>“^”，内容居中</li>
</ul>
<p>（3）sign    【可选】有无符号数字</p>
<ul>
<li>“+”，正号加正，负号加负；</li>
<li>“-“，正号不变，负号加负；</li>
<li>空格 ，正号空格，负号加负；</li>
</ul>
<p>（4）”#”        【可选】对于二进制、八进制、十六进制，如果加上#，会显示 0b/0o/0x，否则不显示</p>
<p>（5)”,”      【可选】为数字添加分隔符，如：1,000,000</p>
<p>（6）width  【可选】格式化位所占宽度</p>
<p>（7）.precision 【可选】小数位保留精度</p>
<p>（8）type     【可选】格式化类型</p>
<p>传入” 字符串类型 “的参数</p>
<ul>
<li>s，格式化字符串类型数据</li>
<li>空白，未指定类型，则默认是None，同s</li>
</ul>
<p>传入“ 整数类型 ”的参数</p>
<ul>
<li>b，将10进制整数自动转换成2进制表示然后格式化</li>
<li>c，将10进制整数自动转换为其对应的unicode字符</li>
<li>d，十进制整数</li>
<li>o，将10进制整数自动转换成8进制表示然后格式化；</li>
<li>x，将10进制整数自动转换成16进制表示然后格式化（小写x）</li>
<li>X，将10进制整数自动转换成16进制表示然后格式化（大写X）</li>
</ul>
<p>传入“ 浮点型或小数类型 ”的参数</p>
<ul>
<li>e，转换为科学计数法（小写e）表示，然后格式化；</li>
<li>E，转换为科学计数法（大写E）表示，然后格式化;</li>
<li>f ，转换为浮点型（默认小数点后保留6位）表示，然后格式化；</li>
<li>F， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；</li>
<li>g，自动在e和f中切换</li>
<li>G，自动在E和F中切换</li>
<li>%  显示百分比（默认显示小数点后6位）</li>
</ul>
<p>常用格式化：</p>
<pre><code>tpl = &quot;i am {}, age {}, {}&quot;.format(&quot;seven&quot;, 18, &apos;alex&apos;)

tpl = &quot;i am {}, age {}, {}&quot;.format(*[&quot;seven&quot;, 18, &apos;alex&apos;])

tpl = &quot;i am {0}, age {1}, really {0}&quot;.format(&quot;seven&quot;, 18)

tpl = &quot;i am {0}, age {1}, really {0}&quot;.format(*[&quot;seven&quot;, 18])

tpl = &quot;i am {name}, age {age}, really {name}&quot;.format(name=&quot;seven&quot;, age=18)

tpl = &quot;i am {name}, age {age}, really {name}&quot;.format(**{&quot;name&quot;: &quot;seven&quot;, &quot;age&quot;: 18})

tpl = &quot;i am {0[0]}, age {0[1]}, really {0[2]}&quot;.format([1, 2, 3], [11, 22, 33])

tpl = &quot;i am {:s}, age {:d}, money {:f}&quot;.format(&quot;seven&quot;, 18, 88888.1)

tpl = &quot;i am {:s}, age {:d}&quot;.format(*[&quot;seven&quot;, 18])

tpl = &quot;i am {name:s}, age {age:d}&quot;.format(name=&quot;seven&quot;, age=18)

tpl = &quot;i am {name:s}, age {age:d}&quot;.format(**{&quot;name&quot;: &quot;seven&quot;, &quot;age&quot;: 18})

tpl = &quot;numbers: {:b},{:o},{:d},{:x},{:X}, {:%}&quot;.format(15, 15, 15, 15, 15, 15.87623, 2)

tpl = &quot;numbers: {:b},{:o},{:d},{:x},{:X}, {:%}&quot;.format(15, 15, 15, 15, 15, 15.87623, 2)

tpl = &quot;numbers: {0:b},{0:o},{0:d},{0:x},{0:X}, {0:%}&quot;.format(15)

tpl = &quot;numbers: {num:b},{num:o},{num:d},{num:x},{num:X}, {num:%}&quot;.format(num=15)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python的字符串格式化有两种方式: 百分号方式、format方式。&lt;/p&gt;
&lt;p&gt;百分号的方式相对来说比较老，而format方式则是比较先进的方式，企图替换古老的方式，目前两者并存。&lt;/p&gt;
&lt;h1 id=&quot;百分号方式&quot;&gt;&lt;a href=&quot;#百分号方式&quot; class=&quot;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（二）：基础数值类型</title>
    <link href="http://yjscloud.com/2018/01/16/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yjscloud.com/2018/01/16/Python当歌（二）：基础数值类型/</id>
    <published>2018-01-16T10:31:58.000Z</published>
    <updated>2018-02-07T11:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><p>所有的功能，都放在int里</p>
<p>int:将字符串转换为数字</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%881%EF%BC%89.png" alt="二（1）"></p>
<p>bit_lenght：当前数字的二进制，至少用n位表示</p>
<pre><code>r = age.bit_length()
</code></pre><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%882%EF%BC%89.png" alt="二（2）"></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>如：’wupeiqi’、’alex’</p>
<p>注：字符串一旦创建，不可修改，一旦修改或者拼接，都会造成重新生成字符串。</p>
<p>每个字符串都具备如下功能：</p>
<p>（1）首字母大写</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%883%EF%BC%89.png" alt="二（3）"></p>
<p>（2）所有变小写，casefold（）更牛逼，很多未知的对相应变小写</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%884%EF%BC%89.png" alt="二（4）"></p>
<p>（3）设置宽度，并将内容居中</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%885%EF%BC%89.png" alt="二（5）"></p>
<p>注：20代指总长度，*空白未知填充，一个字符，可有可无</p>
<p>设置宽度，并将内容居右：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%886%EF%BC%89.png" alt="二（6）"></p>
<p>设置宽度，并将内容居左： </p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%887%EF%BC%89.png" alt="二（7）"></p>
<p>（4）去字符串中寻找，寻找子序列的出现次数：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%888%EF%BC%89.png" alt="二（8）"></p>
<p>也可在限定范围内寻找</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%889%EF%BC%89.png" alt="二（9）"></p>
<p>（5）以什么什么结尾：endswith（），以什么什么开始：startswith（）</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8810%EF%BC%89.png" alt="二（10）"></p>
<p>（6）断句方法</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8811%EF%BC%89.png" alt="二（11）"></p>
<p>注：20的意思是以20个字符为空格作为断句</p>
<p>（7）从开始往后找，找到第一个之后，获取其未知</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8812%EF%BC%89.png" alt="二（12）"></p>
<p>（8）Index（）找不到，报错 </p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8813%EF%BC%89.png" alt="二（13）"></p>
<p>（9）格式化，将一个字符串中的占位符替换为指定的值 </p>
<p>使用关键字进行匹配</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8814%EF%BC%89.png" alt="二（14）"></p>
<p>使用数字进行匹配</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8815%EF%BC%89.png" alt="二（15）"></p>
<p>(10)格式化，传入的值 {“name”: ‘alex’, “a”: 19} </p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-16.png" alt="2-16"></p>
<p>（11）字符串中是否只包含字母和数字</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-17.png" alt="2-17"></p>
<p>（12）是否是字母和汉字</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-18.png" alt="2-18"></p>
<p>（13）当前输入是否是数字</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-19.png" alt="2-19"></p>
<p>（14）是否存在不可显示的字符</p>
<pre><code># \t   制表符
# \n   换行
</code></pre><p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-20.png" alt="2-20"></p>
<p>(15)判断是否全部是空格</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-21.png" alt="2-21"></p>
<p>（16）判断是否是标题</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-22.png" alt="2-22"></p>
<p>(17)将字符串中的每一个元素按照指定分隔符进行拼接</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-23.png" alt="2-23"></p>
<p>（18)判断是否全部是大小写和转换为大小写</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-24.png" alt="2-24"></p>
<p>(19)移除指定字符串，有限最多匹配</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-25.png" alt="2-25"></p>
<p>lstrip()和rstrip()去除左右空白，也可以去除去除\t \n</p>
<p>（20）分割为三部分</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-26.png" alt="2-26"></p>
<p>（21）分割为指定个数</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-27.png" alt="2-27"></p>
<p>（22）分割，只能根据，true，false：是否保留换行</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-28.png" alt="2-28"></p>
<p>(23)以xxx开头，以xx结尾</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-29.png" alt="2-29"></p>
<p>(24)大小写转换</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-30.png" alt="2-30"></p>
<p>(25)字母，数字，下划线 ： 标识符 def  class</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-31.png" alt="2-31"></p>
<p>(26)将指定字符串替换为指定字符串</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-32.png" alt="2-32"></p>
<p>以上方法中join、split、find、strip、upper、lower、replace这7个方法比较常用</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>如：[11,22,33]、[‘wupeiqi’, ‘alex’]</p>
<p>每个列表都具备如下功能：</p>
<p>（1)原来值最后追加</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-33.png" alt="2-33"></p>
<p>(2)清空列表</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-34.png" alt="2-34"></p>
<p>(3)拷贝，浅拷贝</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-35.png" alt="2-35"></p>
<p>(4)计算元素出现的次数</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-36.png" alt="2-36"></p>
<p>(5)根据值获取当前值索引位置（左边优先）</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-37.png" alt="2-37"></p>
<p>(6)在指定索引位置插入元素</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-38.png" alt="2-38"></p>
<p>(7)删除某个值(1.指定索引；2. 默认最后一个)，并获取删除的值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-39.png" alt="2-39"></p>
<p>还可以指定索引来删除</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-40.png" alt="2-40"></p>
<p>(8)删除列表中的指定值，左边优先</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-41.png" alt="2-41"></p>
<p>(9)将当前列表进行翻转</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-42.png" alt="2-42"></p>
<p>(10)列表的排序</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-43-1.png" alt="2-43"></p>
<p>注：列表中可以嵌套任何类型，列表是有序的，列表中的元素可以是数字，字符串,列表，布尔值…所有的都能放进去，列表元素可以被查询、修改和删除，可以通过索引和切片进行查找，可以用in操作判断一个元素是否在列表中例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-43.png" alt="2-44"></p>
<p>取嵌套列表中的元素例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-44.png" alt="2-45"></p>
<p>也可以将字符串转换列表，其内部使用for循环，例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-45.png" alt="2-46"></p>
<p>也可以将列表转换成字符串，需要自己写for循环一个一个处理： 既有数字又有字符串，例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-46.png" alt="2-47"></p>
<p>也可以直接使用字符串join方法：列表中的元素只有字符串，例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-47.png" alt="2-48"></p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>如：(11,22,33)、(‘wupeiqi’, ‘alex’)</p>
<p>元组，元素不可被修改，不能被增加或者删除，元组同样可以通过切片索引查询元素</p>
<p>每个元组都具备如下功能：</p>
<p>(1)可以被for循环，可迭代对象</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-48.png" alt="2-49"></p>
<p>(2)转换</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-49.png" alt="2-50"></p>
<p>(3)元组的一级元素不可修改/删除/增加，元组是有序的。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-50.png" alt="2-51"></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>如：{‘name’: ‘wupeiqi’, ‘age’: 18} 、{‘host’: ‘2.2.2.2’, ‘port’: 80]}</p>
<p>ps：循环时，默认循环key</p>
<p>字典两大特点：无序，键唯一</p>
<p>每个字典都具备如下功能：</p>
<p>(1)根据序列，创建字典，并指定统一的值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-51.png" alt="2-52"></p>
<p>(2)根据Key获取值，key不存在时，可以指定默认值（None）</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-52.png" alt="2-53"></p>
<p>(3)删除并获取值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-53.png" alt="2-54"></p>
<p>(4)设置值，已存在，不设置，获取当前key对应的值：不存在，设置，获取当前key对应的值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-54.png" alt="2-55"></p>
<p>(5)更新</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-55.png" alt="2-56"></p>
<p>(6)字典的value可以是任何值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-56.png" alt="2-57"></p>
<p>(7)布尔值(1,0)、列表、字典不能作为字典的key</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-57.png" alt="2-58"></p>
<p>(8)索引方式找到指定元素</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-58.png" alt="2-59"></p>
<p>(9)字典支持 del 删除</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-59.png" alt="2-60"></p>
<p>(10)for循环</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-60.png" alt="2-61"></p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>set是一个无序且不重复的元素集合</p>
<p>每个集合都具备如下功能：</p>
<p>(1)添加</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-61.png" alt="2-62"></p>
<p>(2)清空</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-62.png" alt="2-63"></p>
<p>(3)拷贝</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-63.png" alt="2-64"></p>
<p>(4)随机删</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-64.png" alt="2-65"></p>
<p>(5)指定删除</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-65.png" alt="2-66"></p>
<p>(6)求交集</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-66.png" alt="2-67"></p>
<p>(7)求并集</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-67.png" alt="2-68"></p>
<p>(8)差集</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-68.png" alt="2-69"></p>
<p>(9)交叉补集</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-69.png" alt="2-70"></p>
<p>(10)集合值更新</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-70.png" alt="2-71"></p>
<p>(11)去除集合中的重复值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-71.png" alt="2-72"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字&quot;&gt;&lt;a href=&quot;#数字&quot; class=&quot;headerlink&quot; title=&quot;数字&quot;&gt;&lt;/a&gt;数字&lt;/h1&gt;&lt;p&gt;所有的功能，都放在int里&lt;/p&gt;
&lt;p&gt;int:将字符串转换为数字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3q1rwnbl.b
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（一）：Python入门</title>
    <link href="http://yjscloud.com/2018/01/15/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9APython%E5%85%A5%E9%97%A8/"/>
    <id>http://yjscloud.com/2018/01/15/Python当歌（一）：Python入门/</id>
    <published>2018-01-15T08:47:45.000Z</published>
    <updated>2018-02-07T11:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一句Python代码"><a href="#第一句Python代码" class="headerlink" title="第一句Python代码"></a>第一句Python代码</h1><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%881%EF%BC%89.png" alt="一（1）"></p>
<p>python内部执行过程如下：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%882%EF%BC%89.png" alt="一（2）"></p>
<h1 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h1><p>python解释器在加载 .py 文件中的代码时，会对内容进行编码（默认ascill）<br>ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，其最多只能用 8 位来表示（一个字节），即：2**8 = 256，所以，ASCII码最多只能表示 256 个符号。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%883%EF%BC%89.png" alt="一（3）"><br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%884%EF%BC%89.png" alt="一（4）"></p>
<p>显然ASCII码无法将世界上的各种文字和符号全部表示，所以，就需要新出一种可以代表所有字符和符号的编码，即：Unicode<br>Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，规定虽有的字符和符号最少由 16 位来表示（2个字节），即：2 **16 = 65536。</p>
<p>注：此处说的的是最少2个字节，可能更多UTF-8，是对Unicode编码的压缩和优化，他不再使用最少使用2个字节，而是将所有的字符和符号进行分类：ascii码中的内容用1个字节保存、欧洲的字符用2个字节保存，东亚的字符用3个字节保存。<br>注：在python2中如果在.py文中有中文会报错，需要在文件开头添加一行注释：# -<em>- coding: utf-8 -</em>-，就不会报错，而知python3中可以不用添加，python3已经可以很好的支持中文了。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>当行注视：# 被注释内容<br>多行注释：””” 被注释内容 “””</p>
<h1 id="执行脚本传入参数"><a href="#执行脚本传入参数" class="headerlink" title="执行脚本传入参数"></a>执行脚本传入参数</h1><p>Python有大量的模块，从而使得开发Python程序非常简洁。类库有包括三中：</p>
<p>•    Python内部提供的模块</p>
<p>•    业内开源的模块</p>
<p>•    程序员自己开发的模块</p>
<p>Python内部提供一个 sys 的模块，其中的 sys.argv 用来捕获执行执行python脚本时传入的参数</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%885%EF%BC%89.png" alt="一（5）"></p>
<h1 id="pyc-文件"><a href="#pyc-文件" class="headerlink" title="pyc 文件"></a>pyc 文件</h1><p>执行Python代码时，如果导入了其他的 .py 文件，那么，执行过程中会自动生成一个与其同名的 .pyc 文件，该文件就是Python解释器编译之后产生的字节码。<br>ps：代码经过编译可以产生字节码；字节码通过反编译也可以得到代码。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%886%EF%BC%89.png" alt="一（6）"></p>
<p>上述代码声明了一个变量，变量名为： name，变量name的值为：”xwq”<br>变量的作用：昵称，其代指内存里某个地址中保存的内容</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%887%EF%BC%89.png" alt="一（7）"></p>
<p>变量定义的规则：</p>
<p>变量名只能是 字母、数字或下划线的任意组合，变量名的第一个字符不能是数字</p>
<p>以下关键字不能声明为变量名：[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</p>
<h2 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h2><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%888%EF%BC%89.png" alt="一（8）"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%809.png" alt="一9"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%889%EF%BC%89.png" alt="一（9）"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8810%EF%BC%89.png" alt="一（10）"></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8811%EF%BC%89.png" alt="一（11）"></p>
<h1 id="初识基本数据类型"><a href="#初识基本数据类型" class="headerlink" title="初识基本数据类型"></a>初识基本数据类型</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>2是一个整数的例子。<br>长整数不过是大一些的整数。</p>
<p>3.23和52.3E-4是浮点数的例子。E标记表示10的幂。在这里，52.3E-4表示52.3 * 10-4。<br>(-5+4j)和(2.3-4.6j)是复数的例子。</p>
<p>int（整型）</p>
<p>　　在32位机器上，整数的位数为32位，取值范围为-2<strong>31～2</strong>31-1，即-2147483648～2147483647<br>　　在64位系统上，整数的位数为64位，取值范围为-2<strong>63～2</strong>63-1，即-9223372036854775808～9223372036854775807<br>　　<br>long（长整型）<br>　　<br>　　跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。<br>　　注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。</p>
<p>float（浮点型）<br>　　<br>　　浮点数用来处理实数，即带有小数的数字。类似于C语言中的double类型，占8个字节（64位），其中52位表示底，11位表示指数，剩下的一位表示符号。</p>
<p>complex（复数）<br>　　<br>　　复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数。<br>注：Python中存在小数字池：-5 ～ 257</p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>　　真或假<br>　　<br>　　1 或 0
　　</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>“hello world”</p>
<p>万恶的字符串拼接：python中的字符串在C语言中体现为是一个字符数组，每次创建字符串时候需要在内存中开辟一块连续的空，并且一旦需要修改字符串的话，就需要再次开辟空间，万恶的+号每出现一次就会在内从中重新开辟一块空间。</p>
<p>字符串格式化:<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8812%EF%BC%89.png" alt="一（12）"></p>
<p>PS: 字符串是 %s;整数 %d;浮点数%f</p>
<p>字符串常用功能：移除空白、分割、长度、索引、切片</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>创建列表：</p>
<p>name_list = [‘alex’, ‘seven’, ‘eric’]</p>
<p>基本操作：索引、切片、追加、删除、长度、切片、循环、包含</p>
<h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><p>创建元祖：ages = (11, 22, 33, 44, 55)</p>
<p>基本操作：索引、切片、循环、长度、包含</p>
<h2 id="字典（无序）"><a href="#字典（无序）" class="headerlink" title="字典（无序）"></a>字典（无序）</h2><p>创建字典：person = {“name”: “mr.wu”, ‘age’: 18}</p>
<p>常用操作：索引，新增，删除，键、值、键值对，循环，长度</p>
<p>PS：循环，range，continue 和 break</p>
<h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><p>算数运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8813%EF%BC%89.png" alt="一（13）"></p>
<p>比较运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8814%EF%BC%89.png" alt="一（14）"></p>
<p>赋值运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8815%EF%BC%89.png" alt="一（15）"></p>
<p>逻辑运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8816%EF%BC%89.png" alt="一（16）"></p>
<p>成员运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8818%EF%BC%89.png" alt="一（17）"></p>
<p>身份运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8818%EF%BC%89.png" alt="一（18）"></p>
<p>位运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8819%EF%BC%89.png" alt="一（19）"></p>
<p>运算符优先级：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8820%EF%BC%89.png" alt="一（20）"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一句Python代码&quot;&gt;&lt;a href=&quot;#第一句Python代码&quot; class=&quot;headerlink&quot; title=&quot;第一句Python代码&quot;&gt;&lt;/a&gt;第一句Python代码&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://p3q1rwnbl.bkt.clo
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何用九条命令在一分钟内检查Linux服务器性能?</title>
    <link href="http://yjscloud.com/2017/12/15/%E5%A6%82%E4%BD%95%E7%94%A8%E4%B9%9D%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%9C%A8%E4%B8%80%E5%88%86%E9%92%9F%E5%86%85%E6%A3%80%E6%9F%A5Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/"/>
    <id>http://yjscloud.com/2017/12/15/如何用九条命令在一分钟内检查Linux服务器性能/</id>
    <published>2017-12-15T14:52:37.000Z</published>
    <updated>2017-12-15T15:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uptime命令"><a href="#uptime命令" class="headerlink" title="uptime命令"></a>uptime命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-1.png" alt="1-1"></p>
<p>这个命令可以快速查看机器的负载情况。在Linux系统中，这些数据表示等待CPU资源的进程和阻塞在不可中断IO进程（进程状态为D）的数量。这些数据可以让我们对系统资源使用有一个宏观的了解。</p>
<p>命令的输出分别表示1分钟、5分钟、15分钟的平均负载情况。通过这三个数据，可以了解服务器负载是在趋于紧张还是趋于缓解。如果1分钟平均负载很高，而15分钟平均负载很低，说明服务器正在命令高负载情况，需要进一步排查CPU资源都消耗在了哪里。反之，如果15分钟平均负载很高，1分钟平均负载较低，则有可能是CPU资源紧张时刻已经过去。</p>
<h1 id="dmesg命令"><a href="#dmesg命令" class="headerlink" title="dmesg命令"></a>dmesg命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-2.png" alt="1-2"></p>
<p>该命令会输出系统日志的最后10行。示例中的输出，可以看见一次内核的oom kill和一次TCP丢包。这些日志可以帮助排查性能问题。千万不要忘了这一步。</p>
<h1 id="vmstat命令"><a href="#vmstat命令" class="headerlink" title="vmstat命令"></a>vmstat命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-3.png" alt="1-3"></p>
<p>vmstat(8) 命令，每行会输出一些系统核心指标，这些指标可以让我们更详细的了解系统状态。后面跟的参数1，表示每秒输出一次统计信息，表头提示了每一列的含义，这几介绍一些和性能调优相关的列：</p>
<p>r：等待在CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况，数据中不包含等待IO的进程。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。</p>
<p>free：系统可用内存数（以千字节为单位），如果剩余内存不足，也会导致系统性能问题。下文介绍到的free命令，可以更详细的了解系统内存的使用情况。</p>
<p>si，so：交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。</p>
<p>us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。</p>
<p>上述这些CPU时间，可以让我们很快了解CPU是否出于繁忙状态。一般情况下，如果用户时间和系统时间相加非常大，CPU出于忙于执行指令。如果IO等待时间很长，那么系统的瓶颈可能在磁盘IO。</p>
<p>示例命令的输出可以看见，大量CPU时间消耗在用户态，也就是用户应用程序消耗了CPU时间。这不一定是性能问题，需要结合r队列，一起分析。</p>
<h1 id="mpstat命令"><a href="#mpstat命令" class="headerlink" title="mpstat命令"></a>mpstat命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-4.png" alt="1-4"></p>
<p>该命令可以显示每个CPU的占用情况，如果有一个CPU占用率特别高，那么有可能是一个单线程应用程序引起的。</p>
<h1 id="pidstat命令"><a href="#pidstat命令" class="headerlink" title="pidstat命令"></a>pidstat命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-5.png" alt="1-5"></p>
<p>pidstat命令输出进程的CPU占用率，该命令会持续输出，并且不会覆盖之前的数据，可以方便观察系统动态。</p>
<h1 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-6.png" alt="1-6"></p>
<p>r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。</p>
<p>await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。</p>
<p>avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。</p>
<p>%util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。</p>
<p>如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。</p>
<h1 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-7.png" alt="1-7"></p>
<p>free命令可以查看系统内存的使用情况，-m参数表示按照兆字节展示。最后两列分别表示用于IO缓存的内存数，和用于文件系统页缓存的内存数。需要注意的是，第二行-/+ buffers/cache，看上去缓存占用了大量内存空间。</p>
<p>这是Linux系统的内存使用策略，尽可能的利用内存，如果应用程序需要内存，这部分内存会立即被回收并分配给应用程序。因此，这部分内存一般也被当成是可用内存。</p>
<p>如果可用内存非常少，系统可能会动用交换区（如果配置了的话），这样会增加IO开销（可以在iostat命令中提现），降低系统性能。</p>
<h1 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-8-1.png" alt="1-8-1"></p>
<p>sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和。</p>
<p><img src="http://p10cpl3za.bkt.clouddn.com/1-8-2.png" alt="1-8-2"></p>
<p>sar命令在这里用于查看TCP连接状态，其中包括：</p>
<p>active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；</p>
<p>passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；</p>
<p>retrans/s：每秒TCP重传数量；</p>
<p>TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压</p>
<h1 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-9.png" alt="1-9"></p>
<p>top命令包含了前面好几个命令的检查的内容。比如系统负载情况（uptime）、系统内存使用情况（free）、系统CPU使用情况（vmstat）等。因此通过这个命令，可以相对全面的查看系统负载的来源。同时，top命令支持排序，可以按照不同的列排序，方便查找出诸如内存占用最多的进程、CPU占用率最高的进程等。但是，top命令相对于前面一些命令，输出是一个瞬间值，如果不持续盯着，可能会错过一些线索。这时可能需要暂停top命令刷新，来记录和比对数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;uptime命令&quot;&gt;&lt;a href=&quot;#uptime命令&quot; class=&quot;headerlink&quot; title=&quot;uptime命令&quot;&gt;&lt;/a&gt;uptime命令&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://p10cpl3za.bkt.clouddn.com/1-1
    
    </summary>
    
      <category term="运维技能" scheme="http://yjscloud.com/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Linux运维技能" scheme="http://yjscloud.com/tags/Linux%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
      <category term="非原创系列" scheme="http://yjscloud.com/tags/%E9%9D%9E%E5%8E%9F%E5%88%9B%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LVS + Keepalived 实现高可用Web集群</title>
    <link href="http://yjscloud.com/2017/10/26/LVS-Keepalived-%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8Web%E9%9B%86%E7%BE%A4/"/>
    <id>http://yjscloud.com/2017/10/26/LVS-Keepalived-实现高可用Web集群/</id>
    <published>2017-10-26T05:23:40.000Z</published>
    <updated>2017-10-26T07:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高可用性技术简介"><a href="#高可用性技术简介" class="headerlink" title="高可用性技术简介"></a>高可用性技术简介</h1><p>高可用性（HighAvailability）通常是用来描述一个系统经过专门的设计，从而减少停工的时间，而保持其服务的高可用性。计算机系统的可用性定义为：MTTF/(MTTF+MTTR) * 100%，因此计算机系统的可用性定义为系统保持正常运行时间的百分比。而负载均衡服务器的高可用性是为了屏蔽负载均衡服务器的失效，需要建立一个备份机。主服务器和备份机上都运行高可用性监控程序，通过传送信息来监控对方的运行状况。当备份机不能在一定的时间里接收到从主服务器那里发送的它存活着（即它从事着主服务器的工作）的时候，备份服务器就会从主服务器那里接管器主服务器的服务IP并继续提供服务。当主服务器又开始接管服务时，它会给备份服务器发送它接管的消息，接着备份服务器就会释放服务IP地址，这样子主服务器又再一次接管了服务IP。这就实现了在主服务器失效的状况下，备份服务器可以接管主服务的工作，以此实现负载集群系统配置信息的同步与备份了。</p>
<a id="more"></a>
<h1 id="LVS-负载均衡技术"><a href="#LVS-负载均衡技术" class="headerlink" title="LVS 负载均衡技术"></a>LVS 负载均衡技术</h1><p>LVS即 Linux Virtual Server，是由中国一个Linux程序员章文嵩博士发起和领导的，基于Linux系统的服务器集群解决方案，其实现目标是创建一个具有良好的扩展性、高可靠性、高性能和高可用性的体系。使用LVS架设的服务器集群系统从体系结构上看是透明的，最终用户只感觉到一个虚拟服务器。物理服务器之间可以通过高速的 LAN或分布在各地的WAN相连。最前端是负载均衡器，它负责将各种服务请求分发给后面的物理服务器，让整个集群表现得像一个服务于同一IP地址的虚拟服务器。负载均衡（Load Balance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p>
<p>负载均衡可以通过软件实现也可以通过硬件实现，软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。而硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。LVS负载均衡的实现基础是IP交换，将IP层的TCP/IP请求均匀的转移到服务器池中不同的服务器上。而在 Linux平台下 IP的交换具备了一定的可扩展性,可以实现高性能、高可扩展性、易管理性等诸多特点,成为一个以负载均衡为核心的真正意义的集群系统。</p>
<p>LVS服务器集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。负载调度器可以运行在以下三种模式下：</p>
<p>（1）Virtual Server via NAT（VS-NAT）：用地址翻译实现虚拟服务器。地址转换器有能被外界访问到的合法IP地址，它修改来自专有网络的流出包的地址。外界看起来包是来自 地址转换器本身，当外界包送到转换器时，它能判断出应该将包送到内部网的哪个节点。优点是节省IP 地址，能对内部进行伪装；缺点是效率低，因为返回给请求方的流量经过转换器。</p>
<p>（2）Virtual Server via IP Tunneling （VS-TUN）：用IP隧道技术实现虚拟服务器。这种方式是在集群的节点不在同一个网段时可用的转发机制，是将IP包封装在其他网络流量中的方法。为了 安全的考虑，应该使用隧道技术中的VPN，也可使用租用专线。 集群所能提供的服务是基于TCP/IP的Web服务、Mail服务、News服务、DNS服务、Proxy服务器等。</p>
<p>（3）Virtual Server via Direct Routing（VS-DR）：用直接路由技术实现虚拟服务器。当参与集群的计算机和作为控制管理的计算机在同一个网段时可以用此法，控制管理的计算机接 收到请求包时直接送到参与集群的节点。优点是返回给客户的流量不经过控制主机，速度快开销少。<br>LVS本身是基于IP层的负载均衡，可以说是最高效的一种方式。其中VS- DR和VS-TUN两种工作模式可以由后端机器直接对外服务，负载均衡的性能很高，对资源占用很少，通过LVS服务器集群负载均衡技术，能够以很高的性价比解决网络访问量激增带来的服务器瓶颈问题。</p>
<h1 id="KEEPALIVED-技术"><a href="#KEEPALIVED-技术" class="headerlink" title="KEEPALIVED 技术"></a>KEEPALIVED 技术</h1><p>在 keepalived中，一个是master，其他的都是backup</p>
<p>vrrp:实现ip地址的高可用性，将除地址之外其他的功能也转移</p>
<p>通过状态的改变，keepalived检测到，执行相应的状态下定义的脚本，脚本中有服务的 关闭和开启的命令，来实现服务的转移。</p>
<p>keepalived不仅提供地址的转移功能，服务启动和关闭，还有监控功能具有两个核心组件：VRRP stack 和 checkers（用来监控服务）、还有对外围监控脚本调用的实现，节点之间只通过优先级来确定资源在哪个节点上运行，需要起始配置，虚拟地址转移需通过配置脚本来启动服务转移信息状态，有个通知机制，可以发短信或者邮件给管理员（需配置邮件服务器）</p>
<p>适用于用不到共享存储，节点少的且keepalived支持多节点，但是节点中启动服务的只能有一个节点（一主多从）让每个节点都活动起来（运行两组资源）</p>
<p>vrrp认证：1、明文认证、配置好预共享密钥  2、md5 sha1 散列</p>
<p>core：是keepalived的核心，复杂主进程的启动和维护，全局配置文件的加载解析等</p>
<p>check：负责healthchecker(健康检查)，包括了各种健康检查方式，以及对应的配置的解析包括<br>LVS的配置解析</p>
<p>vrrp：VRRPD子进程，VRRPD子进程就是来实现VRRP协议的</p>
<p>libipfwc：iptables(ipchains)库，配置LVS会用到</p>
<p>libipvs*：配置LVS会用到</p>
<p>注意，keepalived和LVS完全是两码事，只不过他们各负其责相互配合而已</p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-1.png" alt="k-1"></p>
<p>keepalived启动后会有三个进程</p>
<p>(1)父进程：内存管理，子进程管理等等</p>
<p>(2)子进程：VRRP子进程</p>
<p>(3)子进程：healthchecker子进程</p>
<h1 id="实验环境物理结构说明"><a href="#实验环境物理结构说明" class="headerlink" title="实验环境物理结构说明"></a>实验环境物理结构说明</h1><p><img src="http://ow78pfxd9.bkt.clouddn.com/k-2.png" alt="k-2"></p>
<h1 id="keepalived测试环境安装"><a href="#keepalived测试环境安装" class="headerlink" title="keepalived测试环境安装"></a>keepalived测试环境安装</h1><p>（1）关闭防火墙和selinux</p>
<pre><code># service iptables stop
# chkconfig iptables off
# vi /etc/selinux/config 
    把enforcing改为disabled
# setenforce 0
</code></pre><p>（2）分别给master和backup节点安装ipvsadm和keepalived</p>
<pre><code># yum –y install ipvsadm
# yum –y install keepalived
# service keepalived start
# chkconfig keepalived on
</code></pre><p>（3）配置 keepalived.conf</p>
<pre><code>#  vi /etc/keeplived/keepalived.conf
</code></pre><pre>
! Configuration File for keepalived

global_defs {
   router_id S208                ## keepalived 服务器标识符，可以随意设定（ 貌似也是全局唯一 ）
}

vrrp_instance NW3007 {            ## 定义一个名为 NW3007 的 VRRP 实例
    state MASTER                ## Keepalived 服务器角色，MASTER 为主、BACKUP 为备
    interface eth0                ## 指定 HA 监测网络接口
    virtual_router_id 51            ## 虚拟路由标识，同一个 VRRP 实例使用唯一的标识，主备必须一样
    priority 200                    ## 节点优先级，同一 VRRP 实例中 MASTER 的优先级必须大于 BACKUP
    advert_int 5                    ## MASTER / BACKUP 之间同步检查间隔时间，单位 秒
    track_interface {                ##指定监听数据的网口
        eth0
    }
    authentication {                ## 节点之间通信验证类型、密码 ，同一 VRRP 实例中，MASTER / BACKUP 必须使用相同的密码才可以通信
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {            ## 虚拟 IP 地址，又称漂移 IP 。可以通过 ip add 在 MASTER 上查看是否绑定
        192.168.2.100
    }
}

virtual_server 192.168.0.110 80 {        ## 定义虚拟服务器
    delay_loop 3                        ## 定义健康检查时间间隔，单位 秒
    lb_algo wlc                         ## 负载均衡调度算法，支持 rr 、wrr 、lc 、wlc 、lblc 、sh 、dh 等
    lb_kind DR                        ## LVS 负载均衡机制，支持 NAT 、TUN 、DR
    protocol TCP                    ## 转发协议类型，支持 TCP 、UDP
    ha_suspend                        

    real_server 192.168.0.30 80 {            ## 定义节点服务器
        weight 3                        ## 节点权重值，数字越大权重越高，分配到的连接越多。主要用于后端节点服务器性能不统一
        TCP_CHECK {                ## 健康检测方式，支持 HTTP_GET 、SSL_GET 、TCP_CHECK 、SMTP_CHECK 、MISC_CHECK
            connect_timeout 3        ## 无响应超时时间，单位 秒
        }
    }

    real_server 192.168.0.31 80 {        ## 第二台节点服务器
        weight 3
        TCP_CHECK {
            connect_timeout 3
        }
    }
}
</pre>

<p>在master节点配置好keepalived文件后将keepalived.conf拷贝到backup节点</p>
<pre><code># scp /etc/keepalived/keepalived.conf  192.168.0.29:/etc/keepalived/
</code></pre><p>然后将priority值改为100即可,最后重启keepalived服务</p>
<pre><code># service keepalived restart
</code></pre><p>（4）为master节点和backup节点添加vip</p>
<p>master节点</p>
<pre><code># ip addr add 192.168.0.110/32 dev eth0
</code></pre><p><img src="http://ow78pfxd9.bkt.clouddn.com/k-3.png" alt="k-3"></p>
<p>backup节点</p>
<pre><code># ip addr add 192.168.0.110/32 dev eth0
</code></pre><p><img src="http://ow78pfxd9.bkt.clouddn.com/k-4.png" alt="k-4"></p>
<p>（5）验证虚拟 IP 地址是否可以正常漂移</p>
<p>停用master节点网卡</p>
<pre><code># ifdown eth0
</code></pre><p>查看backup节点的日志文件</p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-5.png" alt="k-5"></p>
<p>查看backup的网卡</p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-6.png" alt="k-6"></p>
<p>重新激活master网卡,查看backup日志文件<br><img src="http://ow78pfxd9.bkt.clouddn.com/k-7.png" alt="k-7"></p>
<p>虚拟ip会自动移除，虚拟ip设置正常！</p>
<p>注意：停用master的网卡vip会自动消失需要重新为master添加vip</p>
<pre><code># ip addr add 192.168.0.110/32 dev eth0
</code></pre><h1 id="配置RS-1和RS-2"><a href="#配置RS-1和RS-2" class="headerlink" title="配置RS-1和RS-2"></a>配置RS-1和RS-2</h1><p>（1）关闭防火墙和selinux</p>
<pre><code># service iptables stop
# chkconfig iptables off
# vi /etc/selinux/config 
    把enforcing改为disabled
# setenforce 0
</code></pre><p>（2）安装httpd</p>
<p>分别在RS-1和RS-2上进行如下操作</p>
<pre><code># yum –y install httpd
# service httpd start
# chkconfig httpd on
</code></pre><p>在RS-1</p>
<pre><code>echo RS-1-Web11111111 &gt; /var/www/html/index.html
</code></pre><p>在RS-2</p>
<pre><code>echo RS-2-Web2222222 &gt; /var/www/html/index.html
</code></pre><p>（3）RS-1创建一个脚本文件</p>
<pre><code># vi /root/realserver.sh
</code></pre><pre>
#!/bin/bash
vip=192.168.0.110

case $1 in
start)
    echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore
    echo 1 > /proc/sys/net/ipv4/conf/eth0/arp_ignore
    echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce
    echo 2 > /proc/sys/net/ipv4/conf/eth0/arp_announce

    ifconfig lo:0 $vip netmask 255.255.255.255 broadcast $vip up

    ;;
stop)
    ifconfig lo:0 down
        echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore
        echo 0 > /proc/sys/net/ipv4/conf/eth0/arp_ignore
        echo 0 > /proc/sys/net/ipv4/conf/all/arp_announce
        echo 0 > /proc/sys/net/ipv4/conf/eth0/arp_announce
    ;;
esac
</pre>

<p>赋予运行权权限</p>
<pre><code># chmod a+x /root/realserver.sh
</code></pre><p>将脚本拷贝到RS-2</p>
<pre><code># scp /root/realserver.sh 192.168.0.31:/root/
</code></pre><p>在RS-1和RS-2执行脚本</p>
<pre><code># ./realserver start
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>服务器之间可以自由调度</p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-9.png" alt="k-9"></p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-8.png" alt="k-8"></p>
<p>停用mater网卡也可以自由调度RS-1和RS-2，实验到此结束</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高可用性技术简介&quot;&gt;&lt;a href=&quot;#高可用性技术简介&quot; class=&quot;headerlink&quot; title=&quot;高可用性技术简介&quot;&gt;&lt;/a&gt;高可用性技术简介&lt;/h1&gt;&lt;p&gt;高可用性（HighAvailability）通常是用来描述一个系统经过专门的设计，从而减少停工的时间，而保持其服务的高可用性。计算机系统的可用性定义为：MTTF/(MTTF+MTTR) * 100%，因此计算机系统的可用性定义为系统保持正常运行时间的百分比。而负载均衡服务器的高可用性是为了屏蔽负载均衡服务器的失效，需要建立一个备份机。主服务器和备份机上都运行高可用性监控程序，通过传送信息来监控对方的运行状况。当备份机不能在一定的时间里接收到从主服务器那里发送的它存活着（即它从事着主服务器的工作）的时候，备份服务器就会从主服务器那里接管器主服务器的服务IP并继续提供服务。当主服务器又开始接管服务时，它会给备份服务器发送它接管的消息，接着备份服务器就会释放服务IP地址，这样子主服务器又再一次接管了服务IP。这就实现了在主服务器失效的状况下，备份服务器可以接管主服务的工作，以此实现负载集群系统配置信息的同步与备份了。&lt;/p&gt;
    
    </summary>
    
      <category term="技术分享" scheme="http://yjscloud.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Linux学习笔记" scheme="http://yjscloud.com/tags/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="keepalived" scheme="http://yjscloud.com/tags/keepalived/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（九）-cpu添加虚拟化功能</title>
    <link href="http://yjscloud.com/2017/10/21/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89-cpu%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8A%9F%E8%83%BD/"/>
    <id>http://yjscloud.com/2017/10/21/kvm学习笔记（九）-cpu添加虚拟化功能/</id>
    <published>2017-10-21T09:23:10.000Z</published>
    <updated>2017-12-02T09:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为只有一台物理机，物理机运行着centos7，需要测试虚拟化环境，就要在运行的kvm环境中的虚拟机增加kvm_intel模块！具体方法如下：</p>
<pre><code>[root@kvm~]# vim /etc/modprobe.d/kvm-nested.conf #此文件默认不存在，新建即可
options kvm_intel nested=1 #添加此行
[root@kvm ~]# modprobe -r kvm_intel #卸载模块
[root@kvm ~]# modprobe kvm_intel #重新加载模块
[root@kvm ~]# cat /sys/module/kvm_intel/parameters/nested 
Y
#返还Y即为支持nested KVM
[root@kvm ~]# virsh edit VM host name #修改虚拟机
</code></pre><p>修改如下区块</p>
<p>将如下代码</p>
<pre><code>&lt;cpu mode=’custom’ match=’exact’ &gt;
</code></pre><p>修改为</p>
<pre><code>&lt;cpu mode=&apos;host-passthrough&apos;&gt;
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/2.1.png" alt="2.1"></p>
<p>如果虚拟机的配置文件里没有<cpu mode="’custom’" match="’exact’">这一行代码就在如下位置添加一行代码即可</cpu></p>
<p><img src="http://oxysobnip.bkt.clouddn.com/2.2.png" alt="2.2"></p>
<p>查看一下虚拟机cpu已经支持虚拟化了</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/2.3.png" alt="2.3"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为只有一台物理机，物理机运行着centos7，需要测试虚拟化环境，就要在运行的kvm环境中的虚拟机增加kvm_intel模块！具体方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@kvm~]# vim /etc/modprobe.d/kvm-nested.conf #
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（八）-kvm虚拟机存储池配置</title>
    <link href="http://yjscloud.com/2017/10/20/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89-kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%98%E5%82%A8%E6%B1%A0%E9%85%8D%E7%BD%AE/"/>
    <id>http://yjscloud.com/2017/10/20/kvm学习笔记（八）-kvm虚拟机存储池配置/</id>
    <published>2017-10-20T04:56:21.000Z</published>
    <updated>2017-12-02T09:34:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是存储池"><a href="#什么是存储池" class="headerlink" title="什么是存储池"></a>什么是存储池</h1><p>KVM平台以存储池的形式对存储进行统一管理，所谓存储池可以理解为本地目录、通过远端磁盘阵列（iSCSI、NFS）分配过来磁盘或目录，当然也支持各类分布式文件系统。通过virsh中pool命令能够查看、创建、激活、注册、删除存储池。</p>
<p>注1:KVM存储池主要是体现一种管理方式，可以通过挂载存储目录，lvm逻辑卷的方式创建存储池，虚拟机存储卷创建完成后，剩下的操作与无存储卷的方式无任何区别了。</p>
<p>注2:KVM存储池也要用于虚拟机迁移任务。</p>
<h1 id="存储池配置步骤"><a href="#存储池配置步骤" class="headerlink" title="存储池配置步骤"></a>存储池配置步骤</h1><h2 id="创建基于文件夹的存储池（目录）"><a href="#创建基于文件夹的存储池（目录）" class="headerlink" title="创建基于文件夹的存储池（目录）"></a>创建基于文件夹的存储池（目录）</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.102.png" alt="1.102"></p>
<h2 id="定义存储池与其目录"><a href="#定义存储池与其目录" class="headerlink" title="定义存储池与其目录"></a>定义存储池与其目录</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.103.png" alt="1.103"></p>
<h2 id="创建已定义的存储池"><a href="#创建已定义的存储池" class="headerlink" title="创建已定义的存储池"></a>创建已定义的存储池</h2><p>(1)创建已定义的存储池</p>
<pre><code># virsh pool-build vmdisk
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.104.png" alt="1.104"></p>
<p>(2)查看已定义的存储池，存储池不激活无法使用。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.105.png" alt="1.105"></p>
<h2 id="激活并自动启动已定义的存储池"><a href="#激活并自动启动已定义的存储池" class="headerlink" title="激活并自动启动已定义的存储池"></a>激活并自动启动已定义的存储池</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.106.png" alt="1.106"></p>
<p>这里vmdisk存储池就已经创建好了，可以直接在这个存储池中创建虚拟磁盘文件了。</p>
<h2 id="在存储池中创建虚拟机存储卷"><a href="#在存储池中创建虚拟机存储卷" class="headerlink" title="在存储池中创建虚拟机存储卷"></a>在存储池中创建虚拟机存储卷</h2><p>(1)在存储池中创建虚拟机存储卷</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.107.png" alt="1.107"></p>
<p>(2)根据创建的虚拟机存储卷安装虚拟机</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.108.png" alt="1.108"></p>
<p>安装过程略！</p>
<p>说明：KVM存储池主要是体现一种管理方式，可以通过挂载存储目录，lvm逻辑卷的方式创建存储池，虚拟机存储卷创建完成后，剩下的操作与无存储卷的方式无任何区别了。KVM存储池也要用于虚拟机迁移任务。</p>
<h2 id="存储池相关管理命令"><a href="#存储池相关管理命令" class="headerlink" title="存储池相关管理命令"></a>存储池相关管理命令</h2><p>(1)在存储池中删除虚拟机存储卷</p>
<pre><code># virsh vol-delete --pool vmdisk test-01.qcow2
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.109.png" alt="1.109"></p>
<p>(2)取消激活存储池</p>
<pre><code># virsh pool-destroy vmdisk
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.110.png" alt="1.110"></p>
<p>(3)删除存储池定义的目录/mnt/vmfs</p>
<pre><code># virsh pool-delete vmdisk
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.111.png" alt="1.111"></p>
<p>(4)取消定义存储池</p>
<pre><code># virsh pool-undefine vmdisk
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.112.png" alt="1.112"></p>
<p>到此kvm存储池配置与管理操作完毕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是存储池&quot;&gt;&lt;a href=&quot;#什么是存储池&quot; class=&quot;headerlink&quot; title=&quot;什么是存储池&quot;&gt;&lt;/a&gt;什么是存储池&lt;/h1&gt;&lt;p&gt;KVM平台以存储池的形式对存储进行统一管理，所谓存储池可以理解为本地目录、通过远端磁盘阵列（iSCSI、NF
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（七）-kvm虚拟机动态迁移</title>
    <link href="http://yjscloud.com/2017/10/20/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89-kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A8%E6%80%81%E8%BF%81%E7%A7%BB/"/>
    <id>http://yjscloud.com/2017/10/20/kvm学习笔记（七）-kvm虚拟机动态迁移/</id>
    <published>2017-10-20T01:49:46.000Z</published>
    <updated>2017-12-02T09:34:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么叫动态迁移？"><a href="#什么叫动态迁移？" class="headerlink" title="什么叫动态迁移？"></a>什么叫动态迁移？</h1><p>动态迁移（Live Migration）：也叫在线迁移（Online Migration）。就是在保证虚拟机上服务正常运行的同时，将一个虚拟机系统从一个物理主机移动到另一个物理主机的过程。该过程不会对最终用户造成明 显的影响，从而使得管理员能够在不影响用户正常使用的情况下，对物理服务器进行离线维修或者升级。与静态迁移不同的是，为了保证迁移过程中虚拟机服务的可用，迁移过程仅有非常短暂的停机时间。迁移的前面阶段，服务在源主机的虚拟机上运行，当迁移进行到一定阶段，目的主机已经具备了运行虚拟机系统的必须资源，经过一个非常短暂的切换，源主机将控制权转移到目的主机，虚拟机系统在目的主机上继续运行。对于虚拟机服务本身而言，由于切换的时间非常短暂，用户感 觉不到服务的中断，因而迁移过程对用户是透明的。动态迁移适用于对虚拟机服务可用性要求很高的场合。</p>
<a id="more"></a>
<p>动态迁移需要将原有的虚拟机镜像放在采用 SAN（storage area network）或 NAS（network-attached storage）之类的集中式共享外存设备,这样迁移的时候,不是迁移整个硬盘镜象,而是迁移内存的信息.所以迁移起来,速度比较快,停顿时间少。</p>
<p>动态迁移实际上是把虚拟机的配置封装在一个文件中，然后通过高速网络，把虚拟机配置和内存运行状态从一台物理机迅速传送到另外一台物理机上，期间虚拟机一直保持运行状态。现有技术条件下，大多虚拟机软件如 VMware、Hyper-V、Xen 进行动态迁移都需要共享存储的支持。典型的共享存储包括 NFS 和 SMB/CIFS 协议的网络文件系统，或者通过 iSCSI 连接到 SAN 网络。选用哪一种网络文件系统，需要根据具体情况而定，本文使用NFS 共享存储！</p>
<p>虚拟化平台架构</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.83.png" alt="1.83"></p>
<h1 id="虚拟化环境介绍"><a href="#虚拟化环境介绍" class="headerlink" title="虚拟化环境介绍"></a>虚拟化环境介绍</h1><p>（1）kvm虚拟化服务器节点：kvm-1</p>
<p>   操作系统：CentOS7.2</p>
<p>   kvm虚拟化：自带版本</p>
<p>   Ip地址：192.168.0.40    </p>
<p>   nfs挂载目录：/mnt</p>
<hr>
<p>(2）kvm虚拟化服务器节点kvm-2</p>
<p>   操作系统：CentOS7.2</p>
<p>   kvm虚拟化：自带版本</p>
<p>  ip地址：192.168.0.15    </p>
<p>  nfs挂载目录：/mnt</p>
<p>  测试虚拟机：share</p>
<p>  虚拟机磁盘文件：/mnt/kvm/share.qcow2</p>
<hr>
<p>（3）nfs服务器</p>
<p>   操作系统：CentOS7.2</p>
<p>   ip地址：192.168.0.12</p>
<p>   nfs服务目录：/home/image</p>
<h1 id="三台虚拟机都关闭SElinux和防火墙"><a href="#三台虚拟机都关闭SElinux和防火墙" class="headerlink" title="三台虚拟机都关闭SElinux和防火墙"></a>三台虚拟机都关闭SElinux和防火墙</h1><pre><code># systemctl stop firewalld
# systemctl disable firewalld
# vim /etc/selinux/config
    将enforcing改为disabled
</code></pre><h1 id="共享存储的配置"><a href="#共享存储的配置" class="headerlink" title="共享存储的配置"></a>共享存储的配置</h1><p>（1）)NFS共享存储虚拟机安装NFS服务</p>
<pre><code># yum –y install nfs-utils
</code></pre><p>（2）创建并加载挂载目录</p>
<pre><code># mkdir /home/image
# vim /etc/exports
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.84.png" alt="1.84"></p>
<p>（3）查看是否共享目录,并重启nfs服务</p>
<pre>
# exportfs -av
# systemctl enable rpcbind.service
# systemctl enable nfs-server.service
# systemctl start rpcbind.service
# systemctl start nfs-server.service
# showmount –e
</pre>

<p><img src="http://oxysobnip.bkt.clouddn.com/1.85.png" alt="1.85"></p>
<p>（4）先确保两台宿主机的虚拟机全部呈关闭状态，目的是将之前的磁盘镜像目录移动到/mnt 外的其他位置，好将NFS 目录挂载到 /mnt 目录下：</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.86.png" alt="1.86"><br><img src="http://oxysobnip.bkt.clouddn.com/1.87.png" alt="1.87"></p>
<p>(5)将kvm-2和kvm-2的虚拟机磁盘镜像目录移动到 /mnt 目录以外的地方：</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.88.png" alt="1.88"><br><img src="http://oxysobnip.bkt.clouddn.com/1.89.png" alt="1.89"></p>
<h1 id="kvm虚拟主机配置准备"><a href="#kvm虚拟主机配置准备" class="headerlink" title="kvm虚拟主机配置准备"></a>kvm虚拟主机配置准备</h1><p>(1)节点1挂载nfs目录</p>
<pre><code># mount -t nfs 192.168.0.12:/home/image /mnt/
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.90.png" alt="1.90"></p>
<p>(2)节点2挂载nfs目录</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.91.png" alt="1.91"></p>
<p>(3)将kvm-2的虚拟机磁盘镜像目录移回到NFS，因为kvm-1的虚拟机之前是静态迁移过来的，kvm-2上也有一份，所以就不移回了(如果kvm-1上有不同于kvm-2上的虚拟机，则也要移回)</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.92.png" alt="1.92"></p>
<h1 id="kvm虚拟机迁移"><a href="#kvm虚拟机迁移" class="headerlink" title="kvm虚拟机迁移"></a>kvm虚拟机迁移</h1><p>(1)kvm-2虚拟机状态，share虚拟机开机状态</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.93.png" alt="1.93"></p>
<p>(2) kvm-1虚拟机状态，无虚拟机运行</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.94.png" alt="1.94"></p>
<p>(3)kvm-2上执行迁移命令</p>
<pre><code># virsh migrate --live --verbose share  qemu+ssh://192.168.0.40/system tcp://192.168.0.40 --unsafe
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.95.png" alt="1.95"></p>
<p>(4) 为了在验证过程中，虚拟主机不中断，我们开启ping 虚拟主机，没有出现超时状态，迁移成功。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.96.png" alt="1.96"></p>
<p>（5）迁移完成，验证kvm-2上的share呈关闭状态</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.97.png" alt="1.97"></p>
<p>kvm-1上,可以看到虚拟机share已经启动了。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.98.png" alt="1.98"></p>
<p>(6) 虽然share虚拟机已经在kvm-1上启动了，但是虚拟主机上还没有share虚拟机的配置文件。所以需要创建配置文件并定义虚拟机。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.99.png" alt="1.99"></p>
<p>Kvm-1上,通过迁移过来的虚拟机内存状态创建虚拟机配置文件，并通过xml配置文件定义虚拟机。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.100.png" alt="1.100"></p>
<p>在kvm-1上进入虚拟机没有问题。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.101.png" alt="1.101"></p>
<p>到此，kvm虚拟机动态迁移成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么叫动态迁移？&quot;&gt;&lt;a href=&quot;#什么叫动态迁移？&quot; class=&quot;headerlink&quot; title=&quot;什么叫动态迁移？&quot;&gt;&lt;/a&gt;什么叫动态迁移？&lt;/h1&gt;&lt;p&gt;动态迁移（Live Migration）：也叫在线迁移（Online Migration）。就是在保证虚拟机上服务正常运行的同时，将一个虚拟机系统从一个物理主机移动到另一个物理主机的过程。该过程不会对最终用户造成明 显的影响，从而使得管理员能够在不影响用户正常使用的情况下，对物理服务器进行离线维修或者升级。与静态迁移不同的是，为了保证迁移过程中虚拟机服务的可用，迁移过程仅有非常短暂的停机时间。迁移的前面阶段，服务在源主机的虚拟机上运行，当迁移进行到一定阶段，目的主机已经具备了运行虚拟机系统的必须资源，经过一个非常短暂的切换，源主机将控制权转移到目的主机，虚拟机系统在目的主机上继续运行。对于虚拟机服务本身而言，由于切换的时间非常短暂，用户感 觉不到服务的中断，因而迁移过程对用户是透明的。动态迁移适用于对虚拟机服务可用性要求很高的场合。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（六）-kvm虚拟机静态迁移</title>
    <link href="http://yjscloud.com/2017/10/20/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89-kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%99%E6%80%81%E8%BF%81%E7%A7%BB/"/>
    <id>http://yjscloud.com/2017/10/20/kvm学习笔记（六）-kvm虚拟机静态迁移/</id>
    <published>2017-10-20T01:28:43.000Z</published>
    <updated>2017-12-02T09:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是静态迁移？"><a href="#什么是静态迁移？" class="headerlink" title="什么是静态迁移？"></a>什么是静态迁移？</h1><p>静态迁移：也叫做常规迁移、离线迁移（Offline Migration）。就是在虚拟机关机或暂停的情况下从一台物理机迁移到另一台物理机。因为虚拟机的文件系统建立在虚拟机镜像上面，所以在虚拟机关机的 情况下，只需要简单的迁移虚拟机镜像和相应的配置文件到另外一台物理主机上；如果需要保存虚拟机迁移之前的状态，在迁移之前将虚拟机暂停，然后拷贝状态至目的主机，最后在目的主机重建虚拟机状态，恢复执行。这种方式的迁移过程需要显式的停止虚拟机的运行。从用户角度看，有明确的一段停机时间，虚拟机上的服务不可用。这种迁移方式简单易行，适用于对服务可用性要求不严格的场合。</p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>(1)虚拟主机各自使用本地存储存放虚拟机磁盘文件</p>
<p>本文实现基于本地磁盘存储虚拟机磁盘文件的迁移方式</p>
<p>(2)虚拟主机之间使用共享存储存放虚拟机磁盘文件</p>
<p>该方式只是在目标虚拟主机上重新定义虚拟机就可以了</p>
<h1 id="静态迁移过程"><a href="#静态迁移过程" class="headerlink" title="静态迁移过程"></a>静态迁移过程</h1><p>(1)确定虚拟机关闭状态</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.70.png" alt="1.70"></p>
<p>(2)准备迁移clone-3虚拟机，查看该虚拟机配置的磁盘文件</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.71.png" alt="1.71"></p>
<p>(3)导入虚拟机配置文件</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.72.png" alt="1.72"></p>
<p>(4)拷贝配置文件到目标虚拟主机上</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.73.png" alt="1.73"></p>
<p>拷贝虚拟磁盘文件</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.74.png" alt="1.74"></p>
<h1 id="目标虚拟主机"><a href="#目标虚拟主机" class="headerlink" title="目标虚拟主机"></a>目标虚拟主机</h1><p>上面已经将虚拟机磁盘文件与配置文件都已经复制到目标虚拟主机上了。下面开始配置与启动。</p>
<p>(1)    查看目标虚拟主机环境</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.75.png" alt="1.75"></p>
<p>如果上面没有显示虚拟主机，就需要对虚拟主机进行注册</p>
<pre><code># virsh define /etc/libvirt/qemu/clone-3.xml
</code></pre><p>查看虚拟机磁盘文件，目录结构与源虚拟主机一致。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.76.png" alt="1.76"></p>
<p>(2)启动虚拟主机并确认</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.77.png" alt="1.77"></p>
<p>成功连接</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.78.png" alt="1.78"></p>
<p>至此虚拟机静态迁移完成。</p>
<h1 id="kvm的那些坑"><a href="#kvm的那些坑" class="headerlink" title="kvm的那些坑"></a>kvm的那些坑</h1><p>（1）如果您遇到如下报错您可以这样处理</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.79.png" alt="1.79"></p>
<p>查看包版本：</p>
<pre><code># yum info device-mapper-libs         
</code></pre><p>更新软件包：</p>
<pre><code># yum update device-mapper-libs  
</code></pre><p>然后运行如下命令</p>
<pre>
# sed -i 's/#listen_tls = 0/listen_tls = 0/g' /etc/libvirt/libvirtd.conf
# sed -i 's/#listen_tcp = 1/listen_tcp = 1/g' /etc/libvirt/libvirtd.conf
# sed -i 's/#auth_tcp = "sasl"/auth_tcp = "none"/g' /etc/libvirt/libvirtd.conf
# sed -i 's/#LIBVIRTD_ARGS="--listen"/LIBVIRTD_ARGS="--listen"/g' /etc/sysconfig/libvirtd
# systemctl restart libvirtd
</pre>

<p>（2）如果您把您的虚拟机静态迁移到不同平台（不同型号的cpu）的主机上报了如下错误</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.80.png" alt="1.80"></p>
<p>您可以根据提示修改您的虚拟机配置文件</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.81.png" alt="1.81"></p>
<p>Broadwell是原cpu类型，这里根据报错信息将其修改为Broadwell-noTSX</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.82.png" alt="1.82"></p>
<p>修改后即可启动虚拟机了！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是静态迁移？&quot;&gt;&lt;a href=&quot;#什么是静态迁移？&quot; class=&quot;headerlink&quot; title=&quot;什么是静态迁移？&quot;&gt;&lt;/a&gt;什么是静态迁移？&lt;/h1&gt;&lt;p&gt;静态迁移：也叫做常规迁移、离线迁移（Offline Migration）。就是在虚拟机关机或暂停的情况下从一台物理机迁移到另一台物理机。因为虚拟机的文件系统建立在虚拟机镜像上面，所以在虚拟机关机的 情况下，只需要简单的迁移虚拟机镜像和相应的配置文件到另外一台物理主机上；如果需要保存虚拟机迁移之前的状态，在迁移之前将虚拟机暂停，然后拷贝状态至目的主机，最后在目的主机重建虚拟机状态，恢复执行。这种方式的迁移过程需要显式的停止虚拟机的运行。从用户角度看，有明确的一段停机时间，虚拟机上的服务不可用。这种迁移方式简单易行，适用于对服务可用性要求不严格的场合。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（五）-kvm虚拟机在线扩展磁盘</title>
    <link href="http://yjscloud.com/2017/10/20/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9C%A8%E7%BA%BF%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98/"/>
    <id>http://yjscloud.com/2017/10/20/kvm学习笔记（五）-kvm虚拟机在线扩展磁盘/</id>
    <published>2017-10-20T01:08:07.000Z</published>
    <updated>2017-12-02T09:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<p> kvm虚拟机也支持在线扩展磁盘功能,在线扩展有特定的使用环境，主要用于不能随便停用的生产环境中。经过测试KVM在线扩展磁盘功能只适用于RHEL/CentOS/OEL6.x环境,5.x不支持在线的扩展磁盘。</p>
<p>本次次测试使用centos7.3的虚拟机</p>
<p>给clone-2虚拟机在线添加磁盘</p>
<a id="more"></a>
<h1 id="查看现有磁盘"><a href="#查看现有磁盘" class="headerlink" title="查看现有磁盘"></a>查看现有磁盘</h1><pre><code># virsh start clone-2
# virsh list –all 
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.60.png" alt="1.60"></p>
<h1 id="创建一块qcow2虚拟磁盘"><a href="#创建一块qcow2虚拟磁盘" class="headerlink" title="创建一块qcow2虚拟磁盘"></a>创建一块qcow2虚拟磁盘</h1><pre><code># qemu-img create -f qcow2 add01.qcow2 10G
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.61.png" alt="1.61"></p>
<h1 id="在线添加这台qcow2虚拟磁盘"><a href="#在线添加这台qcow2虚拟磁盘" class="headerlink" title="在线添加这台qcow2虚拟磁盘"></a>在线添加这台qcow2虚拟磁盘</h1><pre><code># virsh attach-disk clone-2 /mnt/kvm/add01.qcow2 vdb --cache=none --subdriver=qcow2
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.62.png" alt="1.62"></p>
<h1 id="进入clone-2虚拟机查看添加磁盘情况"><a href="#进入clone-2虚拟机查看添加磁盘情况" class="headerlink" title="进入clone-2虚拟机查看添加磁盘情况"></a>进入clone-2虚拟机查看添加磁盘情况</h1><p>这里我通过vnc远程登录clone-2即可看见刚才添加到虚拟机的磁盘了</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.63.png" alt="1.63"></p>
<p>可以看见有两个scsi存储设备</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.64.png" alt="1.64"></p>
<blockquote>
<p>注：再次说明只有RHEL/CentOS/OEL6.x版本在线添加磁盘，虚拟机直接可以在线识别。</p>
</blockquote>
<h1 id="修改虚拟机配置文件添加新增磁盘配置"><a href="#修改虚拟机配置文件添加新增磁盘配置" class="headerlink" title="修改虚拟机配置文件添加新增磁盘配置"></a>修改虚拟机配置文件添加新增磁盘配置</h1><p>1)查看当前虚拟机配置文件<br>这里查看到的虚拟机配置文件是内存中存放的配置，重启后会消失，需要将新添的磁盘配置保存到配置文件中。</p>
<pre><code># virsh dumpxml clone-2
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.65.png" alt="1.65"></p>
<p>2)保存新增磁盘配置</p>
<pre><code># virsh edit clone-2
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.66.png" alt="1.66"></p>
<h1 id="将新增磁盘并入虚拟机逻辑卷中"><a href="#将新增磁盘并入虚拟机逻辑卷中" class="headerlink" title="将新增磁盘并入虚拟机逻辑卷中"></a>将新增磁盘并入虚拟机逻辑卷中</h1><p>(1) 分区过程如下</p>
<pre><code># fdisk /dev/vdb
# partprobe
</code></pre><p>(2) 创建逻辑卷过程如下</p>
<pre>
# pvcreate  /dev/vdb
# vgextend cl_kvm-1 /dev/vdb
# lvextend –l +100%FREE /dev/cl_kvm-1/root
# xfs_growfs /dev/cl_kvm-1/root
</pre>

<p><img src="http://oxysobnip.bkt.clouddn.com/1.67.png" alt="1.67"><br><img src="http://oxysobnip.bkt.clouddn.com/1.68.png" alt="1.68"><br><img src="http://oxysobnip.bkt.clouddn.com/1.69.png" alt="1.69"></p>
<p>至此clone-2虚拟机在线添加磁盘并在线扩展磁盘成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; kvm虚拟机也支持在线扩展磁盘功能,在线扩展有特定的使用环境，主要用于不能随便停用的生产环境中。经过测试KVM在线扩展磁盘功能只适用于RHEL/CentOS/OEL6.x环境,5.x不支持在线的扩展磁盘。&lt;/p&gt;
&lt;p&gt;本次次测试使用centos7.3的虚拟机&lt;/p&gt;
&lt;p&gt;给clone-2虚拟机在线添加磁盘&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（四）-kvm虚拟机快照备份</title>
    <link href="http://yjscloud.com/2017/10/20/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%AB%E7%85%A7%E5%A4%87%E4%BB%BD/"/>
    <id>http://yjscloud.com/2017/10/20/kvm学习笔记（四）-kvm虚拟机快照备份/</id>
    <published>2017-10-19T23:42:15.000Z</published>
    <updated>2017-12-02T09:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>kvm虚拟机默认使用raw格式的镜像格式，性能最好，速度最快，它的缺点就是不支持一些新的功能，如支持镜像,zlib磁盘压缩,AES加密等。要使用镜像功能，磁盘格式必须为qcow2。KMV下磁盘模式raw和qcow2的性能比较请参阅<a href="http://www.cnblogs.com/zhangzhang/archive/2012/02/13/2348928.html" target="_blank" rel="external">KMV下磁盘模式raw和qcow2的性能比较</a></p>
<p>下面开始kvm虚拟机快照备份的过程</p>
<a id="more"></a>
<h1 id="查看现有磁盘镜像格式与转换"><a href="#查看现有磁盘镜像格式与转换" class="headerlink" title="查看现有磁盘镜像格式与转换"></a>查看现有磁盘镜像格式与转换</h1><p>(1) 查看磁盘格式</p>
<pre><code># qemu-img info test01.img
</code></pre><p>raw格式需要转换成qcow2</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.45.png" alt="1.45"></p>
<p>（2）关闭虚拟机并装换磁盘</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.46.png" alt="1.46"></p>
<p>(3) 转换磁盘格式</p>
<pre><code># qemu-img convert -f raw -O qcow2 clone-2.img clone-2.qcow2 
</code></pre><p>   -f  源镜像的格式</p>
<p>   -O 目标镜像的格式<br><img src="http://oxysobnip.bkt.clouddn.com/1.47.png" alt="1.47"></p>
<p>查看转换后的格式，已经转换成了qcow2, 这里是拷贝一份，并将格式转成qcow2</p>
<pre><code># qemu-img info clone-2.qcow2
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.48.png" alt="1.48"></p>
<h1 id="修改虚拟机配置文件"><a href="#修改虚拟机配置文件" class="headerlink" title="修改虚拟机配置文件"></a>修改虚拟机配置文件</h1><p>修改磁盘格式，与新qcow2格式的磁盘。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.49.png" alt="1.49"></p>
<h1 id="对虚拟机进行快照管理"><a href="#对虚拟机进行快照管理" class="headerlink" title="对虚拟机进行快照管理"></a>对虚拟机进行快照管理</h1><p>(1) 对clone-2虚拟机创建快照</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.50.png" alt="1.50"></p>
<p>(2) 查看虚拟机镜像快照的版本</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.51.png" alt="1.51"></p>
<p>(3) 查看当前虚拟机镜像快照的版本</p>
<p>   可以看到为当前最新的快照版本。</p>
<pre><code># virsh snapshot-current clone-2
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.52.png" alt="1.52"></p>
<p>(4) 查看当前虚拟机镜像文件</p>
<p>  又创建了一个，快照的版本也记录在镜像文件中了。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.53.png" alt="1.53"></p>
<p>快照配置文件在/var/lib/libvirt/qemu/snapshot/虚拟机名称/下<br><img src="http://oxysobnip.bkt.clouddn.com/1.54.png" alt="1.54"></p>
<h1 id="恢复虚拟机快照"><a href="#恢复虚拟机快照" class="headerlink" title="恢复虚拟机快照"></a>恢复虚拟机快照</h1><p>(1) 恢复虚拟机快照必须关闭虚拟机。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.55.png" alt="1.55"></p>
<p>(2) 确认需要恢复的快照时间，这里恢复到1508285665</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.56.png" alt="1.56"></p>
<p>(3) 执行恢复，并确认恢复版本</p>
<pre><code># virsh snapshot-revert clone-2 1508285665
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.57.png" alt="1.57"></p>
<h1 id="删除虚拟机快照"><a href="#删除虚拟机快照" class="headerlink" title="删除虚拟机快照"></a>删除虚拟机快照</h1><p>(1) 查看虚拟机快照</p>
<pre><code># qemu-img info clone-2.qcow2
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.58.png" alt="1.58"></p>
<p>这里删除第一个快照1378579737</p>
<p>(2) 删除快照</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.59.png" alt="1.59"></p>
<p>到此kvm虚拟机快照测试完毕!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;kvm虚拟机默认使用raw格式的镜像格式，性能最好，速度最快，它的缺点就是不支持一些新的功能，如支持镜像,zlib磁盘压缩,AES加密等。要使用镜像功能，磁盘格式必须为qcow2。KMV下磁盘模式raw和qcow2的性能比较请参阅&lt;a href=&quot;http://www.cnblogs.com/zhangzhang/archive/2012/02/13/2348928.html&quot;&gt;KMV下磁盘模式raw和qcow2的性能比较&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面开始kvm虚拟机快照备份的过程&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（三）-设置VNC和时间同步</title>
    <link href="http://yjscloud.com/2017/10/20/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E8%AE%BE%E7%BD%AEVNC%E5%92%8C%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    <id>http://yjscloud.com/2017/10/20/kvm学习笔记（三）-设置VNC和时间同步/</id>
    <published>2017-10-19T18:54:34.000Z</published>
    <updated>2017-12-02T09:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设置VNC"><a href="#设置VNC" class="headerlink" title="设置VNC"></a>设置VNC</h1><p>这里的通过vnc方式访问虚拟机不是在kvm虚拟机安装配置vnc服务器，通过虚拟主机的IP地址与端口进行访问，kvm虚拟化对vnc的支持相对来说比xen要好很多，在虚拟主机上配置VNC访问虚拟机，也是为了多提供一种方式访问虚拟机。</p>
<a id="more"></a>
<h2 id="修改qemu-conf"><a href="#修改qemu-conf" class="headerlink" title="修改qemu.conf"></a>修改qemu.conf</h2><pre><code># vim  /etc/libvirt/qemu.conf
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.38.png" alt="1.38"></p>
<p>去掉第12行的注释，保存退出</p>
<p>注意：vnclisten 默认绑定127.0.0.1 在配置文件里指定VNC 绑定0.0.0.0的IP,就不用在安装kvm虚拟机时指定vnclisten参数了。在虚拟主机上有很多个虚拟机的时候，需要指定每个虚拟机的端口，否则将会很乱。</p>
<h2 id="修改虚拟机配置文件"><a href="#修改虚拟机配置文件" class="headerlink" title="修改虚拟机配置文件"></a>修改虚拟机配置文件</h2><pre><code># virsh edit clone-1
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.39.png" alt="1.39"></p>
<p>配置VNC的配置文件,port是指定端口号,autoport是自动分配端口号。</p>
<h2 id="启动虚拟机并测试VNC"><a href="#启动虚拟机并测试VNC" class="headerlink" title="启动虚拟机并测试VNC"></a>启动虚拟机并测试VNC</h2><p>启动虚拟机</p>
<pre><code># virsh start clone-1
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.40.png" alt="1.40"></p>
<p>使用vnc工具登陆</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.41.png" alt="1.41"></p>
<p>登陆成功</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.42.png" alt="1.42"></p>
<hr>
<h1 id="kvm虚拟机时间配置"><a href="#kvm虚拟机时间配置" class="headerlink" title="kvm虚拟机时间配置"></a>kvm虚拟机时间配置</h1><p>在虚拟化环境中，虚拟机在长时间运行过程中，时间会变慢，通常的作法是配置ntpdate定时与时间服务器进行时间同步的计划任务。KVM虚拟机默认采用utc时间，需要专门修改，以及考虑kvm时间同步问题。</p>
<h2 id="kvm虚拟机修改时间配置文件"><a href="#kvm虚拟机修改时间配置文件" class="headerlink" title="kvm虚拟机修改时间配置文件"></a>kvm虚拟机修改时间配置文件</h2><p>kvm虚拟机采用utc时间，需要先修改配置文件使用KVM虚拟机的时间与虚拟主机同步。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.43.png" alt="1.43"></p>
<p>修改utc为localtime，保存退出，重启虚拟机</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.44.png" alt="1.44"></p>
<h2 id="关于kvm虚拟机时间问题解决思路"><a href="#关于kvm虚拟机时间问题解决思路" class="headerlink" title="关于kvm虚拟机时间问题解决思路"></a>关于kvm虚拟机时间问题解决思路</h2><p>(1)虚拟机时间慢是所有虚拟化平台的一共性问题。</p>
<p>(2)解决时间的最终解决方法就是在生产环境中配置时间服务器，kvm虚拟化服务器与kvm机均都要配置时间同步的计划任务，这才是解决这一个问题最终解决方案。</p>
<p>示例：如果能访问互联网，最简单了，需要kvm虚拟机与主机时间同步，但是运行一段时间会慢，一定要做时间同步，特别是对时间敏感的环境。   </p>
<pre><code># crontab -e    
01 */3 * * * /usr/sbin/ntpdate cn.pool.ntp.org &gt;&gt; /dev/null 2&gt;&amp;1
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;设置VNC&quot;&gt;&lt;a href=&quot;#设置VNC&quot; class=&quot;headerlink&quot; title=&quot;设置VNC&quot;&gt;&lt;/a&gt;设置VNC&lt;/h1&gt;&lt;p&gt;这里的通过vnc方式访问虚拟机不是在kvm虚拟机安装配置vnc服务器，通过虚拟主机的IP地址与端口进行访问，kvm虚拟化对vnc的支持相对来说比xen要好很多，在虚拟主机上配置VNC访问虚拟机，也是为了多提供一种方式访问虚拟机。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（二）-KVM基础学习</title>
    <link href="http://yjscloud.com/2017/10/18/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-KVM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yjscloud.com/2017/10/18/kvm学习笔记（二）-KVM基础学习/</id>
    <published>2017-10-17T20:06:18.000Z</published>
    <updated>2017-12-02T09:33:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kvm简绍"><a href="#kvm简绍" class="headerlink" title="kvm简绍"></a>kvm简绍</h1><p>KVM 全称是 基于内核的虚拟机（Kernel-basedVirtual Machine），它是一个 Linux 的一个内核模块，该内核模块使得 Linux 变成了一个 Hypervisor：</p>
<ul>
<li>它由 Quramnet 开发，该公司于 2008年被 Red Hat 收购。</li>
<li>它支持 x86 (32 and 64 位), s390, Powerpc 等 CPU。</li>
<li>它从 Linux 2.6.20 起就作为一模块被包含在 Linux 内核中。</li>
<li>它需要支持虚拟化扩展的 CPU。</li>
<li>它是完全开源的。</li>
</ul>
<a id="more"></a>
<p>（1）KVM特性</p>
<p>嵌入到Linux正式Kernel（提高兼容性），代码级资源调用（提高性能），虚拟机就是一个进程（内存易于管理）</p>
<p>（2）KVM虚拟化架构</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.20.png" alt="1.20"></p>
<p>（3)KVM CPU性能优化</p>
<ul>
<li>一个 KVM 虚机即一个 Linux qemu-kvm 进程，与其他Linux 进程一样被Linux 进程调度器调度。</li>
<li>KVM 虚机包括虚拟内存、虚拟CPU和虚机 I/O设备，其中，内存和 CPU 的虚拟化由 KVM 内核模块负责实现，I/O 设备的虚拟化由 QEMU 负责实现。</li>
<li>KVM户机系统的内存是 qumu-kvm 进程的地址空间的一部分。</li>
<li><p>KVM 虚机的 vCPU 作为 线程运行在 qemu-kvm 进程的上下文中。</p>
<p>CPU虚拟化<br><img src="http://oxysobnip.bkt.clouddn.com/1.21.png" alt="1.21"></p>
</li>
</ul>
<h1 id="KVM安装"><a href="#KVM安装" class="headerlink" title="KVM安装"></a>KVM安装</h1><h2 id="检查主机是否支持虚拟化"><a href="#检查主机是否支持虚拟化" class="headerlink" title="检查主机是否支持虚拟化"></a>检查主机是否支持虚拟化</h2><p>   打开您的虚拟机的虚拟化引擎</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.22.png" alt="1.22"></p>
<pre>
# egrep -c '(vmx|svm)' /proc/cpuinfo
</pre>

<p>命令结果大于0表示cpu支持虚拟化</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.23.png" alt="1.23"></p>
<p>最好关闭防火墙和关闭selinux</p>
<pre>
# systemctl stop firewalld
# systemctl disable firewalld
# vim /etc/selinux/config
    将enforcing改为disabled
</pre>

<h2 id="配置本地yum源"><a href="#配置本地yum源" class="headerlink" title="配置本地yum源"></a>配置本地yum源</h2><p>替换CentOS默认源，默认生产环境上不了外网，所以你得想办法用自己的内部Yum源，如果没有，需要搭建一个。让系统上网，然后运行下面命令：</p>
<pre>
# cd /etc/yum.repos.d
# rm -rf *
# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
# wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
</pre>

<p>在我的实验环境中我已经搭好了本地yum源，在这里我直接使用本地yum源，下面是我的yum配置文件</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.24.png" alt="1.24"></p>
<h2 id="安装kvm以及相应的依赖包"><a href="#安装kvm以及相应的依赖包" class="headerlink" title="安装kvm以及相应的依赖包"></a>安装kvm以及相应的依赖包</h2><p>安装依赖包</p>
<pre>
# yum -y groupinstall "Virtualization Host"
# yum -y install virt-{install,viewer,manager} 
</pre>

<p>相关组件介绍</p>
<p>【1】libvirt：操作和管理KVM虚机的虚拟化 API，使用 C 语言编写，可以由 Python,Ruby, Perl, PHP, Java 等语言调用。可以操作包括 KVM，vmware，XEN，Hyper-v, LXC 等 Hypervisor。</p>
<p>【2】Virsh：基于 libvirt 的 命令行工具 （CLI）</p>
<p>【3】Virt-Manager：基于 libvirt 的 GUI 工具</p>
<p>kvm内核模块</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.25.png" alt="1.25"></p>
<h2 id="配置网卡为桥接模式"><a href="#配置网卡为桥接模式" class="headerlink" title="配置网卡为桥接模式"></a>配置网卡为桥接模式</h2><pre>
# cd /etc/sysconfig/network-scripts/
# cp ifcfg-eno16777736 ifcfg-br0
</pre>

<p>我的配置文件</p>
<pre>
[root@kvm network-scripts]# cat ifcfg-eno16777736 
TYPE="Ethernet"
DEVICE="eno16777736"
NAME="eno16777736"
BRIDGE=br0
[root@kvm network-scripts]# cat ifcfg-br0 
TYPE=Bridge
NAME=br0
DEVICE=br0
IPADDR=172.31.129.95
NETMASK=255.255.255.0
GATEWAY=172.31.129.254
</pre>

<h2 id="创建虚拟机硬盘"><a href="#创建虚拟机硬盘" class="headerlink" title="创建虚拟机硬盘"></a>创建虚拟机硬盘</h2><pre>
# qemu-img create -f qcow2 /mnt/vm-test/iso/centos-7.2.qcow2 10G
# chown qemu:qemu /mnt/vm-test/iso/centos-7.2.qcow2 -R
</pre>

<h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><pre>
[root@kvm iso]# virt-install --virt-type kvm --name centos-7.2 --ram 512 \    # name 是自己取得
> --vcpus 1 \        #指定cpu核数
> --cdrom=CentOS-7-x86_64-DVD-1511.iso \  #指定镜像
> --disk centos-7.2.qcow2,format=qcow2 \    #disk参数为上面创建的磁盘
> --network network=default \  #网络设置为默认网络（NAT）
> --graphics vnc,listen=0.0.0.0 --noautoconsole \ #运行所有网段远程，远程方式采用vnc
> --os-type=linux --os-variant=rhel7 #指定系统类型
</pre>

<p>桥接网卡位置</p>
<pre>
virt-install --virt-type kvm --name centos-7.2 --ram 512 --vcpus 1 --cdrom=CentOS-7-x86_64-DVD-1511.iso --disk centos7.2.qcow2,format=qcow2 --network bridge=virbr0 --vnc --vncport=5910 --vnclisten=0.0.0.0  --os-type=linux --os-variant=rhel7
</pre>

<h2 id="远程虚拟机"><a href="#远程虚拟机" class="headerlink" title="远程虚拟机"></a>远程虚拟机</h2><p>查看端口：netstat –natp</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.26.png" alt="1.26"></p>
<p>在vnc输入172.31.129.95:5900即可远程虚拟机</p>
<h1 id="KVM命令介绍"><a href="#KVM命令介绍" class="headerlink" title="KVM命令介绍"></a>KVM命令介绍</h1><h2 id="virsh"><a href="#virsh" class="headerlink" title="virsh"></a>virsh</h2><p>virsh:虚拟化交互式终端</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.27.png" alt="1.27"></p>
<ul>
<li>virsh list  # 显示本地活动虚拟机</li>
<li>virsh start kvm_name # 启动非活动虚拟机, kvm_name为你的虚拟机名字</li>
<li>virsh create kvm_name.xml  # 创建虚拟机（创建后，虚拟机立即执行，成为活动主机）</li>
<li>virsh suspend kvm_name # 暂停虚拟机</li>
<li>virsh resume kvm_name # 启动暂停的虚拟机</li>
<li>virsh shutdown kvm_name # 正常关闭虚拟机</li>
<li>virsh destroy kvm_name # 强制关闭虚拟机</li>
<li>virsh dominfo kvm_name # 显示虚拟机的基本信息</li>
<li>virsh dumpxml kvm_name # 显示虚拟机的当前配置文件</li>
<li>virsh setmem kvm_name 51200 # 给不活动虚拟机设置内存大小</li>
<li>virsh setvcpus kvm_name 4  # 给不活动虚拟机设置cpu个数</li>
<li><p>virsh edit kvm_name # 编辑配置文件（一般用在刚定义完VM）</p>
<p>虚拟机配置文件路径：/etc/libvirt/qemu</p>
</li>
</ul>
<h2 id="虚拟化vcpu操作"><a href="#虚拟化vcpu操作" class="headerlink" title="虚拟化vcpu操作"></a>虚拟化vcpu操作</h2><pre>
# yum -y install numactl
</pre>

<ul>
<li>nodeinfo #查看节点配置信息</li>
<li>dominfo    #查看虚拟机节点配置信息</li>
<li>numactl –hardware #查看节点硬件信息</li>
<li>numastat –c qemu-kvm</li>
<li>virsh<ul>
<li>vcpuinfo kvm_name #查看运行在那个逻辑cpu上</li>
<li>emulatorpin kvm_name #查看可以调度逻辑cpu</li>
<li>emulatorpin kvm_name 1-2 –live #限制可以调度逻辑cpu(重启生效)<br><img src="http://oxysobnip.bkt.clouddn.com/1.28.png" alt="1.28"></li>
</ul>
</li>
</ul>
<p>虚拟机cpu优化</p>
<p>vcpu单独强制绑定</p>
<ul>
<li>vcpupin kvm_name 0 1</li>
<li>vcpupin kvm_name 1 2</li>
<li>vcpuinfo</li>
<li>dumpxml kvm_name</li>
</ul>
<p>命令使用参考文章：<br><a href="http://hl914.blog.51cto.com/4128173/1557615/" target="_blank" rel="external">CPU性能监控之二—–Numa架构下进程与CPU绑定</a></p>
<p><a href="http://blog.csdn.net/shaoyunzhe/article/details/53606584" target="_blank" rel="external">numa总结</a></p>
<h2 id="安装acpid"><a href="#安装acpid" class="headerlink" title="安装acpid"></a>安装acpid</h2><p>默认情况下virsh工具不能对linux虚拟机进行关机操作，linux操作系统需要开启与启动acpid服务。在安装KVM linux虚拟机必须配置此服务。 </p>
<pre>
# yum install -y acpid
# systemctl enable acpid
</pre>

<h2 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h2><p>（1）根据模板文件修改</p>
<ul>
<li>进入对应目录拷贝模板文件</li>
</ul>
<pre>
# cd /etc/libvirt/qemu
# cp centos-7.2.xml clone-1.xml
</pre>

<ul>
<li>修改虚拟名称</li>
<li>删除uuid</li>
</ul>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.29.png" alt="1.29"></p>
<ul>
<li>指定disk</li>
</ul>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.30.png" alt="1.30"></p>
<ul>
<li>删除mac</li>
</ul>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.31.png" alt="1.31"></p>
<ul>
<li>修改vnc远程允许端口（可选）</li>
</ul>
<p>如果您上面选择桥接模式创建虚拟机且指定了端口5910，请您把5910改为5911，这样可以避免与centos7.3的端口冲突</p>
<p>（2）复制qcow2文件</p>
<pre>
# cp centos-7.2.qcow2 clone-1.qcow2
</pre>

<p>（3）virsh define 模板文件路径</p>
<pre>
# virsh define /etc/libvirt/qemu/clone-1.xml
</pre>

<p>（4）启动虚拟机</p>
<pre>
# virsh start clone-1
</pre>

<p>（5）删除克隆的虚拟机</p>
<pre>
# virsh shutdown clone-1
# virsh undefine clone-1
# rm –rf /mnt/vm-test/clone-1.qcow2
</pre>

<p>（6）一个小坑</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.32.png" alt="1.32"></p>
<p>这一行位置在第86行，修改配置文件时一定要删除，不知道为什么，它会出现在CentOS7.2版本的系统中，而在CentOS7.3版本的系统中不会出现这一行代码！</p>
<h2 id="虚拟机快照snapshot"><a href="#虚拟机快照snapshot" class="headerlink" title="虚拟机快照snapshot"></a>虚拟机快照snapshot</h2><pre>
virsh # snapshot-create-as centos-7.2 kuaizhao #创建虚拟机centos-7.2的快照，快照名字为kuaizhao
Domain snapshot kuaizhao created
virsh # snapshot-list centos-7.2 #显示虚拟机快照的名称
 Name                 Creation Time             State
------------------------------------------------------------
 kuaizhao             2017-10-17 09:53:49 +0800 shutoff

virsh # snapshot-revert centos-7.2 kuaizhao #恢复快照
</pre>

<h2 id="添加磁盘"><a href="#添加磁盘" class="headerlink" title="添加磁盘"></a>添加磁盘</h2><p>(1)创建磁盘</p>
<pre>
# qemu-img create -f qcow2 /mnt/vm-test/ios/testadd.qcow2 10G
</pre>

<p>(2)修改配置文件</p>
<pre>
# virsh edit centos-7.2
</pre>

<p>添加以下内容并保存配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">'file'</span> <span class="attr">device</span>=<span class="string">'disk'</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">'qemu'</span> <span class="attr">type</span>=<span class="string">'qcow2'</span>/&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">'/mnt/vm-test/ios/testadd.qcow2'</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">'vdb'</span> <span class="attr">bus</span>=<span class="string">'virtio'</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></div></pre></td></tr></table></figure>
<pre>
# virsh create /etc/libvirt/qemu/centos-7.2.xml
# virsh destroy centos-7.2
# virsh start centos-7.2
</pre>

<p>重启后进入虚拟机查看</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.33.png" alt="1.33"></p>
<p>(3)直接扩展qcow2磁盘</p>
<p>qcow2格式的好处就是支持直接扩展，下面我们关闭虚拟机直接对磁盘进行扩容</p>
<pre><code># qemu-img resize clone-3.qcow2 +10G
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.35-1.png" alt="1.35-1"></p>
<p>经过前后对比，磁盘大小已由20G扩展到30G,已扩展,qcow2磁盘格式必须采用此方式进行扩展!</p>
<h2 id="kvm虚拟机的网络模式"><a href="#kvm虚拟机的网络模式" class="headerlink" title="kvm虚拟机的网络模式"></a>kvm虚拟机的网络模式</h2><p>(1)nat网络模式</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.34.png" alt="1.34"></p>
<p>(2)桥接模式</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.35.png" alt="1.35"></p>
<p>（3）添加NAT网络</p>
<p> 定义一个虚拟网络</p>
<pre>
# virsh net-define /usr/share/libvirt/networks/default.xml
</pre>

<p>添加内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">network</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">bridge</span> <span class="attr">name</span>=<span class="string">"virbr0"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">forward</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">ip</span> <span class="attr">address</span>=<span class="string">"192.168.122.1"</span> <span class="attr">netmask</span>=<span class="string">"255.255.255.0"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">dhcp</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">range</span> <span class="attr">start</span>=<span class="string">"192.168.122.2"</span> <span class="attr">end</span>=<span class="string">"192.168.122.254"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">dhcp</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">ip</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">network</span>&gt;</span></div></pre></td></tr></table></figure>
<p>设置为自动启动</p>
<pre>
# virsh net-autostart default
</pre>

<p>查看网络</p>
<pre>
# brctl show
</pre>

<p>修改/etc/sysctl.conf中参数，允许ip转发</p>
<pre>
# net.ipv4.ip_forward=1
</pre>

<p>修改虚拟机配置文件</p>
<pre>
# virsh edit centos-7.2
</pre>

<p>修改网卡链接模式</p>
<p>桥接模式</p>
<pre><code>&lt;interface type=&apos;bridge&apos;&gt;
    &lt;source bridge=&apos;br0&apos;/&gt;
    &lt;model type=&apos;virtio&apos;/&gt;
    &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x02&apos; function=&apos;0x0&apos;/&gt;
&lt;/interface&gt;
</code></pre><p>nat模式</p>
<pre><code>&lt;interface type=&apos;network&apos;&gt;
    &lt;source network=&apos;default&apos;/&gt;
    &lt;model type=&apos;virtio&apos;/&gt;
    &lt;address type=&apos;pci&apos; domain=&apos;0x0000&apos; bus=&apos;0x00&apos; slot=&apos;0x03&apos; function=&apos;0x0&apos;/&gt;
&lt;/interface&gt; 
</code></pre><p>修改完之后，保存退出。</p>
<pre>
# virsh create /etc/libvirt/qemu/centos-7.2.xml
</pre>

<ol>
<li><p>修改桥接后nat不能上网问题</p>
<p>默认配置文件：（virsh交互界面）</p>
</li>
</ol>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.36.png" alt="1.36"></p>
<p>将默认配置文件修改为：</p>
<pre>
# vim /etc/libvirt/qemu/networks/default.xml
</pre>

<p><img src="http://oxysobnip.bkt.clouddn.com/1.37.png" alt="1.37"></p>
<p>然后再执行如下命令</p>
<pre>
virsh # net-define /etc/libvirt/qemu/networks/default.xml
virsh # net-destroy default
virsh # net-start default
</pre>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kvm简绍&quot;&gt;&lt;a href=&quot;#kvm简绍&quot; class=&quot;headerlink&quot; title=&quot;kvm简绍&quot;&gt;&lt;/a&gt;kvm简绍&lt;/h1&gt;&lt;p&gt;KVM 全称是 基于内核的虚拟机（Kernel-basedVirtual Machine），它是一个 Linux 的一个内核模块，该内核模块使得 Linux 变成了一个 Hypervisor：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它由 Quramnet 开发，该公司于 2008年被 Red Hat 收购。&lt;/li&gt;
&lt;li&gt;它支持 x86 (32 and 64 位), s390, Powerpc 等 CPU。&lt;/li&gt;
&lt;li&gt;它从 Linux 2.6.20 起就作为一模块被包含在 Linux 内核中。&lt;/li&gt;
&lt;li&gt;它需要支持虚拟化扩展的 CPU。&lt;/li&gt;
&lt;li&gt;它是完全开源的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（一）——虚拟化介绍</title>
    <link href="http://yjscloud.com/2017/10/18/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E8%99%9A%E6%8B%9F%E5%8C%96%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yjscloud.com/2017/10/18/kvm学习笔记（一）-虚拟化介绍/</id>
    <published>2017-10-17T19:04:16.000Z</published>
    <updated>2017-12-02T09:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是系统虚拟化"><a href="#什么是系统虚拟化" class="headerlink" title="什么是系统虚拟化"></a>什么是系统虚拟化</h2><p>系统虚拟化是将底层物理设备与上层操作系统、软件分离的一种去耦合技术，在一台物理机器上逻辑的划分出多台机器。虚拟化的目标是实现IT资源利用效率和灵活性的最大化</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.1.png" alt="1.1"></p>
<p>多个系统融合在一台服务器上——资源利用率高 资源利用率高<br>应用系统不再依赖特定的硬件——系统维护灵活</p>
<a id="more"></a>
<h2 id="虚拟化基础架构"><a href="#虚拟化基础架构" class="headerlink" title="虚拟化基础架构"></a>虚拟化基础架构</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.2.png" alt="1.2"></p>
<h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><p>在一台物理主机上虚拟出多个虚拟计算机（虚拟机，Virtual Machine，VM），其上能同时运行多个独立的操作系统，这些客户操作系统（Guest OS）通过虚拟机管理器（Virtual Machine Monitor，VMM，也称作Hypervisor）访问实际的物理资源。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.3.png" alt="1.3"></p>
<h2 id="为什么需要使用虚拟化"><a href="#为什么需要使用虚拟化" class="headerlink" title="为什么需要使用虚拟化"></a>为什么需要使用虚拟化</h2><p>公司服务器越来越多</p>
<p>   – 充分利用是个问题</p>
<p>   – 统一运维管理是个问题</p>
<ul>
<li>浪费时间</li>
<li>操作繁琐</li>
<li>机器闲置时间较多</li>
</ul>
<p>计算系统利用率不高！</p>
<p>  “多数用户承认，计算系统平均利用率只有25%～30%”</p>
<h2 id="为什么客户要选择服务器虚拟化？"><a href="#为什么客户要选择服务器虚拟化？" class="headerlink" title="为什么客户要选择服务器虚拟化？"></a>为什么客户要选择服务器虚拟化？</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.4.png" alt="1.4"></p>
<ol>
<li>打破“一台服务器对应一套应用”的模式，将物理服务器进行整合，提升利用率</li>
<li>服务器和相关IT硬件更少，节省了机房空间，也减少了散热和电力需求</li>
<li>具备灵活数据备份和应用迁移机制，保障服务永不中断</li>
<li>资源动态调配和模板化部署，应用系统快速上线，及时响应业务变化</li>
</ol>
<h2 id="虚拟化技术分类"><a href="#虚拟化技术分类" class="headerlink" title="虚拟化技术分类"></a>虚拟化技术分类</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.5.png" alt="1.5"></p>
<h2 id="什么是桌面虚拟化？"><a href="#什么是桌面虚拟化？" class="headerlink" title="什么是桌面虚拟化？"></a>什么是桌面虚拟化？</h2><p>桌面虚拟化（MS：Remote Desktop、Citrix：XenDesktop、Vmware：View）</p>
<p>   − 将原本在本地电脑安装的桌面系统统一在后端数据中心进行部署和管理；</p>
<p>   − 用户可以通过任何设备，在任何地点，任何时间访问属于自己的桌面系统环境。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.6.png" alt="1.6"></p>
<h2 id="服务器虚拟化"><a href="#服务器虚拟化" class="headerlink" title="服务器虚拟化"></a>服务器虚拟化</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.7.png" alt="1.7"></p>
<h2 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h2><p>【1】无虚拟化</p>
<p>   – CPU一般设为四个Ring</p>
<p>   – Kernel Mode一般跑在Ring 0上</p>
<p>   – User Mode一般跑在Ring 3上</p>
<p>   – 对于一个普通的传统的Linux系统没有问题</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.8.png" alt="1.8"></p>
<p>【2】虚拟化</p>
<p>   – 在Guest机器和Host机器中间加一层Hypervisor</p>
<p>   – Host机器看它像跑在自己上面的程序</p>
<p>   – Guest机器看它像自己所运行的硬件</p>
<p>   – 如果Host机器和Guest机器都跑相同的Linux，它们的Kernel都想运行在Ring 0，可怎么办？</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.9.png" alt="1.9"></p>
<p>【3】传统cpu工作模式</p>
<p>   – X86 操作系统是设计在直接运行在裸硬件设备上的，因此它们自动认为它们完全占有计算机硬件。x86 架构提供四个特权级别给操作系统和应用程序来访问硬件。 Ring 是指 CPU 的运行级别，Ring 0是最高级别，Ring1次之，Ring2更次之…… 就 Linux+x86 来说，</p>
<p>   – 操作系统（内核）需要直接访问硬件和内存，因此它的代码需要运行在最高运行级别 Ring0上，这样它可以使用特权指令，控制中断、修改页表、访问设备等等。</p>
<p>   – 应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。这个过程也称作用户态和内核态的切换。</p>
<p>【4】为什么需要 为什么需要 CPU 虚拟化</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.10.png" alt="1.10"></p>
<h2 id="虚拟化分类"><a href="#虚拟化分类" class="headerlink" title="虚拟化分类"></a>虚拟化分类</h2><p>   虚拟化在这里就遇到了一个难题，因为宿主操作系统是工作在 ring0 的，客户操作系统就不能也在 ring0 了，但是它不知道这一点，以前执行什么指令，现在还是执行什么指令，但是没有执行权限是会出错的。所以这时候虚拟机管理程序（VMM）需要避免这件事情发生。 虚机怎么通过 VMM 实现 Guest CPU 对硬件的访问，根据其原理不同有三种实现技术：</p>
<p>【1】基于二进制翻译的全虚拟化（Full Virtualization with Binary Translation）</p>
<p>   客户操作系统运行在 Ring 1，它在执行特权指令时，会触发异常（CPU的机制，没权限的指令会触发异常），然后 VMM捕获这个异常，在异常里面做翻译，模拟，最后返回到客户操作系统内，客户操作系统认为自己的特权指令工作正常，继续运行。但是这个性能损耗，就非常的大， 简单的一条指令，执行完，了事，现在却要通过复杂的异常处理过程</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.11.png" alt="1.11"></p>
<p>异常 “捕获（trap）-翻译（handle）-模拟（emulate）” 过程：</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.12.png" alt="1.12"></p>
<p>【2】 超虚拟化（或者半虚拟化/操作系统辅助虚拟化 Paravirtualization）</p>
<p>   半虚拟化的思想就是，修改操作系统内核，替换掉不能虚拟化的指令，通过超级调用（hypercall）直接和底层的虚拟化层hypervisor来通讯，hypervisor 同时也提供了超级调用接口来满足其他关键内核操作，比如内存管理、中断和时间保持。这种做法省去了全虚拟化中的捕获和模拟，大大提高了效率。所以像XEN这种半虚拟化技术，客户机操作系统都是有一个专门的定制内核版本，和x86、mips、arm这些内核版本等价。这样以来，就不会有捕获异常、翻译、模拟的过程了，性能损耗非常低。这就是XEN这种半虚拟化架构的优势。这也是为什么XEN只支持虚拟化Linux，无法虚拟化windows原因，微软不改代码啊。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.13.png" alt="1.13"></p>
<p>【3】硬件辅助的全虚拟化</p>
<p>   2005年后，CPU厂商Intel 和 AMD 开始支持虚拟化了。Intel 引入了 Intel-VT （Virtualization Technology）技术。这种 CPU，有 VMX root operation 和 VMX non-root operation两种模式，两种模式都支持Ring 0 ~ Ring 3 共 4个运行级别。这样，VMM 可以运行在 VMX root operation模式下，客户 OS 运行在VMX non-root operation模式下。也就说，硬件这层就做了些区分，这样全虚拟化下，那些靠“捕获异常-翻译-模拟”的实现就不需要了。而且CPU厂商，支持虚拟化的力度越来越大，靠硬件辅助的全虚拟化技术的性能逐渐逼近半虚拟化，再加上全虚拟化不需要修改客户操作系统这一优势，全虚拟化技术应该是未来的发展趋势</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.14.png" alt="1.14"></p>
<h2 id="三种虚拟化技术的比较"><a href="#三种虚拟化技术的比较" class="headerlink" title="三种虚拟化技术的比较"></a>三种虚拟化技术的比较</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.15.png" alt="1.15"></p>
<h2 id="全虚拟化-vs-半虚拟化"><a href="#全虚拟化-vs-半虚拟化" class="headerlink" title="全虚拟化 vs 半虚拟化"></a>全虚拟化 vs 半虚拟化</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.16.png" alt="1.16"></p>
<h2 id="服务器虚拟化方法"><a href="#服务器虚拟化方法" class="headerlink" title="服务器虚拟化方法"></a>服务器虚拟化方法</h2><p>【1】全虚拟化(Full-Virtulization)：无需修改操作系统， VM ESXi、Linux KVM</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.17.png" alt="1.17"></p>
<p>【2】半虚拟化(Para-Virtulization)：集成半虚拟化代码，直接运行特权指令，性能接近物理机，需要修改操作系统，MS Hyper-V、 Ctrix Xen、IBM PowerVM</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.18.png" alt="1.18"></p>
<p>【3】操作系统层虚拟化：开发、测试环境，VM Workstation、VM Server、Oracle VitrualBox</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.19.png" alt="1.19"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是系统虚拟化&quot;&gt;&lt;a href=&quot;#什么是系统虚拟化&quot; class=&quot;headerlink&quot; title=&quot;什么是系统虚拟化&quot;&gt;&lt;/a&gt;什么是系统虚拟化&lt;/h2&gt;&lt;p&gt;系统虚拟化是将底层物理设备与上层操作系统、软件分离的一种去耦合技术，在一台物理机器上逻辑的划分出多台机器。虚拟化的目标是实现IT资源利用效率和灵活性的最大化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oxysobnip.bkt.clouddn.com/1.1.png&quot; alt=&quot;1.1&quot;&gt;&lt;/p&gt;
&lt;p&gt;多个系统融合在一台服务器上——资源利用率高 资源利用率高&lt;br&gt;应用系统不再依赖特定的硬件——系统维护灵活&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
