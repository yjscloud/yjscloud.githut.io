<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>戏子登台</title>
  <subtitle>唱一曲词，戏子登台，人生若只初相见，卖弄风骚为谁演。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yjscloud.com/"/>
  <updated>2018-05-17T15:46:20.000Z</updated>
  <id>http://yjscloud.com/</id>
  
  <author>
    <name>Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kolla容器化部署OpenStack：多节点部署</title>
    <link href="http://yjscloud.com/2018/04/14/kolla%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2OpenStack%EF%BC%9A%E5%A4%9A%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2/"/>
    <id>http://yjscloud.com/2018/04/14/kolla容器化部署OpenStack：多节点部署/</id>
    <published>2018-04-14T12:59:18.000Z</published>
    <updated>2018-05-17T15:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们已经部署了单节点的OpenStack环境，这次我们尝试部署一个多节点的环境(包括1个controller节点，1个compute节点，1个storage节点)，之前的单节点因为已经安装了kolla-ansible和docker registry，我们把它当做部署节点。</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>准备三台服务器，分别作为controller节点，compute节点，storage节点。其中controller节点3张网卡，compute、storage节点2张网卡。操作系统为centos7.4</p>
<p>1）关闭Selinux </p>
<pre><code>vi /etc/sysconfig/selinux
SELINUX=disabled
</code></pre><p>2）关闭firewalld</p>
<pre><code>systemctl stop firewalld
systemctl disable firewalld
</code></pre><p>3）设置主机名，hosts文件 </p>
<pre><code>vi /etc/hosts
172.16.31.130 control01 
172.16.31.131 controller 
172.16.31.132 compute 
172.16.31.133 storage
</code></pre><p>4）storage节点加盘 </p>
<p>为storage节点划分磁盘，作为cinder的lvm后端，storage节点有13tb的硬盘采用parted分区，分区过程略去</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-17.png" alt="k-17"></p>
<p>创建pv、vg</p>
<pre><code>[root@storage ~]# pvcreate /dev/sdb
Physical volume &quot;/dev/sdb&quot; successfully created.
[root@storage ~]# vgcreate cinder-volumes /dev/sdb
Volume group &quot;cinder-volumes&quot; successfully created
</code></pre><p>修改配置 </p>
<pre><code>vi /etc/lvm/lvm.conf
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/k-18.png" alt="k-18"></p>
<p>重启lvm服务</p>
<pre><code>systemctl restart lvm2-lvmetad.service
</code></pre><p>5）确认节点配置</p>
<p>controller 3 张网卡 </p>
<p>compute 2 张网卡 </p>
<p>storage 2 张网卡(其实一张即可，因为不需要tunnel网络) </p>
<p>storage 磁盘已经分区</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-19.png" alt="k-19"></p>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>1）下载相关docker rpm包</p>
<p>这里我已经到docker把docker的rpm下载下来了，我们上传的相关的目录下，当然还是需要配centos和epel的源才能正常安装的</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-20.png" alt="k-20"></p>
<p>2）安装Docker 1.12.6（三台服务器都要安装）</p>
<pre><code>yum install docker-engine-* -y
</code></pre><p>在各个节点安装</p>
<pre><code>yum install python-docker-py -y
</code></pre><p>3）设置Docker</p>
<pre><code>mkdir /etc/systemd/system/docker.service.d
tee /etc/systemd/system/docker.service.d/kolla.conf &lt;&lt; &apos;EOF&apos;
[Service]
MountFlags=shared
EOF
</code></pre><p>4）重启相关服务</p>
<pre><code>systemctl daemon-reload
systemctl enable docker
systemctl restart docker
</code></pre><p>5）编辑/usr/lib/systemd/system/docker.service文件</p>
<pre><code>ExecStart=/usr/bin/dockerd --insecure-registry 172.16.31.130:4000
</code></pre><p>6）重启Docker服务</p>
<pre><code>systemctl daemon-reload
systemctl restart docker
</code></pre><h1 id="配置免密登录"><a href="#配置免密登录" class="headerlink" title="配置免密登录"></a>配置免密登录</h1><p>部署节点和其他节点免密登陆</p>
<pre><code>[root@control01 ~]# ssh-keygen 
[root@control01 ~]# ssh-copy-id controller 
[root@control01 ~]# ssh-copy-id compute 
[root@control01 ~]# ssh-copy-id storage
</code></pre><h1 id="部署OpenStack"><a href="#部署OpenStack" class="headerlink" title="部署OpenStack"></a>部署OpenStack</h1><p>1）停止部署节点容器</p>
<p>因为部署节点之前已经部署了All in One的OpenStack，为了降低资源占用，我们可以先停止本节的OpenStack相关容器。</p>
<pre><code>[root@control01 ~]# cd /root/kolla-ansible-4.0.3.dev36/tools/
[root@control01 tools]# . kolla-ansible stop
</code></pre><p>2）修改multinode文件</p>
<pre><code>[root@control01 ~]# cd /root/kolla-ansible-4.0.3.dev36/
[root@control01 kolla-ansible-4.0.3.dev36]# cp ansible/inventory/* /home/
[root@control01 ~]# cd /home
[root@control01 home]# ls
all-in-one  multinode
[root@control01 home]# cp multinode mymultinode
[root@control01 home]# vi mymultinode

[control]
controller  
[network]
controller
[compute]
compute
[monitoring]
controller
[storage]
storage
......
</code></pre><p>里面的内容很好理解，表示一个控制节点 controller，网络节点也安装到控制节点，一个计算节点 compute ，一个存储节点 storage，后面的部分不用修改</p>
<p>3）修改global和password配置文件</p>
<pre><code>[root@control01 ~]# cd /etc/kolla/
[root@control01 kolla]# vi globals.yml
</code></pre><p>————————————分割线———————————————</p>
<pre><code>kolla_internal_vip_address: &quot;172.16.31.131&quot;    外部访问地址，如果是非HA环境，是控制节点IP

docker_registry: &quot;172.16.31.130:4000&quot;   镜像库，用部署节点的镜像库
docker_namespace: &quot;99cloud&quot;                 

network_interface: &quot;eno1&quot;   网络接口，默认就这一个接口，这里我们以eth0作为API网络                    
api_interface: &quot;{{ network_interface }}&quot;   用的是eno2
tunnel_interface: &quot;eno2&quot;                   eno2作为vxlan的承载网络
neutron_external_interface: &quot;eno3&quot;          eno3作为外部网络

enable_cinder: &quot;yes&quot;                启用cinder
enable_cinder_backend_lvm: &quot;yes&quot;    cinder后端用lvm
cinder_volume_group: &quot;cinder-volumes&quot;  

enable_haproxy: &quot;no&quot;   不启用haproxy
</code></pre><p>————————————分割线———————————————</p>
<pre><code>[root@control01 kolla]# vi passwords.yml
keystone_admin_password: admin  admin用户登录密码
</code></pre><p>4）部署前检查</p>
<pre><code>[root@control01 ~]# cd /root/kolla-ansible-4.0.3.dev36/tools/
[root@control01 ~]# . kolla-ansible prechecks -i /home/mymultinode
</code></pre><p>没有报错即可正常部署</p>
<p>5）部署</p>
<pre><code>[root@control01 tools]# . kolla-ansible deploy -i /home/mymultinode
</code></pre><p>开始部署，等待大约20分钟，部署完成，一般不会有什么问题，如果有问题，则需要根据报错及容器日志查找原因</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-21.png" alt="k-21"></p>
<p>登录dashboard<br><a href="http://172.16.31.131" target="_blank" rel="external">http://172.16.31.131</a></p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-22.png" alt="k-22"></p>
<p>登录系统，查看各个服务正常，表明部署成功。</p>
<p>可以通过docker ps命令查看各个节点运行的容器</p>
<p>controller节点：</p>
<pre><code>[root@controller ~]# docker ps
CONTAINER ID        IMAGE                                                                        COMMAND             CREATED             STATUS              PORTS               NAMES
1ecab1b4246e        172.16.31.130:4000/99cloud/centos-source-horizon:4.0.2.1                     &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             horizon
b264ea5467ff        172.16.31.130:4000/99cloud/centos-source-heat-engine:4.0.2.1                 &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             heat_engine
08ab0aa8603c        172.16.31.130:4000/99cloud/centos-source-heat-api-cfn:4.0.2.1                &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             heat_api_cfn
6f6aba4804a2        172.16.31.130:4000/99cloud/centos-source-heat-api:4.0.2.1                    &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             heat_api
67729f946b23        172.16.31.130:4000/99cloud/centos-source-neutron-metadata-agent:4.0.2.1      &quot;kolla_start&quot;       24 hours ago        Up 24 hours                      neutron_metadata_agent
f8f8d9f766e9        172.16.31.130:4000/99cloud/centos-source-neutron-l3-agent:4.0.2.1            &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             neutron_l3_agent
fd3a8ca63fdf        172.16.31.130:4000/99cloud/centos-source-neutron-dhcp-agent:4.0.2.1          &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             neutron_dhcp_agent
c9f9f72090a4        172.16.31.130:4000/99cloud/centos-source-neutron-openvswitch-agent:4.0.2.1   &quot;kolla_start&quot;       24 hours ago        Up 24 hours                  neutron_openvswitch_agent
9f19bca0759c        172.16.31.130:4000/99cloud/centos-source-neutron-server:4.0.2.1              &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             neutron_server
e1286083b3f7        172.16.31.130:4000/99cloud/centos-source-openvswitch-vswitchd:4.0.2.1        &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             openvswitch_vswitchd
dd4986364575        172.16.31.130:4000/99cloud/centos-source-openvswitch-db-server:4.0.2.1       &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             openvswitch_db
a6692acea93f        172.16.31.130:4000/99cloud/centos-source-nova-novncproxy:4.0.2.1             &quot;kolla_start&quot;       36 hours ago        Up 36 hours                             nova_novncproxy
cd704f0bc2c7        172.16.31.130:4000/99cloud/centos-source-nova-consoleauth:4.0.2.1            &quot;kolla_start&quot;       36 hours ago        Up 36 hours                             nova_consoleauth
105978eda1a9        172.16.31.130:4000/99cloud/centos-source-nova-conductor:4.0.2.1              &quot;kolla_start&quot;       36 hours ago        Up 36 hours                             nova_conductor
9d9e7571d7dd        172.16.31.130:4000/99cloud/centos-source-nova-scheduler:4.0.2.1              &quot;kolla_start&quot;       36 hours ago        Up 36 hours                             nova_scheduler
7436ca003817        172.16.31.130:4000/99cloud/centos-source-nova-api:4.0.2.1                    &quot;kolla_start&quot;       36 hours ago        Up 36 hours                             nova_api
ae8d830091d3        172.16.31.130:4000/99cloud/centos-source-nova-placement-api:4.0.2.1          &quot;kolla_start&quot;       36 hours ago        Up 36 hours                             placement_api
f053087cfde5        172.16.31.130:4000/99cloud/centos-source-cinder-scheduler:4.0.2.1            &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             cinder_scheduler
8c849182ee63        172.16.31.130:4000/99cloud/centos-source-cinder-api:4.0.2.1                  &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             cinder_api
129996bd76ee        172.16.31.130:4000/99cloud/centos-source-glance-registry:4.0.2.1             &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             glance_registry
fcc184936be5        172.16.31.130:4000/99cloud/centos-source-glance-api:4.0.2.1                  &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             glance_api
06a35ba7eb7f        172.16.31.130:4000/99cloud/centos-source-keystone:4.0.2.1                    &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             keystone
6821886162bc        172.16.31.130:4000/99cloud/centos-source-rabbitmq:4.0.2.1                    &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             rabbitmq
04b556da8365        172.16.31.130:4000/99cloud/centos-source-mariadb:4.0.2.1                     &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             mariadb
859a1d8d0137        172.16.31.130:4000/99cloud/centos-source-cron:4.0.2.1                        &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             cron
4e7230af5339        172.16.31.130:4000/99cloud/centos-source-kolla-toolbox:4.0.2.1               &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             kolla_toolbox
50be20c91704        172.16.31.130:4000/99cloud/centos-source-fluentd:4.0.2.1                     &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             fluentd
72b2538e1beb        172.16.31.130:4000/99cloud/centos-source-memcached:4.0.2.1                   &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             memcached
</code></pre><p>compute节点：</p>
<pre><code>[root@compute ~]# docker ps
CONTAINER ID        IMAGE                                                                        COMMAND             CREATED             STATUS              PORTS               NAMES
0f954ef9095e        172.16.31.130:4000/99cloud/centos-source-neutron-openvswitch-agent:4.0.2.1   &quot;kolla_start&quot;       24 hours ago        Up 24 hours                  neutron_openvswitch_agent
8f62c376e2b5        172.16.31.130:4000/99cloud/centos-source-openvswitch-vswitchd:4.0.2.1        &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             openvswitch_vswitchd
005c3dd582a9        172.16.31.130:4000/99cloud/centos-source-openvswitch-db-server:4.0.2.1       &quot;kolla_start&quot;       24 hours ago        Up 24 hours                             openvswitch_db
d6a9b676c0ad        172.16.31.130:4000/99cloud/centos-source-nova-compute:4.0.2.1                &quot;kolla_start&quot;       36 hours ago        Up 36 hours                             nova_compute
fbc66c3f40ba        172.16.31.130:4000/99cloud/centos-source-nova-libvirt:4.0.2.1                &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             nova_libvirt
6f942f376c83        172.16.31.130:4000/99cloud/centos-source-nova-ssh:4.0.2.1                    &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             nova_ssh
4872cfb2b025        172.16.31.130:4000/99cloud/centos-source-iscsid:4.0.2.1                      &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             iscsid
c55ec16b0752        172.16.31.130:4000/99cloud/centos-source-cron:4.0.2.1                        &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             cron
426d77add095        172.16.31.130:4000/99cloud/centos-source-kolla-toolbox:4.0.2.1               &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             kolla_toolbox
5f959b2372f0        172.16.31.130:4000/99cloud/centos-sourc
</code></pre><p>stroage节点：</p>
<pre><code>[root@cinder ~]# docker ps
CONTAINER ID        IMAGE                                                            COMMAND             CREATED             STATUS              PORTS               NAMES
7eca045eeff1        172.16.31.130:4000/99cloud/centos-source-cinder-backup:4.0.2.1   &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             cinder_backup
bcdf196510f2        172.16.31.130:4000/99cloud/centos-source-cinder-volume:4.0.2.1   &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             cinder_volume
d59fc8ec7716        172.16.31.130:4000/99cloud/centos-source-tgtd:4.0.2.1            &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             tgtd
7a8d9dab2755        172.16.31.130:4000/99cloud/centos-source-iscsid:4.0.2.1          &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             iscsid
ea471af172de        172.16.31.130:4000/99cloud/centos-source-cron:4.0.2.1            &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             cron
4b41ebf3ea62        172.16.31.130:4000/99cloud/centos-source-kolla-toolbox:4.0.2.1   &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             kolla_toolbox
91c086f63421        172.16.31.130:4000/99cloud/centos-source-fluentd:4.0.2.1         &quot;kolla_start&quot;       37 hours ago        Up 37 hours                             fluentd
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们已经部署了单节点的OpenStack环境，这次我们尝试部署一个多节点的环境(包括1个controller节点，1个compute节点，1个storage节点)，之前的单节点因为已经安装了kolla-ansible和docker registry，我们把它当做部署节点
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://yjscloud.com/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack技能" scheme="http://yjscloud.com/tags/OpenStack%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>kolla容器化部署OpenStack：单点部署</title>
    <link href="http://yjscloud.com/2018/04/13/kolla%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2OpenStack%EF%BC%9A%E5%8D%95%E7%82%B9%E9%83%A8%E7%BD%B2/"/>
    <id>http://yjscloud.com/2018/04/13/kolla容器化部署OpenStack：单点部署/</id>
    <published>2018-04-13T12:37:32.000Z</published>
    <updated>2018-05-17T15:45:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>陈沙克老师发布了一个kolla的Ocata的ISO,这个ISO把所有需要的软件及Docker镜像都集成起来，安装应该非常方便，所以决定试一试。</p>
<p>首先我在一台16g的戴尔服务器上面安装这个iso，配置2块网卡，一块为em1(隧道网络，网段为192.168.0.0/24)，一块为em2(作为作为管理和外部网络，网段为172.16.31.0/24)。 </p>
<p>注意硬盘至少需要200G(安装完成后实际占用空间为25G以内)，否则无法进行安装。</p>
<h1 id="all-in-one部署步骤"><a href="#all-in-one部署步骤" class="headerlink" title="all in one部署步骤"></a>all in one部署步骤</h1><p>（1）使用iso引导，选择 install centos7.3 and kolla</p>
<p>可以使用tab键，修改ip地址和主机名，默认ip地址为10.99.0.2，主机名为control01</p>
<p>这里需要注意，安装完成后，需要设置好网卡1、网卡2的IP地址，最好固定ip地址！网卡名称分别为em1和em2，IP地址分别为192.168.0.130和172.16.31.130</p>
<p>（2）安装系统后，登录系统(root密码为99cloud)，首先要进行如下修改：</p>
<p>1）/etc/hosts 文件需要修改<br>10.99.0.2 control01 改为 172.16.31.0.130 control01 </p>
<p>2）/etc/kolla/globals.yml 文件里面2个IP地址由10.99.0.2替换为172.16.31.130</p>
<p>3）/etc/kolla/globals.yml 文件中  neutron_external_interface: “docker0” 改为neutron_external_interface: “em2”</p>
<p>然后进行部署：</p>
<pre><code>/root/kolla-ansible-4.0.3.dev36/tools/kolla-ansible deploy
</code></pre><p>部署过程中，如果发现下面类似的错误，则需要进入容器，查看日志进行排错。<br>下面这个错误原因就是RabbitMQ容器中的服务没有正常启动(问题1造成)而导致nova-compute服务无法启动。 </p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-1.png" alt="k-1"></p>
<p>遇到的最后一个问题，就是  neutron_openvswitch_agent 容器无法正常启动，排查的结果是  openvswitch_vswitchd 容器里面的 br-ex 下面的port应该由docker0改为em2(外网网卡)</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-2.png" alt="k-2"></p>
<p>dashboard访问地址  <a href="http://172.16.31.130/" target="_blank" rel="external">http://172.16.31.130/</a> </p>
<p>username admin </p>
<p>password 99cloud</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-3.png" alt="k-3"></p>
<h1 id="后续测试"><a href="#后续测试" class="headerlink" title="后续测试"></a>后续测试</h1><p>1）上传镜像cirros </p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-4.png" alt="k-4"></p>
<p>2）创建flavor </p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-5.png" alt="k-5"></p>
<p>3）创建一个vxlan网络 </p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-6.png" alt="k-6"></p>
<p>4）创建一个外部网络 </p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-7.png" alt="k-7"></p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-8.png" alt="k-8"></p>
<p>5）添加路由router1，可以让内部网络连接到外网</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-9.png" alt="k-9"></p>
<p>6）启动2个实例，其中给test1添加浮动IP </p>
<p>如果实例无法启动的话进行如下修改（物理机环境不会出现这个情况） </p>
<p>问题描述： </p>
<p>VMware虚拟机作为OpenStack计算节点，如果安装的操作系统是CentOS7.3，则在此计算节点放置的虚拟机无法正常启动，报如下错误： </p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-10.png" alt="k-10"></p>
<p>在创建计算节点时，为了能让 KVM 能创建嵌套的虚机，要把 CPU 的虚拟化功能打开。如下图在 VMWare 中设置以下 CPU 的模式。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-11.png" alt="k-11"></p>
<p>用以下命令确认 CPU 支持虚拟化。 </p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-12.png" alt="k-12"></p>
<p>nova的配置如下：</p>
<pre><code>/etc/nova/nova.conf
[libvirt]
virt_type = kvm
</code></pre><p>已经验证，如果计算节点安装的是CentOS7.2或Ubuntu操作系统，则不会报上面的错误。</p>
<p>解决方案： </p>
<p>修改nova的配置：</p>
<pre><code>/etc/nova/nova.conf
[libvirt]
virt_type = qemu
cpu_mode = none
</code></pre><p>重启 nova-compute即可。</p>
<p>就算CPU支持虚拟化，也得设置 virt_type = qemu ，否则还是报错。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-13.png" alt="k-13"></p>
<p>7) 默认安全组添加两条规则，支持外部ping通内部、ssh登陆内部 </p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-14.png" alt="k-14"></p>
<p>8）ping测试</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-15.png" alt="k-15"></p>
<p>虚拟机之间可以互相通信</p>
<p>绑定浮动ip后ping外网ip</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/k-16.png" alt="k-16"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;陈沙克老师发布了一个kolla的Ocata的ISO,这个ISO把所有需要的软件及Docker镜像都集成起来，安装应该非常方便，所以决定试一试。&lt;/p&gt;
&lt;p&gt;首先我在一台16g的戴尔服务器上面安装这个iso，配置2块网卡，一块为em1(隧道网络，网段为192.168.0.0
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://yjscloud.com/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack技能" scheme="http://yjscloud.com/tags/OpenStack%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack排错（一）：Cinder僵尸卷删除</title>
    <link href="http://yjscloud.com/2018/04/12/OpenStack%E6%8E%92%E9%94%99-%E4%B8%80-cinder%E5%83%B5%E5%B0%B8%E5%8D%B7%E5%88%A0%E9%99%A4/"/>
    <id>http://yjscloud.com/2018/04/12/OpenStack排错-一-cinder僵尸卷删除/</id>
    <published>2018-04-12T12:14:21.000Z</published>
    <updated>2018-05-17T15:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理报错的大致思路"><a href="#处理报错的大致思路" class="headerlink" title="处理报错的大致思路"></a>处理报错的大致思路</h1><p>(1)到数据库cinder表中找到volumes，将其中对应要删除的卷的状态由error_deleting改为deleted；</p>
<p>(2)针对lvm，可以用命令lvdisplay列出所有卷的信息，如果现在应用命令lvremove来删除相应的卷，则会提示要删除的卷正在使用中，所以我们使用命令lsof查看相应卷所占用的进程，然后kill这个进程；</p>
<p>(3)应用命令lvremove来删除相应的卷；</p>
<p>(4)此时问题貌似已经解决，因为已经可以正确地执行cinder中命令，要删除的卷的记录也已经删除。但是这里还有个问题，默认的建立卷的最大数目为10，如果之前删除的僵尸卷的数目为1，但是此时当你建立卷的数目为9个时，再尝试建立新卷时，就会提示已经达到卷的数目的最大值。解决方法就是到cinder数据表中找到quota_usages，将其中in_use中的数据减少相应的删除的僵尸卷的数目即可。</p>
<p>备注：fuser命令在psmisc包中</p>
<h1 id="第一种情况的僵尸卷"><a href="#第一种情况的僵尸卷" class="headerlink" title="第一种情况的僵尸卷"></a>第一种情况的僵尸卷</h1><p><img src="http://oxysobnip.bkt.clouddn.com/err-1.png" alt="err-1"></p>
<p><img src="http://oxysobnip.bkt.clouddn.com/err-2.png" alt="err-2"></p>
<p><img src="http://oxysobnip.bkt.clouddn.com/err-3.png" alt="err-3"></p>
<p><img src="http://oxysobnip.bkt.clouddn.com/err-4.png" alt="err-4"></p>
<p>执行完上面的操作后进入云平台系统，更改需要删除云硬盘状态为“可用配额”，然后“删除云硬盘”，如果再界面上删除依旧没有执行成功或者依旧一直再删除中，就采用比较暴力的方式，修改云硬盘再数据库中的状态，因为此时云硬盘再存储设备（物理机）上已经删除了，仅仅还有数据库中还有该记录信息，但不能直接删除这条记录，数据库有外键依赖，而是要把cinder盘的deleted改成“1”,“1”即为删除，0为不删除。</p>
<p>进入数据库：</p>
<pre><code>mysql -uxxxx -pxxxx
</code></pre><p>选择数据库表：</p>
<pre><code>use cinder;
</code></pre><p>关闭数据库的键外查询：</p>
<pre><code>set foreign_key_checks=0;
</code></pre><p>select找到出错的数据：</p>
<pre><code>select id, status, display_name from volumes where id=&quot;af3e36ce-10ab-4daa-80e3-b71f16836a3b&quot;
</code></pre><p>修改数据库记录状体：</p>
<pre><code>update volumes set deleted=1 where id=&quot;af3e36ce-10ab-4daa-80e3-b71f16836a3b&quot;
</code></pre><p>操作完成后开启数据库的键外查询：</p>
<pre><code>set foreign_key_checks=0;
</code></pre><p>此时如果dashboard界面卷存储还没有恢复正常就需要进行如下操作！！！</p>
<p>（1）use cinder;</p>
<p>（2）select  *  from volumes;</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/err-5.png" alt="err-5"></p>
<p>在删除数据条目之前要临时关闭键值检查，否则删除操作无法进行：set foreign_key_checks=0;</p>
<p>删除操作完成后再运行此命令开启键值检查，确保数据库安全</p>
<p>找到之前出问题的卷并删除条目信息：</p>
<pre><code>delete from volumes where id=&apos;f0a030a6-7ff0-4765-ac47-1f1eed3c7582&apos;;
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/err-6.png" alt="err-6"></p>
<p>然后把in_use的数值修改为0即可</p>
<p>这里我就很暴力了直接删除了了条目：</p>
<pre><code>delete from quota_usages where project_id=&apos;232b14de024647159470ed97873ce774&apos;;
</code></pre><p>等下新建卷的时候就会恢复的，不建议这么做哦。</p>
<h1 id="第二种情况的僵尸卷"><a href="#第二种情况的僵尸卷" class="headerlink" title="第二种情况的僵尸卷"></a>第二种情况的僵尸卷</h1><p>思路和第一中情况差不多；</p>
<p>（1）通过lvdisplay |grep查询cinder对应的卷地址。</p>
<pre><code>root@compute:~# lvdisplay | grep &quot;8580f464-02e1-411c-bd94-a4af35e499a3&quot;
LV Path                /dev/cinder-volumes/volume-8580f464-02e1-411c-bd94-a4af35e499a3
LV Name                volume-8580f464-02e1-411c-bd94-a4af35e499a3
</code></pre><p>（2）通过lsof | grep查询占用cinder卷的端口</p>
<pre><code>lsof| grep &quot;8580f464-02e1-411c-bd94-a4af35e499a3&quot;
kill -9 76568
</code></pre><p>（3）通过lvremove删除相应的卷</p>
<pre><code>lvremove /dev/cinder-volumes/volume-8580f464-02e1-411c-bd94-a4af35e499a3
</code></pre><p>（4）报错处理<br>报错：device-mapper: remove ioctl on failed: Deviceor resource busy。设备繁忙</p>
<p>查看是否被打开：</p>
<pre><code>dmsetup info -c /dev/cinder-volumes/volume-8580f464-02e1-411c-bd94-a4af35e499a3 #查看是否被打开,如果看到open为4或者数字说明它被打开了，所以remove不掉。
</code></pre><p>查看被谁打开：</p>
<pre><code>fuser -m /dev/cinder-volumes/volume-8580f464-02e1-411c-bd94-a4af35e499a3 #查看是谁打开的，显示产用进程号
</code></pre><p>把占用设备的进程杀掉：</p>
<pre><code>kill -9 xxxx xxxx xxxx xxxx
</code></pre><p>重新执行上面验证的几个步骤，验证是否还有进程占用，如果看到open为0，表示现在没有进程占用，再执行lvremove删除相应的卷</p>
<p>（5）验证是否已经删除</p>
<pre><code>root@compute:~# lvdisplay | grep &quot;8580f464-02e1-411c-bd94-a4af35e499a3&quot;
</code></pre><p>（6）进入云平台系统，更改需要删除云硬盘状态为“可用配额”，然后“删除云硬盘”，如果再界面上删除依旧没有执行成功或者依旧一直再删除中，就采用比较暴力的方式，修改云硬盘再数据库中的状态，因为此时云硬盘再存储设备（物理机）上已经删除了，仅仅还有数据库中还有该记录信息，但不能直接删除这条记录，数据库有外键依赖，而是要把cinder盘的deleted改成“1”,“1”即为删除，0为不删除。</p>
<p>进入数据库：</p>
<pre><code>mysql -uxxxx -pxxxx
</code></pre><p>选择数据库表</p>
<pre><code>use cinder;
</code></pre><p>select找到出错的数据:</p>
<pre><code>select id, status, display_name from volumes where id=&apos;2d5d206d-0720-42aa-b178-3f3238177583&apos;;
</code></pre><p>修改数据库记录状体：</p>
<pre><code>update volumes set deleted=1 where id=&apos;2d5d206d-0720-42aa-b178-3f3238177583&apos;;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;处理报错的大致思路&quot;&gt;&lt;a href=&quot;#处理报错的大致思路&quot; class=&quot;headerlink&quot; title=&quot;处理报错的大致思路&quot;&gt;&lt;/a&gt;处理报错的大致思路&lt;/h1&gt;&lt;p&gt;(1)到数据库cinder表中找到volumes，将其中对应要删除的卷的状态由err
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://yjscloud.com/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack技能" scheme="http://yjscloud.com/tags/OpenStack%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>制作OpenStack镜像模板</title>
    <link href="http://yjscloud.com/2018/04/04/%E5%88%B6%E4%BD%9Copenstack%E9%95%9C%E5%83%8F%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yjscloud.com/2018/04/04/制作openstack镜像模板/</id>
    <published>2018-04-04T11:57:11.000Z</published>
    <updated>2018-05-17T15:43:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在kvm服务器上安装一个虚拟机，然后进行如下配置：</p>
<h1 id="模板默认配置"><a href="#模板默认配置" class="headerlink" title="模板默认配置"></a>模板默认配置</h1><p>制作模版要配置yum源，安装常用软件，yum源可以配置为阿里的源，163的源最好有自己的源<br>需要安装的常用软件：</p>
<pre><code>yum install net-tools wget vim ntpdate bash-completion -y
</code></pre><h1 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h1><p>删除网卡配置文件中的UUID，网卡设为DHCP（如果内网有DHCP服务器）</p>
<p>（1）网卡配置文件一般如下</p>
<pre><code>TYPE=Ethernet
DEVICE=eth0
ONBOOT=yes
BOOTPROTO=dhcp
NM_CONTROLLED=no
</code></pre><p>（2）centos6需要执行rm -rf /etc/udev/rules.d/70-persistent-net.rules（centos7不用）</p>
<p>（3）vim /etc/sysconfig/network<br>    添加如下内容：</p>
<pre><code>NOZERCONF=yes
</code></pre><p>NOZERCONF=yes的意思是禁用ZERCONF路由，ZERCONF又被叫做IPv4 Link-Local和Automatic Private IP Addressing。它是一个动态配置协议，系统可以通过它来连接到网络。很多linux发行版本都默认安装该服务，当系统无法连接DHCP server的时候，就会尝试通过ZERCONF来获取IP，一般这个IP地址段为169.254.0.0，我们在做openstack镜像的时候，这个需要禁用，因为VM如果DHCP获取不到IP就让它获取不到，别让它获取其他IP段的地址，所以这里我们禁用。</p>
<h1 id="安装cloud服务"><a href="#安装cloud服务" class="headerlink" title="安装cloud服务"></a>安装cloud服务</h1><pre><code>yum -y install cloud-utils cloud-init parted
</code></pre><h1 id="编辑cloud的配置文件"><a href="#编辑cloud的配置文件" class="headerlink" title="编辑cloud的配置文件"></a>编辑cloud的配置文件</h1><pre><code>vim /etc/cloud/cloud.cfg    
修改如下内容：
ssh_pwauth:    1
在cloud_init_modules:下面添加一个参数                                                                                          - resolv-conf
</code></pre><h1 id="配置脚本文件"><a href="#配置脚本文件" class="headerlink" title="配置脚本文件"></a>配置脚本文件</h1><pre><code>vim /etc/rc.d/rc.local
覆盖配置这个脚本（Netron配置文件）
chmod +x /etc/rc.d/rc.local
systemctl enable cloud-config.service cloud-final.service cloud-init-local.service cloud-init.service
</code></pre><p>最后重启系统</p>
<pre><code>reboot
</code></pre><h1 id="尝试运行命令检查服务"><a href="#尝试运行命令检查服务" class="headerlink" title="尝试运行命令检查服务"></a>尝试运行命令检查服务</h1><pre><code>systemctl list-dependencies
</code></pre><p>出现四个（cloud-）开头的服务且是绿色的就说明cloud-init安装成功</p>
<h1 id="关机和压缩"><a href="#关机和压缩" class="headerlink" title="关机和压缩"></a>关机和压缩</h1><p>找到刚才创建的镜像压缩一下</p>
<p>这里我们进入cd /opt目录压缩（ps：不能在镜像目录下压缩）</p>
<pre><code>virt-sparsify --compress /var/lib/libvirt/images/CentOS7.1 CentOS7.1.qcow2
</code></pre><p>原大小是2.5g压缩后是500mb左右（特别费时间）</p>
<pre><code>du -sh CentOS7.1.qcow2    #查看镜像大小
</code></pre><h1 id="安装windows模版"><a href="#安装windows模版" class="headerlink" title="安装windows模版"></a>安装windows模版</h1><p>安装windows的步骤就不再赘述</p>
<p>需要注意的两点是：</p>
<p>网卡选择 virtio模式</p>
<p>usb模式选择Hypervisor default </p>
<p>然后配置一下远程桌面</p>
<p>安装cloud-init（版本为0.99.dev26）,安装步骤较为简单不再赘述</p>
<p>要设置用户下一次登陆要修改密码，这是为了安全着想。</p>
<p>最后对cloud Initialization service Properties服务属性设置为 local system account</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在kvm服务器上安装一个虚拟机，然后进行如下配置：&lt;/p&gt;
&lt;h1 id=&quot;模板默认配置&quot;&gt;&lt;a href=&quot;#模板默认配置&quot; class=&quot;headerlink&quot; title=&quot;模板默认配置&quot;&gt;&lt;/a&gt;模板默认配置&lt;/h1&gt;&lt;p&gt;制作模版要配置yum源，安装常用软件，yu
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://yjscloud.com/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack技能" scheme="http://yjscloud.com/tags/OpenStack%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack O版搭建（四）：Cinder节点部署</title>
    <link href="http://yjscloud.com/2018/03/25/OpenStack-O%E7%89%88%E6%90%AD%E5%BB%BA%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ACinder%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2/"/>
    <id>http://yjscloud.com/2018/03/25/OpenStack-O版搭建（四）：Cinder节点部署/</id>
    <published>2018-03-25T14:28:38.000Z</published>
    <updated>2018-03-25T14:58:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在controller节点上配置"><a href="#在controller节点上配置" class="headerlink" title="在controller节点上配置"></a>在controller节点上配置</h1><h2 id="创建数据库用户并赋予权限"><a href="#创建数据库用户并赋予权限" class="headerlink" title="创建数据库用户并赋予权限"></a>创建数据库用户并赋予权限</h2><pre><code>CREATE DATABASE cinder;
GRANT ALL PRIVILEGES ON cinder.* TO &apos;cinder&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON cinder.* TO &apos;cinder&apos;@&apos;%&apos; IDENTIFIED BY &apos;devops&apos;;
</code></pre><h2 id="创建cinder用户并赋予admin权限"><a href="#创建cinder用户并赋予admin权限" class="headerlink" title="创建cinder用户并赋予admin权限"></a>创建cinder用户并赋予admin权限</h2><pre><code>source /root/admin-openrc
openstack user create --domain default cinder --password devops
openstack role add --project service --user cinder admin
</code></pre><h2 id="创建volume服务"><a href="#创建volume服务" class="headerlink" title="创建volume服务"></a>创建volume服务</h2><pre><code>openstack service create --name cinder --description &quot;OpenStack Block Storage&quot; volume
openstack service create --name cinderv2 --description &quot;OpenStack Block Storage&quot; volumev2
</code></pre><h2 id="创建endpoint"><a href="#创建endpoint" class="headerlink" title="创建endpoint"></a>创建endpoint</h2><pre><code>openstack endpoint create --region RegionOne volume public http://controller:8776/v1/%\(tenant_id\)s
openstack endpoint create --region RegionOne volume internal http://controller:8776/v1/%\(tenant_id\)s
openstack endpoint create --region RegionOne volume admin http://controller:8776/v1/%\(tenant_id\)s
openstack endpoint create --region RegionOne volumev2 public http://controller:8776/v2/%\(tenant_id\)s
openstack endpoint create --region RegionOne volumev2 internal http://controller:8776/v2/%\(tenant_id\)s
openstack endpoint create --region RegionOne volumev2 admin http://controller:8776/v2/%\(tenant_id\)s
</code></pre><h2 id="安装cinder相关服务"><a href="#安装cinder相关服务" class="headerlink" title="安装cinder相关服务"></a>安装cinder相关服务</h2><pre><code>yum install openstack-cinder -y
</code></pre><h2 id="配置cinder配置文件"><a href="#配置cinder配置文件" class="headerlink" title="配置cinder配置文件"></a>配置cinder配置文件</h2><pre><code>cp /etc/cinder/cinder.conf /etc/cinder/cinder.conf.bak
&gt;/etc/cinder/cinder.conf
openstack-config --set /etc/cinder/cinder.conf DEFAULT transport_url rabbit://openstack:devops@controller
openstack-config --set /etc/cinder/cinder.conf DEFAULT my_ip 10.1.1.120
openstack-config --set /etc/cinder/cinder.conf DEFAULT auth_strategy keystone
openstack-config --set /etc/cinder/cinder.conf database connection mysql+pymysql://cinder:devops@controller/cinder
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken auth_uri http://controller:5000
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken auth_url http://controller:35357
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken memcached_servers controller:11211
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken auth_type password
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken project_domain_name default
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken user_domain_name default
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken project_name service
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken username cinder
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken password devops
openstack-config --set /etc/cinder/cinder.conf oslo_concurrency lock_path /var/lib/cinder/tmp
</code></pre><h2 id="同步数据库"><a href="#同步数据库" class="headerlink" title="同步数据库"></a>同步数据库</h2><pre><code>su -s /bin/sh -c &quot;cinder-manage db sync&quot; cinder
</code></pre><h2 id="在controller上启动cinder服务，并设置开机启动"><a href="#在controller上启动cinder服务，并设置开机启动" class="headerlink" title="在controller上启动cinder服务，并设置开机启动"></a>在controller上启动cinder服务，并设置开机启动</h2><pre><code>systemctl enable openstack-cinder-api.service openstack-cinder-scheduler.service
systemctl restart openstack-cinder-api.service openstack-cinder-scheduler.service
systemctl status openstack-cinder-api.service openstack-cinder-scheduler.service
</code></pre><h1 id="在cinder节点上配置"><a href="#在cinder节点上配置" class="headerlink" title="在cinder节点上配置"></a>在cinder节点上配置</h1><p>Cinder节点这里我们需要额外的添加一个硬盘（/dev/sdb)用作cinder的存储服务 (注意！这一步是在cinder节点操作的）</p>
<pre><code>yum install lvm2 -y
</code></pre><p>启动服务并设置为开机自启 (注意！这一步是在cinder节点操作的）</p>
<pre><code>systemctl enable lvm2-lvmetad.service
systemctl start lvm2-lvmetad.service
systemctl status lvm2-lvmetad.service
</code></pre><p>创建lvm, 这里的/dev/sdb就是额外添加的硬盘 (注意！这一步是在cinder节点操作的）</p>
<pre><code>fdisk -l
pvcreate /dev/vdb
vgcreate cinder-volumes /dev/vdb
</code></pre><p>编辑存储节点lvm.conf文件 (注意！这一步是在cinder节点操作的）</p>
<pre><code>vim /etc/lvm/lvm.conf
</code></pre><p>在devices 下面添加 filter = [ “a/vda/“, “a/vdb/“, “r/.*/“] ，130行 </p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-25.png" alt="o-25"></p>
<p>然后重启下lvm2服务：</p>
<pre><code>systemctl restart lvm2-lvmetad.service
systemctl status lvm2-lvmetad.service
</code></pre><p>安装openstack-cinder、targetcli (注意！这一步是在cinder节点操作的）</p>
<pre><code>yum install openstack-cinder openstack-utils targetcli python-keystone ntpdate -y
</code></pre><p>配置cinder配置文件 (注意！这一步是在cinder节点操作的）</p>
<pre><code>cp /etc/cinder/cinder.conf /etc/cinder/cinder.conf.bak
&gt;/etc/cinder/cinder.conf
openstack-config --set /etc/cinder/cinder.conf DEFAULT auth_strategy keystone
openstack-config --set /etc/cinder/cinder.conf DEFAULT my_ip 10.1.1.122
openstack-config --set /etc/cinder/cinder.conf DEFAULT enabled_backends lvm
openstack-config --set /etc/cinder/cinder.conf DEFAULT glance_api_servers http://controller:9292
openstack-config --set /etc/cinder/cinder.conf DEFAULT glance_api_version 2
openstack-config --set /etc/cinder/cinder.conf DEFAULT enable_v1_api True
openstack-config --set /etc/cinder/cinder.conf DEFAULT enable_v2_api True
openstack-config --set /etc/cinder/cinder.conf DEFAULT enable_v3_api True
openstack-config --set /etc/cinder/cinder.conf DEFAULT storage_availability_zone nova
openstack-config --set /etc/cinder/cinder.conf DEFAULT default_availability_zone nova
openstack-config --set /etc/cinder/cinder.conf DEFAULT os_region_name RegionOne
openstack-config --set /etc/cinder/cinder.conf DEFAULT api_paste_config /etc/cinder/api-paste.ini
openstack-config --set /etc/cinder/cinder.conf DEFAULT transport_url rabbit://openstack:devops@controller
openstack-config --set /etc/cinder/cinder.conf database connection mysql+pymysql://cinder:devops@controller/cinder
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken auth_uri http://controller:5000
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken auth_url http://controller:35357
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken memcached_servers controller:11211
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken auth_type password
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken project_domain_name default
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken user_domain_name default
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken project_name service
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken username cinder
openstack-config --set /etc/cinder/cinder.conf keystone_authtoken password devops
openstack-config --set /etc/cinder/cinder.conf lvm volume_driver cinder.volume.drivers.lvm.LVMVolumeDriver
openstack-config --set /etc/cinder/cinder.conf lvm volume_group cinder-volumes
openstack-config --set /etc/cinder/cinder.conf lvm iscsi_protocol iscsi
openstack-config --set /etc/cinder/cinder.conf lvm iscsi_helper lioadm
openstack-config --set /etc/cinder/cinder.conf oslo_concurrency lock_path /var/lib/cinder/tmp
</code></pre><p>启动openstack-cinder-volume和target并设置开机启动 (注意！这一步是在cinder节点操作的）</p>
<pre><code>systemctl enable openstack-cinder-volume.service target.service
systemctl restart openstack-cinder-volume.service target.service
systemctl status openstack-cinder-volume.service target.service
</code></pre><p>验证cinder服务是否正常</p>
<pre><code>source /root/admin-openrc
cinder service-list
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-26.png" alt="o-26"></p>
<p>至此手动搭建openstack ocata分布式集群完成部署（ps：适用于实验和教学环境，企业还需修改更多参数）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;在controller节点上配置&quot;&gt;&lt;a href=&quot;#在controller节点上配置&quot; class=&quot;headerlink&quot; title=&quot;在controller节点上配置&quot;&gt;&lt;/a&gt;在controller节点上配置&lt;/h1&gt;&lt;h2 id=&quot;创建数据库用户并赋
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://yjscloud.com/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack O版搭建" scheme="http://yjscloud.com/tags/OpenStack-O%E7%89%88%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack O版搭建（三）：Compute节点部署</title>
    <link href="http://yjscloud.com/2018/03/25/OpenStack-O%E7%89%88%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ACompute%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2/"/>
    <id>http://yjscloud.com/2018/03/25/OpenStack-O版搭建（三）：Compute节点部署/</id>
    <published>2018-03-25T14:16:51.000Z</published>
    <updated>2018-03-25T15:00:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装相关依赖包"><a href="#安装相关依赖包" class="headerlink" title="安装相关依赖包"></a>安装相关依赖包</h1><pre><code>yum install openstack-selinux python-openstackclient yum-plugin-priorities openstack-nova-compute openstack-utils ntpdate -y
</code></pre><h2 id="配置nova-conf"><a href="#配置nova-conf" class="headerlink" title="配置nova.conf"></a>配置nova.conf</h2><pre><code>cp /etc/nova/nova.conf /etc/nova/nova.conf.bak
&gt;/etc/nova/nova.conf
openstack-config --set /etc/nova/nova.conf DEFAULT auth_strategy keystone
openstack-config --set /etc/nova/nova.conf DEFAULT my_ip 10.1.1.121
openstack-config --set /etc/nova/nova.conf DEFAULT use_neutron True
openstack-config --set /etc/nova/nova.conf DEFAULT firewall_driver nova.virt.firewall.NoopFirewallDriver
openstack-config --set /etc/nova/nova.conf DEFAULT transport_url rabbit://openstack:devops@controller
openstack-config --set /etc/nova/nova.conf keystone_authtoken auth_uri http://controller:5000
openstack-config --set /etc/nova/nova.conf keystone_authtoken auth_url http://controller:35357
openstack-config --set /etc/nova/nova.conf keystone_authtoken memcached_servers controller:11211
openstack-config --set /etc/nova/nova.conf keystone_authtoken auth_type password
openstack-config --set /etc/nova/nova.conf keystone_authtoken project_domain_name default
openstack-config --set /etc/nova/nova.conf keystone_authtoken user_domain_name default
openstack-config --set /etc/nova/nova.conf keystone_authtoken project_name service
openstack-config --set /etc/nova/nova.conf keystone_authtoken username nova
openstack-config --set /etc/nova/nova.conf keystone_authtoken password devops
openstack-config --set /etc/nova/nova.conf placement auth_uri http://controller:5000
openstack-config --set /etc/nova/nova.conf placement auth_url http://controller:35357
openstack-config --set /etc/nova/nova.conf placement memcached_servers controller:11211
openstack-config --set /etc/nova/nova.conf placement auth_type password
openstack-config --set /etc/nova/nova.conf placement project_domain_name default
openstack-config --set /etc/nova/nova.conf placement user_domain_name default
openstack-config --set /etc/nova/nova.conf placement project_name service
openstack-config --set /etc/nova/nova.conf placement username placement
openstack-config --set /etc/nova/nova.conf placement password devops
openstack-config --set /etc/nova/nova.conf placement os_region_name RegionOne
openstack-config --set /etc/nova/nova.conf vnc enabled True
openstack-config --set /etc/nova/nova.conf vnc keymap en-us
openstack-config --set /etc/nova/nova.conf vnc vncserver_listen 0.0.0.0
openstack-config --set /etc/nova/nova.conf vnc vncserver_proxyclient_address 10.1.1.121
openstack-config --set /etc/nova/nova.conf vnc novncproxy_base_url http://192.168.0.120:6080/vnc_auto.html
openstack-config --set /etc/nova/nova.conf glance api_servers http://controller:9292
openstack-config --set /etc/nova/nova.conf oslo_concurrency lock_path /var/lib/nova/tmp
openstack-config --set /etc/nova/nova.conf libvirt virt_type qemu
</code></pre><h2 id="设置libvirtd-service-和openstack-nova-compute-service开机启动"><a href="#设置libvirtd-service-和openstack-nova-compute-service开机启动" class="headerlink" title="设置libvirtd.service 和openstack-nova-compute.service开机启动"></a>设置libvirtd.service 和openstack-nova-compute.service开机启动</h2><pre><code>systemctl enable libvirtd.service openstack-nova-compute.service
systemctl restart libvirtd.service openstack-nova-compute.service
systemctl status libvirtd.service openstack-nova-compute.service
</code></pre><h2 id="到controller上执行验证"><a href="#到controller上执行验证" class="headerlink" title="到controller上执行验证"></a>到controller上执行验证</h2><pre><code>source /root/admin-openrc
openstack compute service list
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-23.png" alt="o-23">    </p>
<h1 id="安装Neutron"><a href="#安装Neutron" class="headerlink" title="安装Neutron"></a>安装Neutron</h1><h2 id="安装相关软件包"><a href="#安装相关软件包" class="headerlink" title="安装相关软件包"></a>安装相关软件包</h2><pre><code>yum install openstack-neutron-linuxbridge ebtables ipset -y
</code></pre><h2 id="配置neutron-conf"><a href="#配置neutron-conf" class="headerlink" title="配置neutron.conf"></a>配置neutron.conf</h2><pre><code>cp /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak
&gt;/etc/neutron/neutron.conf
openstack-config --set /etc/neutron/neutron.conf DEFAULT auth_strategy keystone
openstack-config --set /etc/neutron/neutron.conf DEFAULT advertise_mtu True
openstack-config --set /etc/neutron/neutron.conf DEFAULT dhcp_agents_per_network 2
openstack-config --set /etc/neutron/neutron.conf DEFAULT control_exchange neutron
openstack-config --set /etc/neutron/neutron.conf DEFAULT nova_url http://controller:8774/v2
openstack-config --set /etc/neutron/neutron.conf DEFAULT transport_url rabbit://openstack:devops@controller
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken auth_uri http://controller:5000
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken auth_url http://controller:35357
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken memcached_servers controller:11211
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken auth_type password
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken project_domain_name default
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken user_domain_name default
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken project_name service
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken username neutron
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken password devops
openstack-config --set /etc/neutron/neutron.conf oslo_concurrency lock_path /var/lib/neutron/tmp
</code></pre><h2 id="配置-etc-neutron-plugins-ml2-linuxbridge-agent-ini"><a href="#配置-etc-neutron-plugins-ml2-linuxbridge-agent-ini" class="headerlink" title="配置/etc/neutron/plugins/ml2/linuxbridge_agent.ini"></a>配置/etc/neutron/plugins/ml2/linuxbridge_agent.ini</h2><pre><code>openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan enable_vxlan True
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan local_ip 10.2.2.121
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan l2_population True
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup enable_security_group True
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup firewall_driver neutron.agent.linux.iptables_firewall.IptablesFirewallDriver
</code></pre><h2 id="配置nova-conf-1"><a href="#配置nova-conf-1" class="headerlink" title="配置nova.conf"></a>配置nova.conf</h2><pre><code>openstack-config --set /etc/nova/nova.conf neutron url http://controller:9696
openstack-config --set /etc/nova/nova.conf neutron auth_url http://controller:35357
openstack-config --set /etc/nova/nova.conf neutron auth_type password
openstack-config --set /etc/nova/nova.conf neutron project_domain_name default
openstack-config --set /etc/nova/nova.conf neutron user_domain_name default
openstack-config --set /etc/nova/nova.conf neutron region_name RegionOne
openstack-config --set /etc/nova/nova.conf neutron project_name service
openstack-config --set /etc/nova/nova.conf neutron username neutron
openstack-config --set /etc/nova/nova.conf neutron password devops
</code></pre><h2 id="重启和enable相关服务"><a href="#重启和enable相关服务" class="headerlink" title="重启和enable相关服务"></a>重启和enable相关服务</h2><pre><code>systemctl restart libvirtd.service openstack-nova-compute.service
systemctl enable neutron-linuxbridge-agent.service
systemctl restart neutron-linuxbridge-agent.service
systemctl status libvirtd.service openstack-nova-compute.service neutron-linuxbridge-agent.service
</code></pre><h1 id="计算节点结合Cinder"><a href="#计算节点结合Cinder" class="headerlink" title="计算节点结合Cinder"></a>计算节点结合Cinder</h1><p>1）计算节点要是想用cinder,那么需要配置nova配置文件 (注意！这一步是在计算节点操作的）</p>
<pre><code>openstack-config --set /etc/nova/nova.conf cinder os_region_name RegionOne
systemctl restart openstack-nova-compute.service
</code></pre><p>2）然后在controller上重启nova服务</p>
<pre><code>systemctl restart openstack-nova-api.service
systemctl status openstack-nova-api.service
</code></pre><h1 id="在controler上执行验证"><a href="#在controler上执行验证" class="headerlink" title="在controler上执行验证"></a>在controler上执行验证</h1><pre><code>source /root/admin-openrc
neutron agent-list
nova-manage cell_v2 discover_hosts
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-24.png" alt="o-24"></p>
<p>到此，Compute节点搭建完毕，运行nova host-list可以查看新加入的compute1节点<br>如果需要再添加另外一个compute节点，只要重复下第二大部即可，记得把计算机名和IP地址改下。</p>
<p>附-创建配额命令</p>
<pre><code>openstack flavor create m1.tiny --id 1 --ram 512 --disk 1 --vcpus 1
openstack flavor create m1.small --id 2 --ram 2048 --disk 20 --vcpus 1
openstack flavor create m1.medium --id 3 --ram 4096 --disk 40 --vcpus 2
openstack flavor create m1.large --id 4 --ram 8192 --disk 80 --vcpus 4
openstack flavor create m1.xlarge --id 5 --ram 16384 --disk 160 --vcpus 8
openstack flavor list
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装相关依赖包&quot;&gt;&lt;a href=&quot;#安装相关依赖包&quot; class=&quot;headerlink&quot; title=&quot;安装相关依赖包&quot;&gt;&lt;/a&gt;安装相关依赖包&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;yum install openstack-selinux python-opens
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://yjscloud.com/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack O版搭建" scheme="http://yjscloud.com/tags/OpenStack-O%E7%89%88%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack O版搭建（二）：Controller节点部署</title>
    <link href="http://yjscloud.com/2018/03/25/OpenStack-O%E7%89%88%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AController%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2/"/>
    <id>http://yjscloud.com/2018/03/25/OpenStack-O版搭建（二）：Controller节点部署/</id>
    <published>2018-03-25T14:15:37.000Z</published>
    <updated>2018-03-25T22:55:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Mariadb和RabbitMQ"><a href="#安装Mariadb和RabbitMQ" class="headerlink" title="安装Mariadb和RabbitMQ"></a>安装Mariadb和RabbitMQ</h1><h2 id="搭建Mariadb"><a href="#搭建Mariadb" class="headerlink" title="搭建Mariadb"></a>搭建Mariadb</h2><h3 id="安装mariadb数据库"><a href="#安装mariadb数据库" class="headerlink" title="安装mariadb数据库"></a>安装mariadb数据库</h3><pre><code>yum install -y MariaDB-server MariaDB-client
</code></pre><h3 id="配置mariadb"><a href="#配置mariadb" class="headerlink" title="配置mariadb"></a>配置mariadb</h3><pre><code>vim /etc/my.cnf.d/mariadb-openstack.cnf
</code></pre><p>在mysqld区块添加如下内容：</p>
<pre><code>[mysqld]
default-storage-engine = innodb
innodb_file_per_table
collation-server = utf8_general_ci
init-connect = &apos;SET NAMES utf8&apos;
character-set-server = utf8
bind-address = 10.1.1.120
</code></pre><h3 id="启动数据库及设置mariadb开机启动"><a href="#启动数据库及设置mariadb开机启动" class="headerlink" title="启动数据库及设置mariadb开机启动"></a>启动数据库及设置mariadb开机启动</h3><pre><code>systemctl enable mariadb.service
systemctl restart mariadb.service
systemctl status mariadb.service
systemctl list-unit-files |grep mariadb.service
</code></pre><h3 id="配置mariadb，给mariadb设置密码"><a href="#配置mariadb，给mariadb设置密码" class="headerlink" title="配置mariadb，给mariadb设置密码"></a>配置mariadb，给mariadb设置密码</h3><pre><code>mysql_secure_installation
</code></pre><p>先按回车，然后按Y，设置mysql密码，然后一直按y结束<br>这里我们设置的密码是devops</p>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><h3 id="安装erlang"><a href="#安装erlang" class="headerlink" title="安装erlang"></a>安装erlang</h3><pre><code>yum install -y erlang
</code></pre><h3 id="安装RabbitMQ-1"><a href="#安装RabbitMQ-1" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h3><pre><code>yum install -y rabbitmq-server
</code></pre><h3 id="启动rabbitmq及设置开机启动"><a href="#启动rabbitmq及设置开机启动" class="headerlink" title="启动rabbitmq及设置开机启动"></a>启动rabbitmq及设置开机启动</h3><pre><code>systemctl enable rabbitmq-server.service
systemctl restart rabbitmq-server.service
systemctl status rabbitmq-server.service
systemctl list-unit-files |grep rabbitmq-server.service
</code></pre><h3 id="创建openstack用户"><a href="#创建openstack用户" class="headerlink" title="创建openstack用户"></a>创建openstack用户</h3><p>注意将密码替换为自己的合适密码，这里密码都是devops</p>
<pre><code>rabbitmqctl add_user openstack devops
</code></pre><h3 id="将openstack用户赋予权限"><a href="#将openstack用户赋予权限" class="headerlink" title="将openstack用户赋予权限"></a>将openstack用户赋予权限</h3><pre><code>rabbitmqctl set_permissions openstack &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
rabbitmqctl set_user_tags openstack administrator
rabbitmqctl list_users
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-3.png" alt="o-3">    </p>
<h3 id="查看监听端口"><a href="#查看监听端口" class="headerlink" title="查看监听端口"></a>查看监听端口</h3><p>rabbitmq用的是5672端口</p>
<pre><code>netstat -ntlp |grep 5672
</code></pre><h3 id="查看RabbitMQ插件"><a href="#查看RabbitMQ插件" class="headerlink" title="查看RabbitMQ插件"></a>查看RabbitMQ插件</h3><pre><code>/usr/lib/rabbitmq/bin/rabbitmq-plugins list
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-4.png" alt="o-4"></p>
<h3 id="打开RabbitMQ相关插件"><a href="#打开RabbitMQ相关插件" class="headerlink" title="打开RabbitMQ相关插件"></a>打开RabbitMQ相关插件</h3><pre><code>/usr/lib/rabbitmq/bin/rabbitmq-plugins enable rabbitmq_management mochiweb webmachine rabbitmq_web_dispatch amqp_client rabbitmq_management_agent
</code></pre><p>打开相关插件后，重启下rabbitmq服务</p>
<pre><code>systemctl restart rabbitmq-server
</code></pre><p>浏览器输入：<a href="http://192.168.0.120:15672" target="_blank" rel="external">http://192.168.0.120:15672</a> 默认用户名密码：guest/guest,<br>通过这个界面，我们能很直观的看到rabbitmq的运行和负载情况</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-5.png" alt="o-5"></p>
<h1 id="安装配置keystone"><a href="#安装配置keystone" class="headerlink" title="安装配置keystone"></a>安装配置keystone</h1><h2 id="创建keystone数据库"><a href="#创建keystone数据库" class="headerlink" title="创建keystone数据库"></a>创建keystone数据库</h2><pre><code>CREATE DATABASE keystone;
</code></pre><h2 id="创建数据库keystone用户-amp-root用户及赋予权限"><a href="#创建数据库keystone用户-amp-root用户及赋予权限" class="headerlink" title="创建数据库keystone用户&amp;root用户及赋予权限"></a>创建数据库keystone用户&amp;root用户及赋予权限</h2><pre><code>GRANT ALL PRIVILEGES ON keystone.* TO &apos;keystone&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON keystone.* TO &apos;keystone&apos;@&apos;%&apos; IDENTIFIED BY &apos;devops&apos;;
</code></pre><p>注意将devops替换为自己的数据库密码</p>
<h2 id="安装keystone和memcached"><a href="#安装keystone和memcached" class="headerlink" title="安装keystone和memcached"></a>安装keystone和memcached</h2><pre><code>yum -y install openstack-keystone httpd mod_wsgi python-openstackclient memcached python-memcached openstack-utils
</code></pre><h2 id="启动memcache服务并设置开机自启动"><a href="#启动memcache服务并设置开机自启动" class="headerlink" title="启动memcache服务并设置开机自启动"></a>启动memcache服务并设置开机自启动</h2><pre><code>systemctl enable memcached.service
systemctl restart memcached.service
systemctl status memcached.service
</code></pre><h2 id="配置-etc-keystone-keystone-conf文件"><a href="#配置-etc-keystone-keystone-conf文件" class="headerlink" title="配置/etc/keystone/keystone.conf文件"></a>配置/etc/keystone/keystone.conf文件</h2><pre><code>cp /etc/keystone/keystone.conf /etc/keystone/keystone.conf.bak
&gt;/etc/keystone/keystone.conf
openstack-config --set /etc/keystone/keystone.conf DEFAULT transport_url rabbit://openstack:devops@controller
openstack-config --set /etc/keystone/keystone.conf database connection mysql://keystone:devops@controller/keystone
openstack-config --set /etc/keystone/keystone.conf cache backend oslo_cache.memcache_pool
openstack-config --set /etc/keystone/keystone.conf cache enabled true
openstack-config --set /etc/keystone/keystone.conf cache memcache_servers controller:11211
openstack-config --set /etc/keystone/keystone.conf memcache servers controller:11211
openstack-config --set /etc/keystone/keystone.conf token expiration 3600
openstack-config --set /etc/keystone/keystone.conf token provider fernet
</code></pre><h2 id="配置httpd-conf文件-amp-memcached文件"><a href="#配置httpd-conf文件-amp-memcached文件" class="headerlink" title="配置httpd.conf文件&amp;memcached文件"></a>配置httpd.conf文件&amp;memcached文件</h2><pre><code>sed -i &quot;s/#ServerName www.example.com:80/ServerName controller/&quot; /etc/httpd/conf/httpd.conf
sed -i &apos;s/OPTIONS*.*/OPTIONS=&quot;-l 127.0.0.1,::1,10.1.1.120&quot;/&apos; /etc/sysconfig/memcached
</code></pre><h2 id="配置keystone与httpd结合"><a href="#配置keystone与httpd结合" class="headerlink" title="配置keystone与httpd结合"></a>配置keystone与httpd结合</h2><pre><code>ln -s /usr/share/keystone/wsgi-keystone.conf /etc/httpd/conf.d/
</code></pre><h2 id="数据库同步"><a href="#数据库同步" class="headerlink" title="数据库同步"></a>数据库同步</h2><pre><code>su -s /bin/sh -c &quot;keystone-manage db_sync&quot; keystone
</code></pre><h2 id="初始化fernet"><a href="#初始化fernet" class="headerlink" title="初始化fernet"></a>初始化fernet</h2><pre><code>keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone
keystone-manage credential_setup --keystone-user keystone --keystone-group keystone
</code></pre><h2 id="启动httpd，并设置httpd开机启动"><a href="#启动httpd，并设置httpd开机启动" class="headerlink" title="启动httpd，并设置httpd开机启动"></a>启动httpd，并设置httpd开机启动</h2><pre><code>systemctl enable httpd.service
systemctl restart httpd.service
systemctl status httpd.service
systemctl list-unit-files |grep httpd.service
</code></pre><h2 id="创建admin用户角色"><a href="#创建admin用户角色" class="headerlink" title="创建admin用户角色"></a>创建admin用户角色</h2><pre><code>keystone-manage bootstrap \
--bootstrap-password devops \
--bootstrap-username admin \
--bootstrap-project-name admin \
--bootstrap-role-name admin \
--bootstrap-service-name keystone \
--bootstrap-region-id RegionOne \
--bootstrap-admin-url http://controller:35357/v3 \
--bootstrap-internal-url http://controller:35357/v3 \
--bootstrap-public-url http://controller:5000/v3
</code></pre><p>验证：</p>
<pre><code>openstack project list --os-username admin --os-project-name admin --os-user-domain-id default --os-project-domain-id default --os-identity-api-version 3 --os-auth-url http://controller:5000 --os-password devops
</code></pre><p>返回如下结果说明你的keystone服务就没有问题了</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-6.png" alt="o-6"></p>
<h2 id="创建admin用户环境变量"><a href="#创建admin用户环境变量" class="headerlink" title="创建admin用户环境变量"></a>创建admin用户环境变量</h2><p>创建/root/admin-openrc 文件并写入如下内容：</p>
<pre><code>vim /root/admin-openrc
</code></pre><p>添加以下内容：</p>
<pre><code>export OS_USER_DOMAIN_ID=default
export OS_PROJECT_DOMAIN_ID=default
export OS_USERNAME=admin
export OS_PROJECT_NAME=admin
export OS_PASSWORD=devops
export OS_IDENTITY_API_VERSION=3
export OS_IMAGE_API_VERSION=2
export OS_AUTH_URL=http://controller:35357/v3
</code></pre><h2 id="创建service项目"><a href="#创建service项目" class="headerlink" title="创建service项目"></a>创建service项目</h2><pre><code>source /root/admin-openrc
openstack project create --domain default --description &quot;Service Project&quot; service
</code></pre><h2 id="创建demo项目"><a href="#创建demo项目" class="headerlink" title="创建demo项目"></a>创建demo项目</h2><pre><code>openstack project create --domain default --description &quot;Demo Project&quot; demo
</code></pre><h2 id="创建demo用户"><a href="#创建demo用户" class="headerlink" title="创建demo用户"></a>创建demo用户</h2><pre><code>openstack user create --domain default demo --password devops
</code></pre><p>注意：devops为demo用户密码</p>
<h2 id="创建user角色"><a href="#创建user角色" class="headerlink" title="创建user角色"></a>创建user角色</h2><p>创建user角色将demo用户赋予user角色</p>
<pre><code>openstack role create user
openstack role add --project demo --user demo user
</code></pre><h2 id="验证keystone"><a href="#验证keystone" class="headerlink" title="验证keystone"></a>验证keystone</h2><pre><code>unset OS_TOKEN OS_URL
openstack --os-auth-url http://controller:35357/v3 --os-project-domain-name default --os-user-domain-name default --os-project-name admin --os-username admin token issue --os-password devops
openstack --os-auth-url http://controller:5000/v3 --os-project-domain-name default --os-user-domain-name default --os-project-name demo --os-username demo token issue --os-password devops
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-7.png" alt="o-7"></p>
<h1 id="安装配置glance"><a href="#安装配置glance" class="headerlink" title="安装配置glance"></a>安装配置glance</h1><h2 id="创建glance数据库"><a href="#创建glance数据库" class="headerlink" title="创建glance数据库"></a>创建glance数据库</h2><pre><code>CREATE DATABASE glance;
</code></pre><h2 id="创建数据库用户并赋予权限"><a href="#创建数据库用户并赋予权限" class="headerlink" title="创建数据库用户并赋予权限"></a>创建数据库用户并赋予权限</h2><pre><code>GRANT ALL PRIVILEGES ON glance.* TO &apos;glance&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON glance.* TO &apos;glance&apos;@&apos;%&apos; IDENTIFIED BY &apos;devops&apos;;
</code></pre><h2 id="创建glance用户及赋予admin权限"><a href="#创建glance用户及赋予admin权限" class="headerlink" title="创建glance用户及赋予admin权限"></a>创建glance用户及赋予admin权限</h2><pre><code>source /root/admin-openrc
openstack user create --domain default glance --password devops
openstack role add --project service --user glance admin
</code></pre><h2 id="创建image服务"><a href="#创建image服务" class="headerlink" title="创建image服务"></a>创建image服务</h2><pre><code>openstack service create --name glance --description &quot;OpenStack Image service&quot; image
</code></pre><h2 id="创建glance的endpoint"><a href="#创建glance的endpoint" class="headerlink" title="创建glance的endpoint"></a>创建glance的endpoint</h2><pre><code>openstack endpoint create --region RegionOne image public http://controller:9292
openstack endpoint create --region RegionOne image internal http://controller:9292
openstack endpoint create --region RegionOne image admin http://controller:9292
</code></pre><h2 id="安装glance相关rpm包"><a href="#安装glance相关rpm包" class="headerlink" title="安装glance相关rpm包"></a>安装glance相关rpm包</h2><pre><code>yum install openstack-glance -y
</code></pre><h2 id="修改glance配置文件-etc-glance-glance-api-conf"><a href="#修改glance配置文件-etc-glance-glance-api-conf" class="headerlink" title="修改glance配置文件/etc/glance/glance-api.conf"></a>修改glance配置文件/etc/glance/glance-api.conf</h2><p>注意将devops的密码设置成你自己的</p>
<pre><code>cp /etc/glance/glance-api.conf /etc/glance/glance-api.conf.bak
&gt;/etc/glance/glance-api.conf
openstack-config --set /etc/glance/glance-api.conf DEFAULT transport_url rabbit://openstack:devops@controller
openstack-config --set /etc/glance/glance-api.conf database connection mysql+pymysql://glance:devops@controller/glance
openstack-config --set /etc/glance/glance-api.conf keystone_authtoken auth_uri http://controller:5000
openstack-config --set /etc/glance/glance-api.conf keystone_authtoken auth_url http://controller:35357
openstack-config --set /etc/glance/glance-api.conf keystone_authtoken memcached_servers controller:11211
openstack-config --set /etc/glance/glance-api.conf keystone_authtoken auth_type password
openstack-config --set /etc/glance/glance-api.conf keystone_authtoken project_domain_name default
openstack-config --set /etc/glance/glance-api.conf keystone_authtoken user_domain_name default
openstack-config --set /etc/glance/glance-api.conf keystone_authtoken username glance
openstack-config --set /etc/glance/glance-api.conf keystone_authtoken password devops
openstack-config --set /etc/glance/glance-api.conf keystone_authtoken project_name service
openstack-config --set /etc/glance/glance-api.conf paste_deploy flavor keystone
openstack-config --set /etc/glance/glance-api.conf glance_store stores file,http
openstack-config --set /etc/glance/glance-api.conf glance_store default_store file
openstack-config --set /etc/glance/glance-api.conf glance_store filesystem_store_datadir /var/lib/glance/images/
</code></pre><h2 id="修改glance配置文件-etc-glance-glance-registry-conf："><a href="#修改glance配置文件-etc-glance-glance-registry-conf：" class="headerlink" title="修改glance配置文件/etc/glance/glance-registry.conf："></a>修改glance配置文件/etc/glance/glance-registry.conf：</h2><pre><code>cp /etc/glance/glance-registry.conf /etc/glance/glance-registry.conf.bak
&gt;/etc/glance/glance-registry.conf
openstack-config --set /etc/glance/glance-registry.conf DEFAULT transport_url rabbit://openstack:devops@controller
openstack-config --set /etc/glance/glance-registry.conf database connection mysql+pymysql://glance:devops@controller/glance
openstack-config --set /etc/glance/glance-registry.conf keystone_authtoken auth_uri http://controller:5000
openstack-config --set /etc/glance/glance-registry.conf keystone_authtoken auth_url http://controller:35357
openstack-config --set /etc/glance/glance-registry.conf keystone_authtoken memcached_servers controller:11211
openstack-config --set /etc/glance/glance-registry.conf keystone_authtoken auth_type password
openstack-config --set /etc/glance/glance-registry.conf keystone_authtoken project_domain_name default
openstack-config --set /etc/glance/glance-registry.conf keystone_authtoken user_domain_name default
openstack-config --set /etc/glance/glance-registry.conf keystone_authtoken project_name service
openstack-config --set /etc/glance/glance-registry.conf keystone_authtoken username glance
openstack-config --set /etc/glance/glance-registry.conf keystone_authtoken password devops
openstack-config --set /etc/glance/glance-registry.conf paste_deploy flavor keystone
</code></pre><h2 id="同步glance数据库"><a href="#同步glance数据库" class="headerlink" title="同步glance数据库"></a>同步glance数据库</h2><pre><code>su -s /bin/sh -c &quot;glance-manage db_sync&quot; glance
</code></pre><p>同步成功</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-8.png" alt="o-8"></p>
<h2 id="启动glance及设置开机启动"><a href="#启动glance及设置开机启动" class="headerlink" title="启动glance及设置开机启动"></a>启动glance及设置开机启动</h2><pre><code>systemctl enable openstack-glance-api.service openstack-glance-registry.service
systemctl restart openstack-glance-api.service openstack-glance-registry.service
systemctl status openstack-glance-api.service openstack-glance-registry.service
</code></pre><h2 id="下载测试镜像文件"><a href="#下载测试镜像文件" class="headerlink" title="下载测试镜像文件"></a>下载测试镜像文件</h2><pre><code>wget http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img
</code></pre><h2 id="上传镜像到glance"><a href="#上传镜像到glance" class="headerlink" title="上传镜像到glance"></a>上传镜像到glance</h2><pre><code>source /root/admin-openrc
glance image-create --name &quot;cirros-0.3.4-x86_64&quot; --file cirros-0.3.4-x86_64-disk.img --disk-format qcow2 --container-format bare --visibility public --progress
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-9.png" alt="o-9"></p>
<p>如果你做好了一个CentOS7.2系统的镜像，也可以用这命令操作，例：</p>
<pre><code>glance image-create --name &quot;CentOS7.2-x86_64&quot; --file CentOS_7.2.qcow2 --disk-format qcow2 --container-format bare --visibility public --progress
</code></pre><p>查看镜像列表：</p>
<pre><code>glance image-list
</code></pre><h1 id="安装配置nova"><a href="#安装配置nova" class="headerlink" title="安装配置nova"></a>安装配置nova</h1><h2 id="创建nova数据库"><a href="#创建nova数据库" class="headerlink" title="创建nova数据库"></a>创建nova数据库</h2><pre><code>CREATE DATABASE nova;
CREATE DATABASE nova_api;
CREATE DATABASE nova_cell0;
</code></pre><h2 id="创建数据库用户并赋予权限-1"><a href="#创建数据库用户并赋予权限-1" class="headerlink" title="创建数据库用户并赋予权限"></a>创建数据库用户并赋予权限</h2><pre><code>GRANT ALL PRIVILEGES ON nova.* TO &apos;nova&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON nova.* TO &apos;nova&apos;@&apos;%&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON nova_api.* TO &apos;nova&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON nova_api.* TO &apos;nova&apos;@&apos;%&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON nova_cell0.* TO &apos;nova&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON nova_cell0.* TO &apos;nova&apos;@&apos;%&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;controller&apos; IDENTIFIED BY &apos;devops&apos;;
FLUSH PRIVILEGES;
</code></pre><p>注：查看授权列表信息 SELECT DISTINCT CONCAT(‘User: ‘’’,user,’’’@’’’,host,’’’;’) AS query FROM mysql.user;<br>取消之前某个授权 REVOKE ALTER ON *.* TO ‘root’@’controller’ IDENTIFIED BY ‘devops’;</p>
<h2 id="创建nova用户及赋予admin权限"><a href="#创建nova用户及赋予admin权限" class="headerlink" title="创建nova用户及赋予admin权限"></a>创建nova用户及赋予admin权限</h2><pre><code>source /root/admin-openrc
openstack user create --domain default nova --password devops
openstack role add --project service --user nova admin
</code></pre><h2 id="创建computer服务"><a href="#创建computer服务" class="headerlink" title="创建computer服务"></a>创建computer服务</h2><pre><code>openstack service create --name nova --description &quot;OpenStack Compute&quot; compute
</code></pre><h2 id="创建nova的endpoint"><a href="#创建nova的endpoint" class="headerlink" title="创建nova的endpoint"></a>创建nova的endpoint</h2><pre><code>openstack endpoint create --region RegionOne compute public http://controller:8774/v2.1/%\(tenant_id\)s
openstack endpoint create --region RegionOne compute internal http://controller:8774/v2.1/%\(tenant_id\)s
openstack endpoint create --region RegionOne compute admin http://controller:8774/v2.1/%\(tenant_id\)s
</code></pre><h2 id="安装nova相关软件"><a href="#安装nova相关软件" class="headerlink" title="安装nova相关软件"></a>安装nova相关软件</h2><pre><code>yum install -y openstack-nova-api openstack-nova-conductor openstack-nova-cert openstack-nova-console openstack-nova-novncproxy openstack-nova-scheduler
</code></pre><h2 id="配置nova的配置文件-etc-nova-nova-conf"><a href="#配置nova的配置文件-etc-nova-nova-conf" class="headerlink" title="配置nova的配置文件/etc/nova/nova.conf"></a>配置nova的配置文件/etc/nova/nova.conf</h2><pre><code>cp /etc/nova/nova.conf /etc/nova/nova.conf.bak
&gt;/etc/nova/nova.conf
openstack-config --set /etc/nova/nova.conf DEFAULT enabled_apis osapi_compute,metadata
openstack-config --set /etc/nova/nova.conf DEFAULT auth_strategy keystone
openstack-config --set /etc/nova/nova.conf DEFAULT my_ip 10.1.1.120
openstack-config --set /etc/nova/nova.conf DEFAULT use_neutron True
openstack-config --set /etc/nova/nova.conf DEFAULT firewall_driver nova.virt.firewall.NoopFirewallDriver
openstack-config --set /etc/nova/nova.conf DEFAULT transport_url rabbit://openstack:devops@controller
openstack-config --set /etc/nova/nova.conf database connection mysql+pymysql://nova:devops@controller/nova
openstack-config --set /etc/nova/nova.conf api_database connection mysql+pymysql://nova:devops@controller/nova_api
openstack-config --set /etc/nova/nova.conf scheduler discover_hosts_in_cells_interval -1
openstack-config --set /etc/nova/nova.conf keystone_authtoken auth_uri http://controller:5000
openstack-config --set /etc/nova/nova.conf keystone_authtoken auth_url http://controller:35357
openstack-config --set /etc/nova/nova.conf keystone_authtoken memcached_servers controller:11211
openstack-config --set /etc/nova/nova.conf keystone_authtoken auth_type password
openstack-config --set /etc/nova/nova.conf keystone_authtoken project_domain_name default
openstack-config --set /etc/nova/nova.conf keystone_authtoken user_domain_name default
openstack-config --set /etc/nova/nova.conf keystone_authtoken project_name service
openstack-config --set /etc/nova/nova.conf keystone_authtoken username nova
openstack-config --set /etc/nova/nova.conf keystone_authtoken password devops
openstack-config --set /etc/nova/nova.conf keystone_authtoken service_token_roles_required True
openstack-config --set /etc/nova/nova.conf vnc vncserver_listen 10.1.1.120
openstack-config --set /etc/nova/nova.conf vnc vncserver_proxyclient_address 10.1.1.120
openstack-config --set /etc/nova/nova.conf glance api_servers http://controller:9292
openstack-config --set /etc/nova/nova.conf oslo_concurrency lock_path /var/lib/nova/tmp
</code></pre><p>注意：其他节点上记得替换IP，还有密码。</p>
<h2 id="设置cell（单元格）"><a href="#设置cell（单元格）" class="headerlink" title="设置cell（单元格）"></a>设置cell（单元格）</h2><p>关于cell（单元格）的介绍，引用出自于九州云分享的《Ocata组件Nova Cell V2 详解》&amp; 有云的《引入Cells功能最核心要解决的问题就是OpenStack集群的扩展性》两篇文章的整合介绍：<br>OpenStack 在控制平面上的性能瓶颈主要在 Message Queue 和 Database 。尤其是 Message Queue , 随着计算节点的增加，性能变的越来越差，因为openstack里每个资源和接口都是通过消息队列来通信的，有测试表明，当集群规模到了200，一个消息可能要在十几秒后才会响应；为了应对这种情况，引入Cells功能以解决OpenStack集群的扩展性。</p>
<p>同步下nova数据库</p>
<pre><code>su -s /bin/sh -c &quot;nova-manage api_db sync&quot; nova
su -s /bin/sh -c &quot;nova-manage db sync&quot; nova
</code></pre><p>不用管这个报警</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-10.png" alt="o-10"></p>
<p>设置cell_v2关联上创建好的数据库nova_cell0</p>
<pre><code>nova-manage cell_v2 map_cell0 --database_connection mysql+pymysql://root:devops@controller/nova_cell0
</code></pre><p>创建一个常规cell，名字叫cell1，这个单元格里面将会包含计算节点</p>
<pre><code>nova-manage cell_v2 create_cell --verbose --name cell1 --database_connection mysql+pymysql://root:devops@controller/nova_cell0 --transport-url rabbit://openstack:devops@controller:5672/
</code></pre><p>检查部署是否正常</p>
<pre><code>nova-status upgrade check
</code></pre><p>如有报错请先运行下面的命令<br>创建和映射cell0，并将现有计算主机和实例映射到单元格中</p>
<pre><code>nova-manage cell_v2 simple_cell_setup
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-11.png" alt="o-11"></p>
<p>查看已经创建好的单元格列表</p>
<pre><code>nova-manage cell_v2 list_cells --verbose
</code></pre><p>注意，如果有新添加的计算节点，需要运行下面命令来发现，并且添加到单元格中</p>
<pre><code>nova-manage cell_v2 discover_hosts
</code></pre><p>当然，你可以在控制节点的nova.conf文件里[scheduler]模块下添加discover_hosts_in_cells_interval=-1 这个设置来自动发现</p>
<h2 id="安装placement"><a href="#安装placement" class="headerlink" title="安装placement"></a>安装placement</h2><p>从Ocata开始，需要安装配置placement参与nova调度了，不然虚拟机将无法创建！</p>
<pre><code>yum install -y openstack-nova-placement-api
</code></pre><p>创建placement用户和placement 服务</p>
<pre><code>openstack user create --domain default placement --password devops
openstack role add --project service --user placement admin
openstack service create --name placement --description &quot;OpenStack Placement&quot; placement
</code></pre><p>创建placement endpoint</p>
<pre><code>openstack endpoint create --region RegionOne placement public http://controller:8778
openstack endpoint create --region RegionOne placement admin http://controller:8778
openstack endpoint create --region RegionOne placement internal http://controller:8778
</code></pre><p>把placement 整合到nova.conf里</p>
<pre><code>openstack-config --set /etc/nova/nova.conf placement auth_url http://controller:35357
openstack-config --set /etc/nova/nova.conf placement memcached_servers controller:11211
openstack-config --set /etc/nova/nova.conf placement auth_type password
openstack-config --set /etc/nova/nova.conf placement project_domain_name default
openstack-config --set /etc/nova/nova.conf placement user_domain_name default
openstack-config --set /etc/nova/nova.conf placement project_name service
openstack-config --set /etc/nova/nova.conf placement username placement
openstack-config --set /etc/nova/nova.conf placement password devops
openstack-config --set /etc/nova/nova.conf placement os_region_name RegionOne
</code></pre><p>配置修改00-nova-placement-api.conf文件，这步没做创建虚拟机的时候会出现禁止访问资源的问题</p>
<pre><code>cd /etc/httpd/conf.d/
cp 00-nova-placement-api.conf 00-nova-placement-api.conf.bak
&gt;00-nova-placement-api.conf
vim 00-nova-placement-api.conf
</code></pre><p>添加以下内容：</p>
<pre><code>Listen 8778

&lt;VirtualHost *:8778&gt;
WSGIProcessGroup nova-placement-api
WSGIApplicationGroup %{GLOBAL}
WSGIPassAuthorization On
WSGIDaemonProcess nova-placement-api processes=3 threads=1 user=nova group=nova
WSGIScriptAlias / /usr/bin/nova-placement-api
&lt;Directory &quot;/&quot;&gt;
    Order allow,deny
    Allow from all
    Require all granted
&lt;/Directory&gt;
&lt;IfVersion &gt;= 2.4&gt;
  ErrorLogFormat &quot;%M&quot;
&lt;/IfVersion&gt;
  ErrorLog /var/log/nova/nova-placement-api.log
&lt;/VirtualHost&gt;

Alias /nova-placement-api /usr/bin/nova-placement-api
&lt;Location /nova-placement-api&gt;
  SetHandler wsgi-script
  Options +ExecCGI
  WSGIProcessGroup nova-placement-api
  WSGIApplicationGroup %{GLOBAL}
  WSGIPassAuthorization On
&lt;/Location&gt;
</code></pre><p>重启下httpd服务</p>
<pre><code>systemctl restart httpd
</code></pre><p>检查下是否配置成功</p>
<pre><code>nova-status upgrade check
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-11.png" alt="o-12"></p>
<h2 id="设置nova相关服务开机启动"><a href="#设置nova相关服务开机启动" class="headerlink" title="设置nova相关服务开机启动"></a>设置nova相关服务开机启动</h2><pre><code>systemctl enable openstack-nova-api.service openstack-nova-cert.service     openstack-nova-consoleauth.service openstack-nova-scheduler.service     openstack-nova-conductor.service openstack-nova-novncproxy.service
</code></pre><p>启动nova服务：</p>
<pre><code>systemctl restart openstack-nova-api.service openstack-nova-cert.service openstack-nova-consoleauth.service openstack-nova-scheduler.service openstack-nova-conductor.service openstack-nova-novncproxy.service
</code></pre><p>查看nova服务：</p>
<pre><code>systemctl status openstack-nova-api.service openstack-nova-cert.service openstack-nova-consoleauth.service openstack-nova-scheduler.service openstack-nova-conductor.service openstack-nova-novncproxy.service

systemctl list-unit-files |grep openstack-nova-*
</code></pre><h2 id="验证nova服务"><a href="#验证nova服务" class="headerlink" title="验证nova服务"></a>验证nova服务</h2><pre><code>unset OS_TOKEN OS_URL
source /root/admin-openrc
nova service-list
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-13.png" alt="o-13"></p>
<p>openstack endpoint list 查看endpoint list<br>看是否有结果正确输出</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-14.png" alt="o-14"></p>
<h1 id="安装配置neutron"><a href="#安装配置neutron" class="headerlink" title="安装配置neutron"></a>安装配置neutron</h1><h2 id="创建neutron数据库"><a href="#创建neutron数据库" class="headerlink" title="创建neutron数据库"></a>创建neutron数据库</h2><pre><code>CREATE DATABASE neutron;
</code></pre><h2 id="创建数据库用户并赋予权限-2"><a href="#创建数据库用户并赋予权限-2" class="headerlink" title="创建数据库用户并赋予权限"></a>创建数据库用户并赋予权限</h2><pre><code>GRANT ALL PRIVILEGES ON neutron.* TO &apos;neutron&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;devops&apos;;
GRANT ALL PRIVILEGES ON neutron.* TO &apos;neutron&apos;@&apos;%&apos; IDENTIFIED BY &apos;devops&apos;;
</code></pre><h2 id="创建neutron用户及赋予admin权限"><a href="#创建neutron用户及赋予admin权限" class="headerlink" title="创建neutron用户及赋予admin权限"></a>创建neutron用户及赋予admin权限</h2><pre><code>source /root/admin-openrc
openstack user create --domain default neutron --password devops
openstack role add --project service --user neutron admin
</code></pre><h2 id="创建network服务"><a href="#创建network服务" class="headerlink" title="创建network服务"></a>创建network服务</h2><pre><code>openstack service create --name neutron --description &quot;OpenStack Networking&quot; network
</code></pre><h2 id="创建endpoint"><a href="#创建endpoint" class="headerlink" title="创建endpoint"></a>创建endpoint</h2><pre><code>openstack endpoint create --region RegionOne network public http://controller:9696
openstack endpoint create --region RegionOne network internal http://controller:9696
openstack endpoint create --region RegionOne network admin http://controller:9696
</code></pre><h2 id="安装neutron相关软件"><a href="#安装neutron相关软件" class="headerlink" title="安装neutron相关软件"></a>安装neutron相关软件</h2><pre><code>yum install openstack-neutron openstack-neutron-ml2 openstack-neutron-linuxbridge ebtables -y
</code></pre><h2 id="配置neutron配置文件-etc-neutron-neutron-conf"><a href="#配置neutron配置文件-etc-neutron-neutron-conf" class="headerlink" title="配置neutron配置文件/etc/neutron/neutron.conf"></a>配置neutron配置文件/etc/neutron/neutron.conf</h2><pre><code>cp /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak
&gt;/etc/neutron/neutron.conf
openstack-config --set /etc/neutron/neutron.conf DEFAULT core_plugin ml2
openstack-config --set /etc/neutron/neutron.conf DEFAULT service_plugins router
openstack-config --set /etc/neutron/neutron.conf DEFAULT allow_overlapping_ips True
openstack-config --set /etc/neutron/neutron.conf DEFAULT auth_strategy keystone
openstack-config --set /etc/neutron/neutron.conf DEFAULT transport_url rabbit://openstack:devops@controller
openstack-config --set /etc/neutron/neutron.conf DEFAULT notify_nova_on_port_status_changes True
openstack-config --set /etc/neutron/neutron.conf DEFAULT notify_nova_on_port_data_changes True
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken auth_uri http://controller:5000
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken auth_url http://controller:35357
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken memcached_servers controller:11211
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken auth_type password
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken project_domain_name default
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken user_domain_name default
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken project_name service
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken username neutron
openstack-config --set /etc/neutron/neutron.conf keystone_authtoken password devops
openstack-config --set /etc/neutron/neutron.conf database connection mysql+pymysql://neutron:devops@controller/neutron
openstack-config --set /etc/neutron/neutron.conf nova auth_url http://controller:35357
openstack-config --set /etc/neutron/neutron.conf nova auth_type password
openstack-config --set /etc/neutron/neutron.conf nova project_domain_name default
openstack-config --set /etc/neutron/neutron.conf nova user_domain_name default
openstack-config --set /etc/neutron/neutron.conf nova region_name RegionOne
openstack-config --set /etc/neutron/neutron.conf nova project_name service
openstack-config --set /etc/neutron/neutron.conf nova username nova
openstack-config --set /etc/neutron/neutron.conf nova password devops
openstack-config --set /etc/neutron/neutron.conf oslo_concurrency lock_path /var/lib/neutron/tmp
</code></pre><h2 id="配置-etc-neutron-plugins-ml2-ml2-conf-ini"><a href="#配置-etc-neutron-plugins-ml2-ml2-conf-ini" class="headerlink" title="配置/etc/neutron/plugins/ml2/ml2_conf.ini"></a>配置/etc/neutron/plugins/ml2/ml2_conf.ini</h2><pre><code>openstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 type_drivers flat,vlan,vxlan
openstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 mechanism_drivers linuxbridge,l2population
openstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 extension_drivers port_security
openstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 tenant_network_types vxlan
openstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2 path_mtu 1500
openstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2_type_flat flat_networks provider
openstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini ml2_type_vxlan vni_ranges 1:1000
openstack-config --set /etc/neutron/plugins/ml2/ml2_conf.ini securitygroup enable_ipset True
</code></pre><h2 id="配置-etc-neutron-plugins-ml2-linuxbridge-agent-ini"><a href="#配置-etc-neutron-plugins-ml2-linuxbridge-agent-ini" class="headerlink" title="配置/etc/neutron/plugins/ml2/linuxbridge_agent.ini"></a>配置/etc/neutron/plugins/ml2/linuxbridge_agent.ini</h2><pre><code>openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini DEFAULT debug false
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini linux_bridge physical_interface_mappings provider:eth0
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan enable_vxlan True
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan local_ip 10.2.2.120
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini vxlan l2_population True
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini agent prevent_arp_spoofing True
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup enable_security_group True
openstack-config --set /etc/neutron/plugins/ml2/linuxbridge_agent.ini securitygroup firewall_driver neutron.agent.linux.iptables_firewall.IptablesFirewallDriver
</code></pre><ul>
<li>注意eth0是外网网卡，一般这里写的网卡名都是能访问外网的，如果不是外网网卡，那么VM就会与外界网络隔离。local_ip 定义的是隧道网络，vxLan下 vm-linuxbridge-&gt;vxlan ——tun—–vxlan-&gt;linuxbridge-vm</li>
</ul>
<h2 id="配置-etc-neutron-l3-agent-ini"><a href="#配置-etc-neutron-l3-agent-ini" class="headerlink" title="配置 /etc/neutron/l3_agent.ini"></a>配置 /etc/neutron/l3_agent.ini</h2><pre><code>openstack-config --set /etc/neutron/l3_agent.ini DEFAULT interface_driver neutron.agent.linux.interface.BridgeInterfaceDriver
openstack-config --set /etc/neutron/l3_agent.ini DEFAULT external_network_bridge
openstack-config --set /etc/neutron/l3_agent.ini DEFAULT debug false
</code></pre><h2 id="配置-etc-neutron-dhcp-agent-ini"><a href="#配置-etc-neutron-dhcp-agent-ini" class="headerlink" title="配置/etc/neutron/dhcp_agent.ini"></a>配置/etc/neutron/dhcp_agent.ini</h2><pre><code>openstack-config --set /etc/neutron/dhcp_agent.ini DEFAULT interface_driver neutron.agent.linux.interface.BridgeInterfaceDriver
openstack-config --set /etc/neutron/dhcp_agent.ini DEFAULT dhcp_driver neutron.agent.linux.dhcp.Dnsmasq
openstack-config --set /etc/neutron/dhcp_agent.ini DEFAULT enable_isolated_metadata True
openstack-config --set /etc/neutron/dhcp_agent.ini DEFAULT verbose True
openstack-config --set /etc/neutron/dhcp_agent.ini DEFAULT debug false
</code></pre><h2 id="重新配置-etc-nova-nova-conf"><a href="#重新配置-etc-nova-nova-conf" class="headerlink" title="重新配置/etc/nova/nova.conf"></a>重新配置/etc/nova/nova.conf</h2><p>配置这步的目的是让compute节点能使用上neutron网络</p>
<pre><code>openstack-config --set /etc/nova/nova.conf neutron url http://controller:9696
openstack-config --set /etc/nova/nova.conf neutron auth_url http://controller:35357
openstack-config --set /etc/nova/nova.conf neutron auth_plugin password
openstack-config --set /etc/nova/nova.conf neutron project_domain_id default
openstack-config --set /etc/nova/nova.conf neutron user_domain_id default
openstack-config --set /etc/nova/nova.conf neutron region_name RegionOne
openstack-config --set /etc/nova/nova.conf neutron project_name service
openstack-config --set /etc/nova/nova.conf neutron username neutron
openstack-config --set /etc/nova/nova.conf neutron password devops
openstack-config --set /etc/nova/nova.conf neutron service_metadata_proxy True
openstack-config --set /etc/nova/nova.conf neutron metadata_proxy_shared_secret devops
</code></pre><h2 id="dnsmasq-neutron-conf配置"><a href="#dnsmasq-neutron-conf配置" class="headerlink" title="dnsmasq-neutron.conf配置"></a>dnsmasq-neutron.conf配置</h2><p>echo “dhcp-option-force=26,1450” &gt;/etc/neutron/dnsmasq-neutron.conf</p>
<h2 id="配置-etc-neutron-metadata-agent-ini"><a href="#配置-etc-neutron-metadata-agent-ini" class="headerlink" title="配置/etc/neutron/metadata_agent.ini"></a>配置/etc/neutron/metadata_agent.ini</h2><pre><code>openstack-config --set /etc/neutron/metadata_agent.ini DEFAULT nova_metadata_ip controller
openstack-config --set /etc/neutron/metadata_agent.ini DEFAULT metadata_proxy_shared_secret devops
openstack-config --set /etc/neutron/metadata_agent.ini DEFAULT metadata_workers 4
openstack-config --set /etc/neutron/metadata_agent.ini DEFAULT verbose True
openstack-config --set /etc/neutron/metadata_agent.ini DEFAULT debug false
openstack-config --set /etc/neutron/metadata_agent.ini DEFAULT nova_metadata_protocol http
</code></pre><h2 id="创建硬链接"><a href="#创建硬链接" class="headerlink" title="创建硬链接"></a>创建硬链接</h2><pre><code>ln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini
</code></pre><h2 id="同步数据库"><a href="#同步数据库" class="headerlink" title="同步数据库"></a>同步数据库</h2><pre><code>su -s /bin/sh -c &quot;neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head&quot; neutron
</code></pre><h2 id="重启nova服务，因为刚才改了nova-conf"><a href="#重启nova服务，因为刚才改了nova-conf" class="headerlink" title="重启nova服务，因为刚才改了nova.conf"></a>重启nova服务，因为刚才改了nova.conf</h2><pre><code>systemctl restart openstack-nova-api.service
systemctl status openstack-nova-api.service
</code></pre><h2 id="重启neutron服务并设置开机启动"><a href="#重启neutron服务并设置开机启动" class="headerlink" title="重启neutron服务并设置开机启动"></a>重启neutron服务并设置开机启动</h2><pre><code>systemctl enable neutron-server.service neutron-linuxbridge-agent.service neutron-dhcp-agent.service neutron-metadata-agent.service
systemctl restart neutron-server.service neutron-linuxbridge-agent.service neutron-dhcp-agent.service neutron-metadata-agent.service
systemctl status neutron-server.service neutron-linuxbridge-agent.service neutron-dhcp-agent.service neutron-metadata-agent.service
</code></pre><h2 id="启动neutron-l3-agent-service并设置开机启动"><a href="#启动neutron-l3-agent-service并设置开机启动" class="headerlink" title="启动neutron-l3-agent.service并设置开机启动"></a>启动neutron-l3-agent.service并设置开机启动</h2><pre><code>systemctl enable neutron-l3-agent.service
systemctl restart neutron-l3-agent.service
systemctl status neutron-l3-agent.service
</code></pre><h2 id="执行验证"><a href="#执行验证" class="headerlink" title="执行验证"></a>执行验证</h2><pre><code>source /root/admin-openrc
neutron ext-list
neutron agent-list
</code></pre><h2 id="创建vxLan模式网络，让虚拟机能外出"><a href="#创建vxLan模式网络，让虚拟机能外出" class="headerlink" title="创建vxLan模式网络，让虚拟机能外出"></a>创建vxLan模式网络，让虚拟机能外出</h2><p>a）首先先执行环境变量</p>
<pre><code>source /root/admin-openrc
</code></pre><p>b）创建flat模式的public网络，注意这个public是外出网络，必须是flat模式的</p>
<pre><code>neutron --debug net-create --shared provider --router:external True --provider:network_type flat --provider:physical_network provider
</code></pre><p>执行完这步，在界面里进行操作，把public网络设置为共享和外部网络。</p>
<p>c）创建public网络子网，名为public-sub，网段就是192.168.0.1，并且IP范围是50-90（这个一般是给VM用的floating IP了），dns设置为192.168.0.1，网关为192.168.0.1</p>
<pre><code>neutron subnet-create provider 192.168.0.1/24 --name provider-sub --allocation-pool start=192.168.0.50,end=192.168.0.90 --dns-nameserver 192.168.0.1 --gateway 192.168.0.1
</code></pre><p>d）创建名为private的私有网络, 网络模式为vxlan</p>
<pre><code>neutron net-create private --provider:network_type vxlan --router:external False --shared
</code></pre><p>e）创建名为private-subnet的私有网络子网，网段为192.168.1.0, 这个网段就是虚拟机获取的私有的IP地址</p>
<pre><code>neutron subnet-create private --name private-subnet --gateway 192.168.1.1 192.168.1.0/24
</code></pre><p>假如你们公司的私有云环境是用于不同的业务，比如行政、销售、技术等，那么你可以创建3个不同名称的私有网络</p>
<pre><code>neutron net-create private-office --provider:network_type vxlan --router:external False --shared
neutron subnet-create private-office --name office-net --gateway 192.168.2.1 192.168.2.0/24

neutron net-create private-sale --provider:network_type vxlan --router:external False --shared
neutron subnet-create private-sale --name sale-net --gateway 192.168.3.1 192.168.3.0/24

neutron net-create private-technology --provider:network_type vxlan --router:external False --shared
neutron subnet-create private-technology --name technology-net --gateway 192.168.4.1 192.168.4.0/24
</code></pre><p>f）创建路由，我们在界面上操作</p>
<p>点击项目–&gt;网络–&gt;路由–&gt;新建路由</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-15.png" alt="o-15"></p>
<p>路由名称随便命名，我这里写”router”, 管理员状态，选择”上”(up)，外部网络选择”provider”</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-16.png" alt="o-16"></p>
<p>点击”新建路由”后，提示创建router创建成功</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-17.png" alt="o-17"></p>
<p>接着点击”接口”–&gt;”增加接口”</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-18.png" alt="o-18"></p>
<p>添加一个连接私网的接口，选中”private-office: 192.168.2.0/24”</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-19.png" alt="o-19"></p>
<p>点击”增加接口”成功后，我们可以看到两个接口先是down的状态，过一会儿刷新下就是running状态（注意，一定得是运行running状态，不然到时候虚拟机网络会出不去）</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-20.png" alt="o-20"></p>
<h2 id="检查网络服务"><a href="#检查网络服务" class="headerlink" title="检查网络服务"></a>检查网络服务</h2><pre><code>neutron agent-list
</code></pre><p>看服务是否是笑脸</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-21.png" alt="o-21"></p>
<h1 id="安装Dashboard"><a href="#安装Dashboard" class="headerlink" title="安装Dashboard"></a>安装Dashboard</h1><h2 id="安装dashboard相关软件包"><a href="#安装dashboard相关软件包" class="headerlink" title="安装dashboard相关软件包"></a>安装dashboard相关软件包</h2><pre><code>yum install openstack-dashboard -y
</code></pre><h2 id="修改配置文件-etc-openstack-dashboard-local-settings"><a href="#修改配置文件-etc-openstack-dashboard-local-settings" class="headerlink" title="修改配置文件/etc/openstack-dashboard/local_settings"></a>修改配置文件/etc/openstack-dashboard/local_settings</h2><pre><code>vim /etc/openstack-dashboard/local_settings
</code></pre><p>直接覆盖我给的local_settings文件也行（为了减少出错，用我提供的local_settings文件替换覆盖）</p>
<p><a href="https://pan.baidu.com/s/1hxN35B5LITfetZDin-6Y5Q" target="_blank" rel="external">百度云盘链接</a>    密码：e4p9</p>
<h2 id="启动dashboard服务并设置开机启动"><a href="#启动dashboard服务并设置开机启动" class="headerlink" title="启动dashboard服务并设置开机启动"></a>启动dashboard服务并设置开机启动</h2><pre><code>systemctl restart httpd.service memcached.service
systemctl status httpd.service memcached.service
</code></pre><p>到此，Controller节点搭建完毕，打开firefox浏览器即可访问 <a href="http://192.168.0.120/dashboard/" target="_blank" rel="external">http://192.168.0.120/dashboard/</a> 可进入openstack界面！</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/o-22.png" alt="o-22"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装Mariadb和RabbitMQ&quot;&gt;&lt;a href=&quot;#安装Mariadb和RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;安装Mariadb和RabbitMQ&quot;&gt;&lt;/a&gt;安装Mariadb和RabbitMQ&lt;/h1&gt;&lt;h2 id=&quot;搭
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://yjscloud.com/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack O版搭建" scheme="http://yjscloud.com/tags/OpenStack-O%E7%89%88%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack O版搭建（一）：环境初始化</title>
    <link href="http://yjscloud.com/2018/03/25/OpenStack-O%E7%89%88%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yjscloud.com/2018/03/25/OpenStack-O版搭建（一）：环境初始化/</id>
    <published>2018-03-25T12:36:24.000Z</published>
    <updated>2018-03-25T14:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自己搭建yum，一定要centos7.2源，具体怎么搭建这里略去（在我的cloudstack的系列文章中有提到的）源的下载如下：<br><a href="https://pan.baidu.com/s/1zlHCRwu0AuQx5Dlnc7X8yg" target="_blank" rel="external">百度网盘链接</a>  密码:8odd</p>
<p>安装CentOS7.2系统（ 最小化安装 ，不要yum update升级到7.3！Ocata版7.3下依然有虚拟机启动出现iPXE启动问题依旧） + 关闭防火墙 + 关闭selinux</p>
<pre><code>systemctl stop firewalld.service
systemctl disable firewalld.service
</code></pre><h1 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h1><p>虚拟出三台配置至少CPU 4c MEM 4G的虚拟机</p>
<p>Controller节点和Compute节点配置：</p>
<p>CPU:4c</p>
<p>MEM:4G</p>
<p>Disk:100G</p>
<p>Network: 3 (eth0 ens8 ens9， 第一块网卡就是extenel的网卡，第二块网卡是admin网卡，第三块是tunnel隧道)</p>
<p>Cinder节点配置：</p>
<p>CPU:4c</p>
<p>MEM:4G</p>
<p>Disk:100G+300G（这个300G可以根据自己需求调整大小）</p>
<p>Network: 2 (eth0 ens8 ens9， 第一块网卡就是extenel的网卡，第二块网卡是admin网卡，第三块是tunnel隧道)</p>
<p>每个节点都要做</p>
<p>安装好相关工具，因为系统是最小化安装的，所以一些ifconfig vim等命令没有，运行下面的命令把它们装上：</p>
<pre><code>yum install net-tools wget vim ntpdate bash-completion -y
</code></pre><h1 id="更改hostname"><a href="#更改hostname" class="headerlink" title="更改hostname"></a>更改hostname</h1><pre><code>hostnamectl set-hostname controller
</code></pre><p>如果是compute就运行：</p>
<pre><code>hostnamectl set-hostname compute1
</code></pre><p>cinder节点就运行：</p>
<pre><code>hostnamectl set-hostname cinder
</code></pre><p>然后每个节点配置/etc/hosts文件添加如下内容</p>
<pre><code>10.1.1.120 controller
10.1.1.121 compute1
10.1.1.122 cinder
</code></pre><h1 id="NTP同步系统时间"><a href="#NTP同步系统时间" class="headerlink" title="NTP同步系统时间"></a>NTP同步系统时间</h1><pre><code>ntpdate cn.pool.ntp.org
</code></pre><p>配置ntp服务</p>
<pre><code>yum -y install ntp
vim /etc/ntp.conf
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-1.png" alt="o-1"></p>
<pre><code>systemctl enable ntpd
systemctl start ntpd
</code></pre><p>检查同步状态</p>
<pre><code>ntpq -p
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/o-2.png" alt="o-2"></p>
<h1 id="配置IP-网络配置规划"><a href="#配置IP-网络配置规划" class="headerlink" title="配置IP 网络配置规划"></a>配置IP 网络配置规划</h1><p>网络配置：</p>
<p>external : 192.168.0.0/24</p>
<p>admin mgt : 10.1.1.0/24</p>
<p>tunnel：10.2.2.0/24</p>
<p>controller虚拟机第一块网卡external，请配置IP 192.168.0.120</p>
<p>第二块网卡admin，请配置IP 10.1.1.120</p>
<p>第三块网卡tunnel，请配置IP 10.2.2.120</p>
<p>compute1虚拟机第一块网卡external，请配置IP 192.168.0.121</p>
<p>第二块网卡admin，请配置IP 10.1.1.121</p>
<p>第三块网卡tunnel，请配置IP 10.2.2.121</p>
<p>cinder虚拟机第一块网卡external，请配置IP 192.168.0.122</p>
<p>第二块网卡admin，请配置IP 10.1.1.122</p>
<p>第三块网卡tunnel，请配置IP 10.2.2.122</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;自己搭建yum，一定要centos7.2源，具体怎么搭建这里略去（在我的cloudstack的系列文章中有提到的）源的下载如下：&lt;br&gt;&lt;a
    
    </summary>
    
      <category term="OpenStack学习笔记" scheme="http://yjscloud.com/categories/OpenStack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="OpenStack O版搭建" scheme="http://yjscloud.com/tags/OpenStack-O%E7%89%88%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（十二）面向对象进阶</title>
    <link href="http://yjscloud.com/2018/03/11/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
    <id>http://yjscloud.com/2018/03/11/Python当歌（十二）面向对象进阶/</id>
    <published>2018-03-11T11:42:14.000Z</published>
    <updated>2018-03-11T13:05:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="isinstance和issubclass"><a href="#isinstance和issubclass" class="headerlink" title="isinstance和issubclass"></a>isinstance和issubclass</h1><p>（1）isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</p>
<p>isinstance() 与 type() 区别：type() 不会认为子类是一种父类类型，不考虑继承关系。isinstance() 会认为子类是一种父类类型，考虑继承关系。如果要判断两个类型是否相同推荐使用 isinstance()。</p>
<p>以下是 isinstance() 方法的语法:</p>
<pre><code>isinstance(object, classinfo)
        object -- 实例对象。
        classinfo -- 可以是直接或间接类名、基本类型或者有它们组成的元组。
</code></pre><p>如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。</p>
<p>例子：</p>
<pre><code>&gt;&gt;&gt;a = 2
&gt;&gt;&gt; isinstance (a,int)
True
&gt;&gt;&gt; isinstance (a,str)
False
&gt;&gt;&gt; isinstance (a,(str,int,list))    # 是元组中的一个返回 True
True
</code></pre><p>type() 与 isinstance()区别：</p>
<pre><code>class A:
    pass

class B(A):
    pass

isinstance(A(), A)    # returns True
type(A()) == A        # returns True
isinstance(B(), A)    # returns True
type(B()) == A        # returns False
</code></pre><p>（2）issubclass() 方法用于判断参数 class 是否是类型参数 classinfo 的子类。</p>
<p>以下是 issubclass() 方法的语法:</p>
<pre><code>issubclass(class, classinfo)
        class -- 类。
        classinfo -- 类。
</code></pre><p>如果 class 是 classinfo 的子类返回 True，否则返回 False。</p>
<p>basestring 函数的实例：</p>
<pre><code>class A:
    pass
class B(A):
    pass

print(issubclass(B,A))    # 返回 True
</code></pre><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>（1）定义：主要指程序可以访问、监测和修改它本身状态或行为的一种能力（自省）。</p>
<p>（2）python面向对象中的反射：通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射）</p>
<p>四个可以实现自省的函数：</p>
<p>hasattr(obj, attr):这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。</p>
<p>getattr(obj, attr):调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为’bar’，则返回obj.bar。</p>
<p>setattr(obj, attr, val):调用这个方法将给obj的名为attr的值的属性赋值为val。例如如果attr为’bar’，则相当于obj.bar = val。</p>
<p>delattr(obj, attr)：函数用于删除属性。delattr(x, ‘foobar’) 相等于 del x.foobar。</p>
<p>四个方法的使用演示：</p>
<pre><code>class BlackMedium:
    feature=&apos;Ugly&apos;
    def __init__(self,name,addr):
        self.name=name
        self.addr=addr

    def sell_house(self):
        print(&apos;%s 黑中介卖房子啦,傻逼才买呢,但是谁能证明自己不傻逼&apos; %self.name)
    def rent_house(self):
        print(&apos;%s 黑中介租房子啦,傻逼才租呢&apos; %self.name)

b1=BlackMedium(&apos;万成置地&apos;,&apos;回龙观天露园&apos;)

#检测是否含有某属性
print(hasattr(b1,&apos;name&apos;))
print(hasattr(b1,&apos;sell_house&apos;))

#获取属性
n=getattr(b1,&apos;name&apos;)
print(n)
func=getattr(b1,&apos;rent_house&apos;)
func()

# getattr(b1,&apos;aaaaaaaa&apos;) #报错
print(getattr(b1,&apos;aaaaaaaa&apos;,&apos;不存在啊&apos;))

#设置属性
setattr(b1,&apos;sb&apos;,True)
setattr(b1,&apos;show_name&apos;,lambda self:self.name+&apos;sb&apos;)
print(b1.__dict__)
print(b1.show_name(b1))

#删除属性
delattr(b1,&apos;addr&apos;)
delattr(b1,&apos;show_name&apos;)
delattr(b1,&apos;show_name111&apos;)#不存在,则报错

print(b1.__dict__)
</code></pre><p>类也是对象：</p>
<pre><code>class Foo(object):
    staticField = &quot;old boy&quot;

    def __init__(self):
        self.name = &apos;wupeiqi&apos;

    def func(self):
        return &apos;func&apos;

    @staticmethod
    def bar():
        return &apos;bar&apos;


print(getattr(Foo, &apos;staticField&apos;))
print(getattr(Foo, &apos;func&apos;))
print(getattr(Foo, &apos;bar&apos;))
</code></pre><p>反射当前模块属性：</p>
<pre><code>import sys

def s1():
    print(&apos;s1&apos;)


def s2():
    print(&apos;s2&apos;)


this_module = sys.modules[__name__]

print(hasattr(this_module, &apos;s1&apos;))
print(getattr(this_module, &apos;s2&apos;))
</code></pre><p>导入其他模块，利用反射查找该模块是否存在某个方法<br>module_test.py文件：</p>
<pre><code># -*- coding:utf-8 -*-

def test():
print(&apos;from the test&apos;)
</code></pre><p>index.py文件：</p>
<pre><code># -*- coding:utf-8 -*-
</code></pre><p>程序目录：</p>
<pre><code>module_test.py
index.py
</code></pre><p>当前文件：</p>
<p>index.py</p>
<pre><code>import module_test as obj

#obj.test()

print(hasattr(obj,&apos;test&apos;))

getattr(obj,&apos;test&apos;)()
</code></pre><p>（3）用反射的好处</p>
<p>好处一：实现可插拔机制</p>
<p>服务端编写的程序由于什么情况中断没有继续编写，客户端那边需要用到服务端的类，这是客户端可以使用反射机制继续完成自己的代码，等服务端回来后再继续完成类的定义并去实现客户端想要的功能。<br>总之反射的好处就是，可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种‘后期绑定’，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能。</p>
<p>服务端还未实现的全部功能：</p>
<pre><code>class FtpClient:
    &apos;ftp客户端,但是还么有实现具体的功能&apos;
    def __init__(self,addr):
        print(&apos;正在连接服务器[%s]&apos; %addr)
        self.addr=addr
</code></pre><p>不影响客户端的代码编写：</p>
<pre><code>#from module import FtpClient
f1=FtpClient(&apos;192.168.1.1&apos;)
if hasattr(f1,&apos;get&apos;):
    func_get=getattr(f1,&apos;get&apos;)
    func_get()
else:
    print(&apos;----&gt;不存在此方法&apos;)
print(&apos;处理其他的逻辑&apos;)
</code></pre><p>好处二：动态导入模块（基于反射当前模块成员）</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/12-1.png" alt="12-1"></p>
<h1 id="setattr-delattr-getattr"><a href="#setattr-delattr-getattr" class="headerlink" title="__setattr__,__delattr__,__getattr__"></a>__setattr__,__delattr__,__getattr__</h1><pre><code>class Foo:
    x=1
    def __init__(self,y):
        self.y=y

    def __getattr__(self, item):
        print(&apos;----&gt; from getattr:你找的属性不存在&apos;)


    def __setattr__(self, key, value):
        print(&apos;----&gt; from setattr&apos;)
        # self.key=value #这就无限递归了,你好好想想
        # self.__dict__[key]=value #应该使用它

    def __delattr__(self, item):
        print(&apos;----&gt; from delattr&apos;)
        # del self.item #无限递归了
        self.__dict__.pop(item)

#__setattr__添加/修改属性会触发它的执行
f1=Foo(10)
print(f1.__dict__) # 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值
f1.z=3
print(f1.__dict__)

#__delattr__删除属性的时候会触发
f1.__dict__[&apos;a&apos;]=3#我们可以直接修改属性字典,来完成添加/修改属性的操作
del f1.a
print(f1.__dict__)

#__getattr__只有在使用点调用属性且属性不存在的时候才会触发
f1.xxxxxx
</code></pre><h1 id="二次加工标准类型-包装"><a href="#二次加工标准类型-包装" class="headerlink" title="二次加工标准类型(包装)"></a>二次加工标准类型(包装)</h1><p>包装：python为大家提供了标准数据类型，以及丰富的内置方法，其实在很多场景下我们都需要基于标准数据类型来定制我们自己的数据类型，新增/改写方法，这就用到了继承/派生知识（其他的标准类型均可以通过下面的方式进行二次加工）</p>
<p>二次加工标准类型(基于继承实现)：</p>
<pre><code>class List(list): #继承list所有的属性，也可以派生出自己新的，比如append和mid
    def append(self, p_object):
        &apos; 派生自己的append：加上类型检查&apos;
        if not isinstance(p_object,int):
            raise TypeError(&apos;must be int&apos;)
        super().append(p_object)

    @property
    def mid(self):
        &apos;新增自己的属性&apos;
        index=len(self)//2
        return self[index]

l=List([1,2,3,4])
print(l)
l.append(5)
print(l)
# l.append(&apos;1111111&apos;) #报错，必须为int类型

print(l.mid)

#其余的方法都继承list的
l.insert(0,-123)
print(l)
l.clear()
print(l)
</code></pre><p>授权：授权是包装的一个特性, 包装一个类型通常是对已存在的类型的一些定制,这种做法可以新建,修改或删除原有产品的功能。其它的则保持原样。授权的过程,即是所有更新的功能都是由新类的某部分来处理,但已存在的功能就授权给对象的默认属性。</p>
<p>实现授权的关键点就是覆盖<strong>getattr</strong>方法</p>
<p>授权示范一：</p>
<pre><code>import time
class FileHandle:
    def __init__(self,filename,mode=&apos;r&apos;,encoding=&apos;utf-8&apos;):
        self.file=open(filename,mode,encoding=encoding)
    def write(self,line):
        t=time.strftime(&apos;%Y-%m-%d %T&apos;)
        self.file.write(&apos;%s %s&apos; %(t,line))

    def __getattr__(self, item):
        return getattr(self.file,item)

f1=FileHandle(&apos;b.txt&apos;,&apos;w+&apos;)
f1.write(&apos;你好啊&apos;)
f1.seek(0)
print(f1.read())
f1.close()
</code></pre><p>授权示范二</p>
<pre><code>#我们来加上b模式支持
import time
class FileHandle:
    def __init__(self,filename,mode=&apos;r&apos;,encoding=&apos;utf-8&apos;):
        if &apos;b&apos; in mode:
            self.file=open(filename,mode)
        else:
            self.file=open(filename,mode,encoding=encoding)
        self.filename=filename
        self.mode=mode
        self.encoding=encoding

    def write(self,line):
        if &apos;b&apos; in self.mode:
            if not isinstance(line,bytes):
                raise TypeError(&apos;must be bytes&apos;)
        self.file.write(line)

    def __getattr__(self, item):
        return getattr(self.file,item)

    def __str__(self):
        if &apos;b&apos; in self.mode:
            res=&quot;&lt;_io.BufferedReader name=&apos;%s&apos;&gt;&quot; %self.filename
        else:
            res=&quot;&lt;_io.TextIOWrapper name=&apos;%s&apos; mode=&apos;%s&apos; encoding=&apos;%s&apos;&gt;&quot; %(self.filename,self.mode,self.encoding)
        return res
f1=FileHandle(&apos;b.txt&apos;,&apos;wb&apos;)
# f1.write(&apos;你好啊啊啊啊啊&apos;) #自定制的write,不用在进行encode转成二进制去写了,简单,大气
f1.write(&apos;你好啊&apos;.encode(&apos;utf-8&apos;))
print(f1)
f1.close()

练习题（授权）
class List:
    def __init__(self,seq,permission=False):
        self.seq=seq
        self.permission=permission
    def clear(self):
        if not self.permission:
            raise PermissionError(&apos;not allow the operation&apos;)
        self.seq.clear()

    def __getattr__(self, item):
        return getattr(self.seq,item)

    def __str__(self):
        return str(self.seq)
l=List([1,2,3])
# l.clear() #此时没有权限，抛出异常

l.permission=True
print(l)
l.clear()
print(l)

#基于授权，获得insert方法
l.insert(0,-123)
print(l)
</code></pre><h1 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a>__getattribute__</h1><p>（1）回顾<strong>getattr</strong></p>
<pre><code>class Foo:
    def __init__(self,x):
        self.x=x

    def __getattr__(self, item):
        print(&apos;执行的是我&apos;)
        # return self.__dict__[item]

f1=Foo(10)
print(f1.x)
f1.xxxxxx #不存在的属性访问，触发__getattr__
</code></pre><p>（2）<strong>getattribute</strong></p>
<pre><code>class Foo:
    def __init__(self,x):
        self.x=x

    def __getattribute__(self, item):
        print(&apos;不管是否存在,我都会执行&apos;)

f1=Foo(10)
f1.x
f1.xxxxxx
</code></pre><p>（3）二者同时出现</p>
<pre><code>#_*_coding:utf-8_*_

class Foo:
    def __init__(self,x):
        self.x=x

    def __getattr__(self, item):
        print(&apos;执行的是我&apos;)
        # return self.__dict__[item]
    def __getattribute__(self, item):
        print(&apos;不管是否存在,我都会执行&apos;)
        raise AttributeError(&apos;哈哈&apos;)

f1=Foo(10)
f1.x
f1.xxxxxx

#当__getattribute__与__getattr__同时存在,只会执行__getattrbute__,除非__getattribute__在执行过程中抛出异常AttributeError
</code></pre><h1 id="setitem-getitem-delitem"><a href="#setitem-getitem-delitem" class="headerlink" title="__setitem__,__getitem__,__delitem__"></a>__setitem__,__getitem__,__delitem__</h1><p><code>__setitem__(self,key,value)</code>：设置给定键的值<br><code>__getitem__(self,key)</code>:返回键对应的值。<br><code>__delitem__(self,key)</code>:删除给定键对应的元素。</p>
<p>例子：</p>
<pre><code>class Foo(object):
    def __getitem__(self, key):
        print(&apos;__getitem__&apos;, key)

    def __setitem__(self, key, value):
        print(&apos;__setitem__&apos;, key, value)

    def __delitem__(self, key):
        print(&apos;__delitem__&apos;, key)


obj = Foo()

result = obj[&apos;k1&apos;]  # 自动触发执行 __getitem__
obj[&apos;k2&apos;] = &apos;Pan&apos;  # 自动触发执行 __setitem__
del obj[&apos;k1&apos;]  # 自动触发执行 __delitem__
</code></pre><h1 id="str-repr-format"><a href="#str-repr-format" class="headerlink" title="__str__,__repr__,__format__"></a>__str__,__repr__,__format__</h1><p>改变对象的字符串显示<code>__str__</code>,<code>__repr__</code></p>
<p>自定制格式化字符串<code>__format__</code></p>
<p>例子：</p>
<pre><code>format_dict={
    &apos;nat&apos;:&apos;{obj.name}-{obj.addr}-{obj.type}&apos;,#学校名-学校地址-学校类型
    &apos;tna&apos;:&apos;{obj.type}:{obj.name}:{obj.addr}&apos;,#学校类型:学校名:学校地址
    &apos;tan&apos;:&apos;{obj.type}/{obj.addr}/{obj.name}&apos;,#学校类型/学校地址/学校名
}
class School:
    def __init__(self,name,addr,type):
        self.name=name
        self.addr=addr
        self.type=type

    def __repr__(self):
        return &apos;School(%s,%s)&apos; %(self.name,self.addr)
    def __str__(self):
        return &apos;(%s,%s)&apos; %(self.name,self.addr)

    def __format__(self, format_spec):
        # if format_spec
        if not format_spec or format_spec not in format_dict:
            format_spec=&apos;nat&apos;
        fmt=format_dict[format_spec]
        return fmt.format(obj=self)

s1=School(&apos;oldboy1&apos;,&apos;北京&apos;,&apos;私立&apos;)
print(&apos;from repr: &apos;,repr(s1))
print(&apos;from str: &apos;,str(s1))
print(s1)
</code></pre><p>str函数或者print函数—&gt;<code>obj.__str__()</code></p>
<p>repr或者交互式解释器—&gt;<code>obj.__repr__()</code></p>
<p>如果<strong>str</strong>没有被定义,那么就会使用<strong>repr</strong>来代替输出</p>
<p>注意:这俩方法的返回值必须是字符串,否则抛出异常</p>
<pre><code>print(format(s1,&apos;nat&apos;))
print(format(s1,&apos;tna&apos;))
print(format(s1,&apos;tan&apos;))
print(format(s1,&apos;asfdasdffd&apos;))
</code></pre><h1 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h1><p>（1）<strong>slots</strong>是什么:是一个类变量,变量值可以是列表,元祖,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性)</p>
<p>（2）    引子:使用点来访问属性本质就是在访问类或者对象的<strong>dict</strong>属性字典(类的字典是共享的,而每个实例的是独立的)</p>
<p>（3）为何使用<strong>slots</strong>:字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用<strong>slots</strong>取代实例的<strong>dict</strong>。<br>当你定义<strong>slots</strong>后,<strong>slots</strong>就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个。<br>字典,这跟元组或列表很类似。在<strong>slots</strong>中列出的属性名在内部被映射到这个数组的指定小标上。使用<strong>slots</strong>一个不好的地方就是我们不能再给。<br>实例添加新的属性了,只能使用在<strong>slots</strong>中定义的那些属性名。</p>
<p>（4）注意事项:<strong>slots</strong>的很多特性都依赖于普通的基于字典的实现。另外,定义了<strong>slots</strong>后的类不再支持一些普通类特性了,比如多继承。大多数情况下,你应该。<br>只在那些经常被使用到的用作数据结构的类上定义<strong>slots</strong>比如在程序中需要创建某个类的几百万个实例对象。<br>关于<strong>slots</strong>的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用<strong>slots</strong>可以达到这样的目的,但是这个并不是它的初衷。           更多的是用来作为一个内存优化工具。</p>
<p>例一：</p>
<pre><code>class Foo:
    __slots__=&apos;x&apos;

f1=Foo()
f1.x=1
f1.y=2#报错
print(f1.__slots__) #f1不再有__dict__

class Bar:
    __slots__=[&apos;x&apos;,&apos;y&apos;]

n=Bar()
n.x,n.y=1,2
n.z=3#报错
</code></pre><p>例二：</p>
<pre><code>class Foo:
    __slots__=[&apos;name&apos;,&apos;age&apos;]

f1=Foo()
f1.name=&apos;alex&apos;
f1.age=18
print(f1.__slots__)

f2=Foo()
f2.name=&apos;egon&apos;
f2.age=19
print(f2.__slots__)

print(Foo.__dict__)
#f1与f2都没有属性字典__dict__了,统一归__slots__管,节省内存
</code></pre><h1 id="next-和-iter-实现迭代器协议"><a href="#next-和-iter-实现迭代器协议" class="headerlink" title="__next__和__iter__实现迭代器协议"></a>__next__和__iter__实现迭代器协议</h1><p>（1）简单实现：</p>
<pre><code>class Foo:
    def __init__(self,x):
        self.x=x

    def __iter__(self):
        return self

    def __next__(self):
        n=self.x
        self.x+=1
        return self.x

f=Foo(3)
for i in f:
print(i)
</code></pre><p>（2）简单模拟range，加上步长：</p>
<pre><code>class Range:
    def __init__(self,n,stop,step):
        self.n=n
        self.stop=stop
        self.step=step

    def __next__(self):
        if self.n &gt;= self.stop:
            raise StopIteration
        x=self.n
        self.n+=self.step
        return x

    def __iter__(self):
        return self

for i in Range(1,7,3): #
print(i)
</code></pre><p>（3）斐波那契数列</p>
<pre><code>class Fib:
    def __init__(self):
        self._a=0
        self._b=1

    def __iter__(self):
        return self

    def __next__(self):
        self._a,self._b=self._b,self._a + self._b
        return self._a

f1=Fib()

print(f1.__next__())
print(next(f1))
print(next(f1))

for i in f1:
    if i &gt; 100:
        break
print(&apos;%s &apos; %i,end=&apos;&apos;)
</code></pre><h1 id="doc"><a href="#doc" class="headerlink" title="__doc__"></a>__doc__</h1><p><strong>doc</strong>是类的描述信息</p>
<pre><code>class Foo:
    &apos;我是描述信息&apos;
    pass

print(Foo.__doc__)

该属性无法继承给子类
class Foo:
    &apos;我是描述信息&apos;
    pass

class Bar(Foo):
    pass
print(Bar.__doc__) #该属性无法继承给子类
</code></pre><h1 id="module-和-class"><a href="#module-和-class" class="headerlink" title="__module__和__class__"></a>__module__和__class__</h1><p><code>__module__</code> 表示当前操作的对象在那个模块</p>
<p><code>__class__</code>   表示当前操作的对象的类是什么</p>
<pre><code>class C:

    def __init__(self):
        self.name = ‘SB&apos;

from lib.aa import C

obj = C()
print obj.__module__  # 输出 lib.aa，即：输出模块
print obj.__class__      # 输出 lib.aa.C，即：输出类
</code></pre><h1 id="del"><a href="#del" class="headerlink" title="__del__"></a>__del__</h1><p>析构方法，当对象在内存中被释放时，自动触发执行。</p>
<p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p>
<pre><code>class Foo:

    def __del__(self):
        pass
</code></pre><h1 id="enter-和-exit"><a href="#enter-和-exit" class="headerlink" title="__enter__和__exit__"></a>__enter__和__exit__</h1><p>我们知道在操作文件对象的时候可以这么写</p>
<pre><code>with open(&apos;a.txt&apos;) as f:
    &apos;代码块&apos;
</code></pre><p>上述叫做上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象的类中声明<strong>enter</strong>和<strong>exit</strong>方法</p>
<pre><code>class Open:
    def __init__(self,name):
        self.name=name

    def __enter__(self):
        print(&apos;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&apos;)
        # return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&apos;with中代码块执行完毕时执行我啊&apos;)


with Open(&apos;a.txt&apos;) as f:
    print(&apos;=====&gt;执行代码块&apos;)
# print(f,f.name)
</code></pre><p><code>__exit__</code>()中的三个参数分别代表异常类型，异常值和追溯信息,with语句中代码块出现异常，则with后的代码都无法执行</p>
<pre><code>class Open:
    def __init__(self,name):
        self.name=name

    def __enter__(self):
        print(&apos;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&apos;)

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&apos;with中代码块执行完毕时执行我啊&apos;)
        print(exc_type)
        print(exc_val)
        print(exc_tb)



with Open(&apos;a.txt&apos;) as f:
    print(&apos;=====&gt;执行代码块&apos;)
    raise AttributeError(&apos;***着火啦,救火啊***&apos;)
print(&apos;0&apos;*100) #-------------------------------&gt;不会执行
</code></pre><p>如果__exit()返回值为True,那么异常会被清空，就好像啥都没发生一样，with后的语句正常执行</p>
<pre><code>class Open:
    def __init__(self,name):
        self.name=name

    def __enter__(self):
        print(&apos;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&apos;)

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&apos;with中代码块执行完毕时执行我啊&apos;)
        print(exc_type)
        print(exc_val)
        print(exc_tb)
        return True

with Open(&apos;a.txt&apos;) as f:
    print(&apos;=====&gt;执行代码块&apos;)
    raise AttributeError(&apos;***着火啦,救火啊***&apos;)
print(&apos;0&apos;*100) #-------------------------------&gt;会执行
</code></pre><p>模拟Open：</p>
<pre><code>class Open:
    def __init__(self,filepath,mode=&apos;r&apos;,encoding=&apos;utf-8&apos;):
        self.filepath=filepath
        self.mode=mode
        self.encoding=encoding

    def __enter__(self):
        # print(&apos;enter&apos;)
        self.f=open(self.filepath,mode=self.mode,encoding=self.encoding)
        return self.f

    def __exit__(self, exc_type, exc_val, exc_tb):
        # print(&apos;exit&apos;)
        self.f.close()
        return True 
    def __getattr__(self, item):
        return getattr(self.f,item)

with Open(&apos;a.txt&apos;,&apos;w&apos;) as f:
    print(f)
    f.write(&apos;aaaaaa&apos;)
f.wasdf #抛出异常，交给__exit__处理
</code></pre><p>用途或者说好处：</p>
<p>1.使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预</p>
<p>2.在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在<strong>exit</strong>中定制自动释放资源的机制，你无须再去关系这个问题，这将大有用处</p>
<h1 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h1><p>对象后面加括号，触发执行。</p>
<p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p>
<pre><code>class Foo:

    def __init__(self):
        pass

    def __call__(self, *args, **kwargs):

        print(&apos;__call__&apos;)


obj = Foo() # 执行 __init__
obj()       # 执行 __call__
</code></pre><h1 id="描述符-get-set-delete"><a href="#描述符-get-set-delete" class="headerlink" title="描述符(__get__,__set__,__delete__)"></a>描述符(__get__,__set__,__delete__)</h1><p>１）描述符是什么:描述符本质就是一个新式类,在这个新式类中,至少实现了</p>
<pre><code>__get__(),__set__(),__delete__()中的一个,这也被称为描述符协议。
__get__():调用一个属性时,触发
__set__():为一个属性赋值时,触发
__delete__():采用del删除属性时,触发
</code></pre><p>定义一个描述符</p>
<pre><code>class Foo: #在python3中Foo是新式类,它实现了三种方法,这个类就被称作一个描述符
    def __get__(self, instance, owner):
        pass
    def __set__(self, instance, value):
        pass
    def __delete__(self, instance):
        pass
</code></pre><p>2)描述符是干什么的:描述符的作用是用来代理另外一个类的属性的(必须把描述符定义成这个类的类属性，不能定义到构造函数中)</p>
<p>引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行</p>
<pre><code>class Foo:
    def __get__(self, instance, owner):
        print(&apos;触发get&apos;)
    def __set__(self, instance, value):
        print(&apos;触发set&apos;)
    def __delete__(self, instance):
        print(&apos;触发delete&apos;)

#包含这三个方法的新式类称为描述符,由这个类产生的实例进行属性的调用/赋值/删除,并不会触发这三个方法
f1=Foo()
f1.name=&apos;egon&apos;
f1.name
del f1.name
#疑问:何时,何地,会触发这三个方法的执行

描述符应用之何时?何地?
#描述符Str
class Str:
    def __get__(self, instance, owner):
        print(&apos;Str调用&apos;)
    def __set__(self, instance, value):
        print(&apos;Str设置...&apos;)
    def __delete__(self, instance):
        print(&apos;Str删除...&apos;)

#描述符Int
class Int:
    def __get__(self, instance, owner):
        print(&apos;Int调用&apos;)
    def __set__(self, instance, value):
        print(&apos;Int设置...&apos;)
    def __delete__(self, instance):
        print(&apos;Int删除...&apos;)

class People:
    name=Str()
    age=Int()
    def __init__(self,name,age): #name被Str类代理,age被Int类代理,
        self.name=name
        self.age=age

#何地？：定义成另外一个类的类属性

#何时？：且看下列演示

p1=People(&apos;alex&apos;,18)

#描述符Str的使用
p1.name
p1.name=&apos;egon&apos;
del p1.name

#描述符Int的使用
p1.age
p1.age=18
del p1.age

#我们来瞅瞅到底发生了什么
print(p1.__dict__)
print(People.__dict__)

#补充
print(type(p1) == People) #type(obj)其实是查看obj是由哪个类实例化来的
print(type(p1).__dict__ == People.__dict__)
</code></pre><p>3)描述符分为两种</p>
<p>（1）数据描述符:至少实现了<code>__get__()</code>和<code>__set__()</code></p>
<pre><code>class Foo:
     def __set__(self, instance, value):
         print(&apos;set&apos;)
     def __get__(self, instance, owner):
        print(&apos;get&apos;)
</code></pre><p>（2）非数据描述符:没有实现<code>__set__()</code></p>
<pre><code>class Foo:
     def __get__(self, instance, owner):
         print(&apos;get&apos;)
</code></pre><p>4）注意事项:</p>
<p>一） 描述符本身应该定义成新式类,被代理的类也应该是新式类</p>
<p>二 ）必须把描述符定义成这个类的类属性，不能为定义到构造函数中</p>
<p>三 ）要严格遵循该优先级,优先级由高到底分别是</p>
<p>1.类属性</p>
<p>2.数据描述符</p>
<p>3.实例属性</p>
<p>4.非数据描述符</p>
<p>5.找不到的属性触发<strong>getattr</strong>()</p>
<p>5）描述符总结</p>
<p>描述符是可以实现大部分python类特性中的底层魔法,包括@classmethod,@staticmethd,@property甚至是<strong>slots</strong>属性。<br>描述父是很多高级库和框架的重要工具之一,描述符通常是使用到装饰器或者元类的大型框架中的一个组件.</p>
<p>6）利用描述符原理完成一个自定制@property,实现延迟计算（本质就是把一个函数属性利用装饰器原理做成一个描述符：类的属性字典中函数名为key，value为描述符类产生的对象）</p>
<p>@property回顾</p>
<pre><code>class Room:
    def __init__(self,name,width,length):
        self.name=name
        self.width=width
        self.length=length

    @property
    def area(self):
        return self.width * self.length

r1=Room(&apos;alex&apos;,1,1)
print(r1.area)
</code></pre><p>自己做一个@property</p>
<pre><code>class Lazyproperty:
    def __init__(self,func):
        self.func=func
    def __get__(self, instance, owner):
        print(&apos;这是我们自己定制的静态属性,r1.area实际是要执行r1.area()&apos;)
        if instance is None:
            return self
        return self.func(instance) #此时你应该明白,到底是谁在为你做自动传递self的事情

class Room:
    def __init__(self,name,width,length):
        self.name=name
        self.width=width
        self.length=length

    @Lazyproperty #area=Lazyproperty(area) 相当于定义了一个类属性,即描述符
    def area(self):
        return self.width * self.length

r1=Room(&apos;alex&apos;,1,1)
print(r1.area)
</code></pre><h1 id="元类metaclass"><a href="#元类metaclass" class="headerlink" title="元类metaclass"></a>元类metaclass</h1><p>1）引子</p>
<pre><code>class Foo:
    pass

f1=Foo() #f1是通过Foo类实例化的对象
</code></pre><p>python中一切皆是对象，类本身也是一个对象，当使用关键字class的时候，python解释器在加载class的时候就会创建一个对象(这里的对象指的是类而非类的实例)。<br>上例可以看出f1是由Foo这个类产生的对象，而Foo本身也是对象，那它又是由哪个类产生的呢？</p>
<pre><code>#type函数可以查看类型，也可以用来查看对象的类，二者是一样的
print(type(f1)) # 输出：&lt;class &apos;__main__.Foo&apos;&gt;     表示，obj 对象由Foo类创建
print(type(Foo)) # 输出：&lt;type &apos;type&apos;&gt;
</code></pre><p>2）什么是元类？</p>
<p>元类是类的类，是类的模板</p>
<p>元类是用来控制如何创建类的，正如类是创建对象的模板一样</p>
<p>元类的实例为类，正如类的实例为对象(f1对象是Foo类的一个实例，Foo类是 type 类的一个实例)</p>
<p>type是python的一个内建元类，用来直接控制生成类，python中任何class定义的类其实都是type类实例化的对象。</p>
<p>3）创建类的两种方式</p>
<p>方式一：</p>
<pre><code>class Foo:
    def func(self):
        print(&apos;from func&apos;)
</code></pre><p>方式二：</p>
<pre><code>def func(self):
    print(&apos;from func&apos;)
x=1
Foo=type(&apos;Foo&apos;,(object,),{&apos;func&apos;:func,&apos;x&apos;:1})
</code></pre><p>4）一个类没有声明自己的元类，默认他的元类就是type，除了使用元类type，用户也可以通过继承type来自定义元类（顺便我们也可以瞅一瞅元类如何控制类的创建，工作流程是什么）</p>
<pre><code>class Mytype(type):
    def __init__(self,what,bases=None,dict=None):
        print(what,bases,dict)

    def __call__(self, *args, **kwargs):
        print(&apos;---&gt;&apos;)
        obj=object.__new__(self)
        self.__init__(obj,*args,**kwargs)
        return obj
class Room(metaclass=Mytype):
    def __init__(self,name):
        self.name=name

r1=Room(&apos;alex&apos;)
print(r1.__dict__)
</code></pre><p>5）元类总结</p>
<pre><code>class Mymeta(type):
    def __init__(self,name,bases,dic):
        print(&apos;===&gt;Mymeta.__init__&apos;)

    def __new__(cls, *args, **kwargs):
        print(&apos;===&gt;Mymeta.__new__&apos;)
        return type.__new__(cls,*args,**kwargs)

    def __call__(self, *args, **kwargs):
        print(&apos;aaa&apos;)
        obj=self.__new__(self)
        self.__init__(self,*args,**kwargs)
        return obj

class Foo(object,metaclass=Mymeta):
    def __init__(self,name):
        self.name=name
    def __new__(cls, *args, **kwargs):
        return object.__new__(cls)
</code></pre><p>需要记住一点:名字加括号的本质(即,任何name()的形式),都是先找到name的爹,然后执行:爹.<strong>call</strong></p>
<p>而爹.<strong>call</strong>一般做两件事:</p>
<p>1.调用name.<strong>new</strong>方法并返回一个对象</p>
<p>2.进而调用name.<strong>init</strong>方法对儿子name进行初始化<br>class 定义Foo,并指定元类为Mymeta,这就相当于要用Mymeta创建一个新的对象Foo,于是相当于执行Foo=Mymeta(‘foo’,(…),{…})因此我们可以看到,只定义class就会有如下执行效果</p>
<p>===&gt;Mymeta.<strong>new</strong></p>
<p>===&gt;Mymeta.<strong>init</strong></p>
<p>实际上class Foo(metaclass=Mymeta)是触发了Foo=Mymeta(‘Foo’,(…),{…})操作,遇到了名字加括号的形式,即Mymeta(…),于是就去找Mymeta的爹type,然后执<code>type.__call__(...)</code>方法，于是触发Mymeta.<strong>new</strong>方法得到一个具体的对象,然后触发Mymeta.<strong>init</strong>方法对对象进行初始化obj=Foo(‘egon’)的原理同上</p>
<p>总结:元类的难点在于执行顺序很绕,其实我们只需要记住两点就可以了</p>
<p>1.谁后面跟括号,就从谁的爹中找<strong>call</strong>方法执行</p>
<p>type-&gt;Mymeta-&gt;Foo-&gt;obj</p>
<p>Mymeta()触发type.<strong>call</strong></p>
<p>Foo()触发Mymeta.<strong>call</strong></p>
<p>obj()触发Foo.<strong>call</strong></p>
<p>2.<strong>call</strong>内按先后顺序依次调用儿子的<strong>new</strong>和<strong>init</strong>方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;isinstance和issubclass&quot;&gt;&lt;a href=&quot;#isinstance和issubclass&quot; class=&quot;headerlink&quot; title=&quot;isinstance和issubclass&quot;&gt;&lt;/a&gt;isinstance和issubclass&lt;/
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（十一）三个class方法</title>
    <link href="http://yjscloud.com/2018/03/11/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%B8%89%E4%B8%AAclass%E6%96%B9%E6%B3%95/"/>
    <id>http://yjscloud.com/2018/03/11/Python当歌（十一）三个class方法/</id>
    <published>2018-03-10T17:36:41.000Z</published>
    <updated>2018-03-11T12:27:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Property（特性）"><a href="#Property（特性）" class="headerlink" title="Property（特性）"></a>Property（特性）</h1><h2 id="什么是特性property"><a href="#什么是特性property" class="headerlink" title="什么是特性property"></a>什么是特性property</h2><p>property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值</p>
<p>例一：BMI指数（bmi是计算而来的，但很明显它听起来像是一个属性而非方法，如果我们将其做成一个属性，更便于理解）</p>
<p>成人的BMI数值：</p>
<p>过轻：低于18.5</p>
<p>正常：18.5-23.9</p>
<p>过重：24-27</p>
<p>肥胖：28-32</p>
<p>非常肥胖, 高于32</p>
<p>　　体质指数（BMI）=体重（kg）÷身高^2（m）</p>
<p>EX：70kg÷（1.75×1.75）=22.86</p>
<pre><code>class People:
    def __init__(self,name,weight,height):
       self.name=name
       self.weight=weight
       self.height=height
   @property
   def bmi(self):
       return self.weight / (self.height**2)

p1=People(&apos;egon&apos;,75,1.85)
print(p1.bmi)
</code></pre><p>例二：圆的周长和面积</p>
<pre><code>import math
class Circle:
    def __init__(self,radius): #圆的半径radius
       self.radius=radius

    @property
    def area(self):
       return math.pi * self.radius**2 #计算面积

    @property
    def perimeter(self):
       return 2*math.pi*self.radius #计算周长

c=Circle(10)
print(c.radius)
print(c.area) #可以向访问数据属性一样去访问area,会触发一个函数的执行,动态计算出一个值
print(c.perimeter) #同上
</code></pre><p>输出结果:</p>
<p>314.1592653589793</p>
<p>62.83185307179586</p>
<p>注意：此时的特性arear和perimeter不能被赋值，c.area=3 #为特性area赋值</p>
<h2 id="为什么要用property"><a href="#为什么要用property" class="headerlink" title="为什么要用property"></a>为什么要用property</h2><p>将一个类的函数定义成特性以后，对象再去使用的时候obj.name,根本无法察觉自己的name是执行了一个函数然后计算出来的，这种特性的使用方式遵循了统一访问的原则。</p>
<p>除此之外，看下</p>
<p>ps：面向对象的封装有三种方式:</p>
<p>【public】</p>
<p>这种其实就是不封装,是对外公开的</p>
<p>【protected】</p>
<p>这种封装方式对外不公开,但对朋友(friend)或者子类(形象的说法是“儿子”,但我不知道为什么大家 不说“女儿”,就像“parent”本来是“父母”的意思,但中文都是叫“父类”)公开</p>
<p>【private】</p>
<p>这种封装对谁都不公开</p>
<p>python并没有在语法上把它们三个内建到自己的class机制中，在C++里一般会将所有的所有的数据都设置为私有的，然后提供set和get方法（接口）去设置和获取，在python中通过property方法可以实现。</p>
<pre><code>class Foo:
    def __init__(self,val):
    self.__NAME=val #将所有的数据属性都隐藏起来

    @property
    def name(self):
       return self.__NAME #obj.name访问的是self.__NAME(这也是真实值的存放位置)

    @name.setter
    def name(self,value):
       if not isinstance(value,str):  #在设定值之前进行类型检查
          raise TypeError(&apos;%s must be str&apos; %value)
       self.__NAME=value #通过类型检查后,将值value存放到真实的位置self.__NAME

    @name.deleter
    def name(self):
       raise TypeError(&apos;Can not delete&apos;)

f=Foo(&apos;egon&apos;)
print(f.name)
# f.name=10 #抛出异常&apos;TypeError: 10 must be str&apos;
del f.name #抛出异常&apos;TypeError: Can not delete&apos;
</code></pre><p>不用装饰器</p>
<pre><code>class Foo:
    def __init__(self,val):
          self.__NAME=val #将所有的数据属性都隐藏起来

    def getname(self):
       return self.__NAME #obj.name访问的是self.__NAME(这也是真实值的存放位置)

    def setname(self,value):
       if not isinstance(value,str):  #在设定值之前进行类型检查
          raise TypeError(&apos;%s must be str&apos; %value)
        self.__NAME=value #通过类型检查后,将值value存放到真实的位置self.__NAME

    def delname(self):
       raise TypeError(&apos;Can not delete&apos;)

    name=property(getname,setname,delname) #不如装饰器的方式清晰
</code></pre><h1 id="staticmethod（静态方法）"><a href="#staticmethod（静态方法）" class="headerlink" title="staticmethod（静态方法）"></a>staticmethod（静态方法）</h1><p>通常情况下，在类中定义的所有函数（注意了，这里说的就是所有，跟self啥的没关系，self也只是一个再普通不过的参数而已）都是对象的绑定方法，对象在调用绑定方法时会自动将自己作为参数传递给方法的第一个参数。除此之外还有两种常见的方法：静态方法和类方法，二者是为类量身定制的，但是实例非要使用，也不会报错。静态方法的好处是可以不实例化就可以调用类。</p>
<p>是一种普通函数，位于类定义的命名空间中，不会对任何实例类型进行操作，python为我们内置了函数staticmethod来把类中的函数定义成静态方法</p>
<pre><code>class Foo:
    def spam(x,y,z): #类中的一个函数，千万不要懵逼，self和x啥的没有不同都是参数名
       print(x,y,z)
spam=staticmethod(spam) #把spam函数做成静态方法
</code></pre><p>基于之前所学装饰器的知识，@staticmethod 等同于spam=staticmethod(spam),于是</p>
<pre><code>class Foo:
    @staticmethod #装饰器
    def spam(x,y,z):
       print(x,y,z)
</code></pre><p>使用演示</p>
<pre><code>print(type(Foo.spam)) #类型本质就是函数
Foo.spam(1,2,3) #调用函数应该有几个参数就传几个参数

f1=Foo()
f1.spam(3,3,3) #实例也可以使用,但通常静态方法都是给类用的,实例在使用时丧失了自动传值的机制

&lt;class &apos;function&apos;&gt;
2 3
3 3
</code></pre><p>应用场景:编写类时需要采用很多不同的方式来创建实例，而我们只有一个<strong>init</strong>函数，此时静态方法就派上用场了</p>
<pre><code>class Date:
    def __init__(self,year,month,day):
       self.year=year
       self.month=month
        self.day=day
    @staticmethod
    def now(): #用Date.now()的形式去产生实例,该实例用的是当前时间
       t=time.localtime() #获取结构化的时间格式
        return Date(t.tm_year,t.tm_mon,t.tm_mday) #新建实例并且返回
    @staticmethod
    def tomorrow():#用Date.tomorrow()的形式去产生实例,该实例用的是明天的时间
       t=time.localtime(time.time()+86400)
        return Date(t.tm_year,t.tm_mon,t.tm_mday)

a=Date(&apos;1987&apos;,11,27) #自己定义时间
b=Date.now() #采用当前时间
c=Date.tomorrow() #采用明天的时间

print(a.year,a.month,a.day)
print(b.year,b.month,b.day)
print(c.year,c.month,c.day)
</code></pre><h1 id="classmethod（类方法）"><a href="#classmethod（类方法）" class="headerlink" title="classmethod（类方法）"></a>classmethod（类方法）</h1><p>classmethod修饰符对应的函数不需要实例化，不需要 self 参数，但第一个参数需要是表示自身类的cls参数，可以来调用类的属性，类的方法，实例化对象等。</p>
<p>类方法是给类用的，类在使用时会将类本身当做参数传给类方法的第一个参数，python为我们内置了函数classmethod来把类中的函数定义成类方法</p>
<pre><code>class A:
    x=1
    @classmethod
    def test(cls):
       print(cls,cls.x)

class B(A):
    x=2
B.test()
</code></pre><p>输出结果:</p>
<pre><code>&lt;class &apos;__main__.B&apos;&gt; 2
</code></pre><p>应用场景：</p>
<pre><code>import time
class Date:
    def __init__(self,year,month,day):
       self.year=year
        self.month=month
        self.day=day
    @staticmethod
    def now():
       t=time.localtime()
       return Date(t.tm_year,t.tm_mon,t.tm_mday)

class EuroDate(Date):
    def __str__(self):
       return &apos;year:%s month:%s day:%s&apos; %(self.year,self.month,self.day)

e=EuroDate.now()
print(e) #我们的意图是想触发EuroDate.__str__,但是结果为
</code></pre><p>输出结果:</p>
<pre><code>&lt;__main__.Date object at 0x1013f9d68&gt;
</code></pre><p>因为e就是用Date类产生的,所以根本不会触发EuroDate._str__,解决方法就是用classmethod</p>
<pre><code>import time
class Date:
    def __init__(self,year,month,day):
        self.year=year
        self.month=month
        self.day=day
    #@staticmethod
    #def now():
    #        t=time.localtime()
    #         return Date(t.tm_year,t.tm_mon,t.tm_mday)

    @classmethod #改成类方法
    def now(cls):
       t=time.localtime()
       return cls(t.tm_year,t.tm_mon,t.tm_mday) #哪个类来调用,即用哪个类cls来实例化

class EuroDate(Date):
    def __str__(self):
       return &apos;year:%s month:%s day:%s&apos; %(self.year,self.month,self.day)

e=EuroDate.now()
print(e) #我们的意图是想触发EuroDate.__str__,此时e就是由EuroDate产生的,所以会如我们所愿
</code></pre><p>输出结果:</p>
<pre><code>year:2017 month:3 day:3
</code></pre><p>强调，注意注意注意：静态方法和类方法虽然是给类准备的，但是如果实例去用，也是可以用的，只不过实例去调用的时候容易让人混淆，不知道你要干啥</p>
<pre><code>x=e.now() #通过实例e去调用类方法也一样可以使用,静态方法也一样
print(x)
</code></pre><p>输出结果:</p>
<pre><code>year:2017 month:3 day:3
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Property（特性）&quot;&gt;&lt;a href=&quot;#Property（特性）&quot; class=&quot;headerlink&quot; title=&quot;Property（特性）&quot;&gt;&lt;/a&gt;Property（特性）&lt;/h1&gt;&lt;h2 id=&quot;什么是特性property&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GitLab安装与汉化</title>
    <link href="http://yjscloud.com/2018/03/08/GitLab%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B1%89%E5%8C%96/"/>
    <id>http://yjscloud.com/2018/03/08/GitLab安装与汉化/</id>
    <published>2018-03-08T14:30:54.000Z</published>
    <updated>2018-03-08T14:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gitlab-ce安装"><a href="#gitlab-ce安装" class="headerlink" title="gitlab-ce安装"></a>gitlab-ce安装</h1><p>GitLab是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。GitLab拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。</p>
<p>1）基础环境准备</p>
<pre><code>yum install curl policycoreutils openssh-server openssh-clients postfix
systemctl start postfix
systemctl enable postfix
systemctl enable sshd
systemctl start sshd
</code></pre><p> 2）安装gitlab-ce</p>
<pre><code>curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash
yum install -y gitlab-ce
</code></pre><p>注：由于网络问题，国内用户，建议使用清华大学的镜像源进行安装：</p>
<pre><code>[root@git ~]# vim /etc/yum.repos.d/gitlab-ce.repo
[gitlab-ce]
name=gitlab-ce
baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/
repo_gpgcheck=0
gpgcheck=0
enabled=1
gpgkey=https://packages.gitlab.com/gpg.key
[root@git ~]# yum makecache
[root@git ~]# yum install gitlab-ce
</code></pre><p>3）配置并启动gitlab-ce</p>
<pre><code>gitlab-ctl reconfigure
</code></pre><p>可以使用gitlab-ctl管理gitlab，例如查看gitlab状态：</p>
<pre><code>[root@git ~]# gitlab-ctl status
run: gitlab-workhorse: (pid 12171) 231s; run: log: (pid 7817) 555s
run: logrotate: (pid 12175) 230s; run: log: (pid 7832) 548s
run: nginx: (pid 12181) 230s; run: log: (pid 7823) 549s
run: postgresql: (pid 12186) 229s; run: log: (pid 7683) 587s
run: redis: (pid 12194) 229s; run: log: (pid 7600) 592s
run: sidekiq: (pid 12198) 229s; run: log: (pid 7806) 558s
run: unicorn: (pid 14967) 6s; run: log: (pid 7774) 560s
关闭gitlab：[root@git ~]# gitlab-ctl stop
启动gitlab：[root@git ~]# gitlab-ctl start
重启gitlab：[root@git ~]# gitlab-ctl restart
</code></pre><p>登录gitlab</p>
<p>第一次登录gitlab，需要为root用户修改密码，root用户也是gitlab的超级管理员。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-1.png" alt="4-1"></p>
<h1 id="配置GitLab主机名"><a href="#配置GitLab主机名" class="headerlink" title="配置GitLab主机名"></a>配置GitLab主机名</h1><p>1）修改/etc/gitlab/gitlab.rb文件</p>
<pre><code>mkdir -p /etc/gitlab
touch /etc/gitlab/gitlab.rb
chmod 600 /etc/gitlab/gitlab.rb
</code></pre><p>找到如下这段代码，把external_url改成部署机器的域名或者IP地址，如我的电脑ip地址就是 192.168.0.14</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-2.png" alt="4-2"></p>
<p>2）修改/var/opt/gitlab/gitlab-rails/etc/gitlab.yml文件</p>
<pre><code>vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/4-3.png" alt="4-3"></p>
<p>执行命令：gitlab-ctl reconfigure</p>
<p>如果还是不能正常访问的话，查看80端口是否被占用？ 有时候80端口可能被apache给暂用了，针对此问题，直接停用apache服务，或者修改apache的默认端口。</p>
<p>到此为止，gitlab的web管理页面就可以正常访问，并通过自定义域名访问了。</p>
<h1 id="端口被占用"><a href="#端口被占用" class="headerlink" title="端口被占用"></a>端口被占用</h1><p>如果出现如下页面可以尝试修改gitlab的端口</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-4.png" alt="4-4"></p>
<pre><code>vim /etc/gitlab/gitlab.rb
</code></pre><p>将external_url 直接输入 ip加上端口号 ，比如因为80端口被占用，我直接输入7777端口</p>
<pre><code>external_url &apos;http://192.168.0.14:7777
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/4-5.png" alt="4-5"></p>
<p>修改NGINX监听的端口为7777</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-6.png" alt="4-6"></p>
<p>修改完毕之后执行命令：gitlab-ctl reconfigure</p>
<h1 id="修改Gitlab数据存储路径"><a href="#修改Gitlab数据存储路径" class="headerlink" title="修改Gitlab数据存储路径"></a>修改Gitlab数据存储路径</h1><p>默认的Gitlab数据存储路径，在目录/var/opt/gitlab/git-data下，但是新的CentOS服务器根目录分配的空间比较小，为了防止以后数据过大，所以可以修改路径存储为/data/gitlabData。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-7.png" alt="4-7"></p>
<p>修改完毕之后执行命令：gitlab-ctl reconfigure</p>
<p>设置完后，过一段使用时间，可以看到该目录下的resposities，如下所示：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-8.png" alt="4-8"></p>
<h1 id="汉化gitlab"><a href="#汉化gitlab" class="headerlink" title="汉化gitlab"></a>汉化gitlab</h1><p>1) 安装git</p>
<pre><code>yum -y install git
</code></pre><p>2)克隆获取汉化版本库</p>
<p>下载最新的汉化包</p>
<pre><code>git clone https://gitlab.com/xhang/gitlab.git
</code></pre><p> 如果是要下载老版本的汉化包，需要加上老版本的分支，比如今天已经是10.5.2，我依旧想下载10.0.2，可以运行下面的语句</p>
<pre><code>git clone https://gitlab.com/xhang/gitlab.git -b v10.0.2-zh
</code></pre><p>3)查看该汉化补丁及gitlab的版本</p>
<pre><code>cat /opt/gitlab/embedded/service/gitlab-rails/VERSION
cat gitlab/VERSION
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/4-9.png" alt="4-9"></p>
<p>4)停止gitlab服务</p>
<pre><code>gitlab-ctl stop
</code></pre><p>5)切换到gitlab汉化包所在的目录（即步骤二获取的汉化版gitlab）</p>
<pre><code>cd /root/gitlab
</code></pre><p>6)比较汉化标签和原标签，导出 patch 用的 diff 文件到/root下 </p>
<pre><code>git diff v10.5.2 v10.5.2-zh &gt; ../10.5.2-zh.diff
</code></pre><p>7)将10.5.2-zh.diff作为补丁更新到gitlab中 </p>
<pre><code>cd ~
yum install patch -y
patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 10.5.2-zh.diff
</code></pre><p>8)重新配置gitlab </p>
<pre><code>gitlab-ctl start
gitlab-ctl reconfigure
</code></pre><p>登录gitlab界面查看</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-10.png" alt="4-10"></p>
<p>汉化完成！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;gitlab-ce安装&quot;&gt;&lt;a href=&quot;#gitlab-ce安装&quot; class=&quot;headerlink&quot; title=&quot;gitlab-ce安装&quot;&gt;&lt;/a&gt;gitlab-ce安装&lt;/h1&gt;&lt;p&gt;GitLab是一个利用 Ruby on Rails 开发的开源应用程
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git学习" scheme="http://yjscloud.com/tags/Git%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>DNS实战</title>
    <link href="http://yjscloud.com/2018/03/01/DNS%E5%AE%9E%E6%88%98/"/>
    <id>http://yjscloud.com/2018/03/01/DNS实战/</id>
    <published>2018-03-01T13:00:23.000Z</published>
    <updated>2018-03-01T15:11:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS简介"><a href="#DNS简介" class="headerlink" title="DNS简介"></a>DNS简介</h1><h2 id="DNS概况"><a href="#DNS概况" class="headerlink" title="DNS概况"></a>DNS概况</h2><p>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址互相映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。</p>
<p>DNS的分布数据库是以域名为索引的，每个域名实际上就是一棵很大的逆向树中路径，这棵逆向树称为域名空间（domain name space），如下图所示树的最大深度不得超过127层，树中每个节点都有一个可以长达63个字符的文本标号。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-1.png" alt="3-1"></p>
<h2 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h2><p>首先，客户端检测自身缓存，如果没有，检测hosts文件，如果没有，客户端发出DNS请求翻译IP地址或者主机名。DNS服务器在收到客户机的请求后：</p>
<p>1）检查DNS服务器的缓存，若查到请求的地址或名字，即向客户机发出应答信息；</p>
<p>2）若没有查到，则在数据库中查找，若查到请求的地址或名字，即向客户机发出应答信息；</p>
<p>3）若没有查到，则将请求发给根域DNS服务器，并依序从根域查找顶级域，由顶级域查找二级域，二级域查找三级，直至找到要解析的地址或名字，即向客户机所在网络的DNS服务器发出应答信息，DNS服务器收到应答后先在缓存中存储，然后将解析结果发给客户机。</p>
<p>4）若没有找到，则返回错误信息。</p>
<h2 id="DNS分类"><a href="#DNS分类" class="headerlink" title="DNS分类"></a>DNS分类</h2><p>主DNS服务器：就是一台存储着原始资料的DNS服务。</p>
<p>从DNS服务器：使用自动更新方式从主DNS服务器同步数据的DNS服务器。也称辅助DNS服务器。</p>
<p>备注：一般生产环境，主DNS服务器做管理使用，从DNS服务器提供服务。</p>
<p>缓存服务器：不负责本地解析，采用递归方式转发客户机查询请求，并返回结果给客户机的DNS服务器。同时缓存查询回来的记过，也叫递归服务器。</p>
<p>转发器：这台DNS发现非本机负责的查询请求时，不再向根域发起请求，而是直接转发给指定的一台或者多台服务器。自身并不缓存查询结果。</p>
<h2 id="DNS中记录类型"><a href="#DNS中记录类型" class="headerlink" title="DNS中记录类型"></a>DNS中记录类型</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-2.png" alt="3-2"></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-3.png" alt="3-3"></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-4.png" alt="3-4"></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-5.png" alt="3-5"></p>
<h2 id="DNS命名规范"><a href="#DNS命名规范" class="headerlink" title="DNS命名规范"></a>DNS命名规范</h2><p>1)26个英文字母</p>
<p>2)“0,1,2,3,4,5,6,7,8,9,”十个数字</p>
<p>3)“-”（英文中的连词号）</p>
<p>4)最多63字节长度</p>
<p>备注：要不按照这个规范命名，bing支不支持？ 支持，不合适，不建议。 非要不按照这个，怎么办？ master-view文件上配置check-name ignore;</p>
<h2 id="DNS三个命令介绍（dig、host、nslookup）"><a href="#DNS三个命令介绍（dig、host、nslookup）" class="headerlink" title="DNS三个命令介绍（dig、host、nslookup）"></a>DNS三个命令介绍（dig、host、nslookup）</h2><p>安装必要软件包：yum  install  bind-utils -y</p>
<h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>工具软件dig可以显示整个查询过程</p>
<pre><code>dig yjscloud.com
</code></pre><p>上面的命令会输出四段信息；</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-6.png" alt="3-6"></p>
<p>第一段是查询参数和统计</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-7.png" alt="3-7"></p>
<p>第二段是查询内容</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-8.png" alt="3-8"></p>
<p>第三段是DNS服务器的答复。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-9.png" alt="3-9"></p>
<p>上面结果表示，yjscloud.com的CNAME记录指向yjscloud.github.io.；而yjscloud.github.io.的CNAME记录指向sni.github.map.fastly.net.；也就是说，用户查询yjscloud.com的时候，实际上返回的是sni.github.map.fastly.net.的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改sni.github.map.fastly.net.这个域名就可以了，用户yjscloud.com域名不用修改。sni.github.map.fastly.net.有一个A记录，即一个IP地址。532、3532、4都是TTL值（time to live的缩写），表示缓存时间，即表示在这些时间内不用重新查询。</p>
<p>第四段是DNS服务器的一些传输信息。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-10.png" alt="3-10"></p>
<p>上面结果显示，本机的DNS服务器是192.168.16.1，查询端口是53（DNS服务器的默认端口），以及回应长度是117字节。</p>
<p>如果不想看到这么多内容，可以使用+short参数</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-11.png" alt="3-11"></p>
<p>使用+trace参数可以显示DNS的整个分级查询过程。</p>
<pre><code>dig yjscloud.com +trace
</code></pre><p>上面命令的第一段列出根域名.的所有NS记录，即所有根域名服务器。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-12.png" alt="3-12"></p>
<p>根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问yjscloud.com的顶级域名服务器com.的NS记录。</p>
<p>最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。</p>
<p>接着是第二段。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-13.png" alt="3-13"></p>
<p>上面结果显示.com域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。</p>
<p>然后，DNS服务器向这些顶级域名服务器发出查询请求，询问yjscloud.com的NS记录。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-14.png" alt="3-14"></p>
<p>上面结果显示yjscloud.com有两条NS记录，同时返回的还有每一条NS记录对应的IP地址。然后，DNS服务器向上面这两台NS服务器查询yjscloud.com的主机名。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-15.png" alt="3-15"></p>
<p>上面结果显示，yjscloud.com有一条CNAME记录，两条NS记录，最先返回结果的NS服务器是f1g1ns1.dnspod.net.，IP地址为58.247.212.36。</p>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>host命令可以看作dig命令的简化版本，返回当前请求域名的各种记录。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-16.png" alt="3-16"></p>
<p>host命令也可以用于逆向查询，即从IP地址查询域名，等同于dig -x <ip>。</ip></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-17.png" alt="3-17"></p>
<h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>nslookup命令用于互动式地查询域名记录。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-18.png" alt="3-18"></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="external">DNS入门原理</a></p>
<h1 id="DNS安装部署"><a href="#DNS安装部署" class="headerlink" title="DNS安装部署"></a>DNS安装部署</h1><h2 id="192-168-16-111（主DNS）安装"><a href="#192-168-16-111（主DNS）安装" class="headerlink" title="192.168.16.111（主DNS）安装"></a>192.168.16.111（主DNS）安装</h2><p>安装DNS： yum  install  -y bind-utils bind bind-devel bind-chroot</p>
<p>检查是否安装完成：rpm -qa | grep bind</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-19.png" alt="3-19"></p>
<p>配置named.conf文件</p>
<pre><code>mv  /etc/named .conf  /etc/named .conf.bak
vim  /etc/named .conf
</code></pre><p>配置文件的内容为：</p>
<pre><code>options {
   version &quot;1.1.1&quot;;
   listen-on port 53 {any;};
   directory &quot;/var/named/chroot/etc/&quot;;
   pid-file &quot;/var/named/chroot/var/run/named/named.pid&quot;;
   allow-query { any; };
   Dump-file &quot;/var/named/chroot/var/log/binddump.db&quot;;
   Statistics-file &quot;/var/named/chroot/var/log/named_stats&quot;;
   zone-statistics yes;
   memstatistics-file &quot;log/mem_stats&quot;;
   empty-zones-enable no;
   forwarders {202.106.196.115;8.8.8.8; };
};

key &quot;rndc-key&quot; {
        algorithm hmac-md5;
        secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};

controls {
       inet 127.0.0.1 port 953
               allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };
};

logging {
    channel warning {
        file &quot;/var/named/chroot/var/log/dns_warning&quot; versions 10 size 10m;
        severity warning;
        print-category yes;
        print-severity yes;
        print-time yes;
 };
    channel general_dns {
    file &quot;/var/named/chroot/var/log/dns_log&quot; versions 10 size 100m;
    severity info;
    print-category yes;
    print-severity yes;
    print-time yes;
 };
category default {
  warning;
 };
category queries {
  general_dns;
 };
};

include &quot;/var/named/chroot/etc/view.conf&quot;;
</code></pre><p>配置rndc.key文件</p>
<pre><code>vim /etc/rndc.key

key &quot;rndc-key&quot; {
        algorithm hmac-md5;
        secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};
</code></pre><p>配置rndc.conf文件</p>
<pre><code>vim /etc/rndc.conf

key &quot;rndc-key&quot; {
        algorithm hmac-md5;
        secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};

options {
        default-key &quot;rndc-key&quot;;
        default-server 127.0.0.1;
        default-port 953;
};
</code></pre><p>配置view.conf文件</p>
<pre><code>vim /var/named/chroot/etc/view.conf

view &quot;View&quot; {
    zone &quot;yjs.com&quot; {
            type    master;
            file    &quot;yjscloud.com.zone&quot;;
            allow-transfer {
                    192.168.16.112;
            };
            notify  yes;
            also-notify {
                    192.168.16.112;
            };
    };
};
</code></pre><p>配置yjscloud.com.zone文件</p>
<pre><code>vim /var/named/chroot/etc/yjscloud.com.zone

$ORIGIN .
$TTL 3600       ; 1 hour
yjs.com                  IN SOA  op.yjs.com. dns.yjs.com. (
                                2000       ; serial
                                900        ; refresh (15 minutes)
                                600        ; retry (10 minutes)
                                86400      ; expire (1 day)
                                3600       ; minimum (1 hour)
                                )
                        NS      op.yjs.com.
$ORIGIN yjs.com.
shanks              A       1.2.3.4
op              A       1.2.3.4
a               A       1.2.3.4
</code></pre><p>1）Serial：只是一个序号，但这个序号可被用来作为slave与master更新的依据。</p>
<p>举例来说，master序号为100但slave序号为90时，那么这个zone file的资料就会被传送到slave来更新了。由于这个序号代表新旧资料，通常我们建议你可以利用日期来设定。例如上面的资料是在2015/10/20所写的第一次，所以用2015102001作为序号代表。（yyyymmddnn，nn代表这一天是第几次修改）</p>
<p>2）Refresh：除了根据Serial来判断新旧之外，我们可以利用这个refresh（更新）命令slave多久进行一次主动更新、</p>
<p>3）Retry：如果到了Refresh的时间，但是slave却无法连接到master时，那么在多久之后，slave会再次的主动尝试与主机连接。</p>
<p>4）Expire：如果slave一直无法与master连接上，那么经过多久的时间之后，则命令slave不要再连接了。也就是说，此时我们假设masterDNS可能遇到重大问题而无法上线，则等待系统管理员处理完毕后，再重新到slaveDNS重启bind。</p>
<p>5）Minimum：这个类似TTL。<br>修改目录权限，并启动服务</p>
<pre><code>cd /var &amp;&amp; chown -R named.named named/
/etc/init.d/named start
chkconfig named on
</code></pre><p>解析测试</p>
<pre><code>dig @127.0.0.1 a.yjs.com
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-20.png" alt="3-20"></p>
<h2 id="192-168-16-112（从DNS）"><a href="#192-168-16-112（从DNS）" class="headerlink" title="192.168.16.112（从DNS）"></a>192.168.16.112（从DNS）</h2><pre><code>yum install -y bind-utils bind bind-devel bind-chroot
</code></pre><p>配置named.conf文件</p>
<pre><code>mv /etc/named.conf /etc/named.conf.bak
vim /etc/named.conf

options {
    version &quot;1.1.1&quot;;
    listen-on port 53 {any;};
    directory &quot;/var/named/chroot/etc/&quot;;
   pid-file &quot;/var/named/chroot/var/run/named/named.pid&quot;;
   allow-query { any; };
   Dump-file &quot;/var/named/chroot/var/log/binddump.db&quot;;
   Statistics-file &quot;/var/named/chroot/var/log/named_stats&quot;;
   zone-statistics yes;
   memstatistics-file &quot;log/mem_stats&quot;;
   empty-zones-enable no;
   forwarders {202.106.196.115;8.8.8.8; };
};

key &quot;rndc-key&quot; {
        algorithm hmac-md5;
        secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};

controls {
       inet 127.0.0.1 port 953
               allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };
};

logging {
    channel warning {
        file &quot;/var/named/chroot/var/log/dns_warning&quot; versions 10 size 10m;
        severity warning;
        print-category yes;
        print-severity yes;
        print-time yes;
    };
    channel general_dns {
        file &quot;/var/named/chroot/var/log/dns_log&quot; versions 10 size 100m;
        severity info;
        print-category yes;
        print-severity yes;
        print-time yes;
   };
   category default {
        warning;
    };
   category queries {
     general_dns;
  };
};

include &quot;/var/named/chroot/etc/view.conf&quot;;
</code></pre><p>配置rndc.key文件</p>
<pre><code>vim /etc/rndc.key

key &quot;rndc-key&quot; {
          algorithm hmac-md5;
          secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};
</code></pre><p>配置rndc.conf文件</p>
<pre><code>vim /etc/rndc.conf

key &quot;rndc-key&quot; {
         algorithm hmac-md5;
       secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};

options {
         default-key &quot;rndc-key&quot;;
       default-server 127.0.0.1;
         default-port 953;
};
</code></pre><p>备注：主从DNS主机配置named.conf、rndc.key、rndc.conf文件一样</p>
<p>配置view.conf文件</p>
<pre><code>vim /var/named/chroot/etc/view.conf

view &quot;SlaveView&quot; {
        zone &quot;yjs.com&quot; {
                 type    slave;
                 masters {192.168.16.111; };
                 file    &quot;slave.yjscloud.com.zone&quot;;
        };    
};
</code></pre><p>修改目录权限，并启动服务</p>
<pre><code>cd /var &amp;&amp; chown -R named.named named/
/etc/init.d/named start
chkconfig named on
</code></pre><p>进入目录/var/named/chroot/etc</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-21.png" alt="3-21"></p>
<p>如果有slave。yjscloud.com.zone这个文件说明主从已经同步</p>
<h2 id="添加A、CNAME、MX、PTR记录（主DNS）"><a href="#添加A、CNAME、MX、PTR记录（主DNS）" class="headerlink" title="添加A、CNAME、MX、PTR记录（主DNS）"></a>添加A、CNAME、MX、PTR记录（主DNS）</h2><h3 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h3><p>编辑master节点/var/named/chroot/etc/yjscloud.com.zone，在文件末尾添加记录</p>
<pre><code>a               A       192.168.1.100
将serial + 1
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-22.png" alt="3-22"></p>
<p>执行rndc reload</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-23.png" alt="3-23"></p>
<p>检查从DNS主机，slave.yjscloud.com.zone文件已同步更新。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-24.png" alt="3-24"></p>
<h3 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h3><p>编辑master节点/var/named/chroot/etc/yjscloud.com.zone，在文件末尾添加记录</p>
<pre><code>cname       CNAME   a.yjs.com.
将serial + 1
</code></pre><p>执行rndc reload</p>
<p>检查从DNS主机，slave.yjscloud.com.zone文件已同步更新。</p>
<p>测试 host a.swj.com 127.0.0.1</p>
<h3 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h3><p>编辑master节点/var/named/chroot/etc/shhnwangjian.com.zone，在文件末尾添加记录</p>
<pre><code>mx      MX 5    192.168.1.101
将serial + 1
</code></pre><p>执行rndc reload</p>
<p>检查从DNS主机，slave.shhnwangjian.com.zone文件已同步更新。</p>
<p>测试 host mx.swj.com 127.0.0.1</p>
<h2 id="PTR记录（反向解析）"><a href="#PTR记录（反向解析）" class="headerlink" title="PTR记录（反向解析）"></a>PTR记录（反向解析）</h2><p>编辑master节点/var/named/chroot/etc/view.conf，加入ptr的zone配置</p>
<pre><code>zone &quot;168.192.in-addr.arpa&quot; {
  type    master;
 file    &quot;168.192.zone&quot;;
 allow-transfer{
       192.168.16.1112;
 };
 notify  yes;
 also-notify{
     192.168.16.112;
 };
};
</code></pre><p>在下面这个位置加入代码：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-25.png" alt="3-25"></p>
<p>编辑master节点/var/named/chroot/etc/168.192.zone</p>
<pre><code>$TTL 3600       ; 1 hour
@                   IN SOA  op.yjs.com. dns.yjs.com. (
                            2003       ; serial
                            900        ; refresh (15 minutes)
                            600        ; retry (10 minutes)
                            86400      ; expire (1 day)
                            3600       ; minimum (1 hour)
                            )
                    NS      op.yjs.com.
100.1               IN  PTR a.yjs.com.
</code></pre><p>修改168.192.zone文件属主</p>
<pre><code>chown named.named 168.192.zone
rndc reload
</code></pre><p>编辑slave节点/var/named/chroot/etc/view.conf，加入ptr的zone配置</p>
<pre><code>zone &quot;168.192.in-addr.arpa&quot; {
     type    slave;
     masters {192.168.16.111; };
     file    &quot;slave.168.192.zone&quot;;
};
</code></pre><p>在下面的这个位置加入代码：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-26.png" alt="3-26"></p>
<p>执行rndc reload</p>
<p>slava节点/var/named/chroot/etc目录下生成slave.168.192.zone文件。</p>
<p>解析测试: host 192.168.1.100 127.0.0.1</p>
<h2 id="DNS实现服务的负载均衡"><a href="#DNS实现服务的负载均衡" class="headerlink" title="DNS实现服务的负载均衡"></a>DNS实现服务的负载均衡</h2><p>编辑master节点/var/named/chroot/etc/yjscloud.com.zone，在文件末尾添加记录</p>
<pre><code>a               A       192.168.1.102
将serial + 1
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-27.png" alt="3-27"></p>
<p>执行rndc reload</p>
<p>master和slave执行解析：nslookup a.yjs.com 127.0.0.1，结果如下（轮询）</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-28.png" alt="3-28"></p>
<h3 id="配置DNS视图（智能DNS）"><a href="#配置DNS视图（智能DNS）" class="headerlink" title="配置DNS视图（智能DNS）"></a>配置DNS视图（智能DNS）</h3><p>编辑master节点/var/named/chroot/etc/named.conf，在include上面添加（对客户端IP分组）</p>
<pre><code>acl group1 {
 192.168.137.13;
};

acl group2 {
 192.168.137.14;
};
</code></pre><p>编辑master节点/var/named/chroot/etc/view.conf（清空原view.conf文件的内容再添加）</p>
<pre><code>view &quot;GROUP1&quot; {
 match-clients { group1; };
 zone &quot;viewyjs.com&quot; {
    type master;
    file &quot;group1.viewyjs.com.zone&quot;;
  };
};

view &quot;GROUP2&quot; {
 match-clients { group2; };
 zone &quot;viewyjs.com&quot; {
    type master;
    file &quot;group2.viewyjs.com.zone&quot;;
 };
};
</code></pre><p>编辑master节点/var/named/chroot/etc/group1.viewyjs.com.zone</p>
<pre><code>$ORIGIN .
$TTL 3600       ; 1 hour
viewyjs.com                  IN SOA  op.viewyjs.com. dns.viewyjs.com. (
                            2000       ; serial
                            900        ; refresh (15 minutes)
                            600        ; retry (10 minutes)
                            86400      ; expire (1 day)
                            3600       ; minimum (1 hour)
                            )
                    NS      op.viewyjs.com.
$ORIGIN viewyjs.com.
view              A       192.168.122.1
op              A       192.168.122.1
</code></pre><p>编辑master节点/var/named/chroot/etc/group2.viewyjs.com.zone</p>
<pre><code>$ORIGIN .
$TTL 3600       ; 1 hour
viewyjs.com                  IN SOA  op.viewyjs.com. dns.viewyjs.com. (
                            2000       ; serial
                            900        ; refresh (15 minutes)
                            600        ; retry (10 minutes)
                            86400      ; expire (1 day)
                            3600       ; minimum (1 hour)
                            )
                    NS      op.viewyjs.com.
$ORIGIN viewyjs.com.
view              A       192.168.122.2
op              A       192.168.122.2
</code></pre><p>修改文件属主，加载配置</p>
<pre><code>chown named.named /var/named/chroot/etc/group*.zone
rndc reload
</code></pre><p>测试，在192.168.16.111主机上执行host view.viewyjs.com 192.168.16.111</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-29.png" alt="3-29"></p>
<p>在192.168.16.112主机上执行host view.viewyjs.com 192.168.16.111</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-30.png" alt="3-30"></p>
<h1 id="构建DNS（企业级）"><a href="#构建DNS（企业级）" class="headerlink" title="构建DNS（企业级）"></a>构建DNS（企业级）</h1><h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><p>CPU：12C以上配置</p>
<p>内存：16G</p>
<p>网络：千兆</p>
<h2 id="初始化系统配置"><a href="#初始化系统配置" class="headerlink" title="初始化系统配置"></a>初始化系统配置</h2><p>关闭 iptables</p>
<p>service iptables stop<br>chkconfig iptables off<br>关闭 selinux<br>vi /etc/sysconfig/selinux<br>SELINUX=disabled</p>
<h2 id="高性能、高可用DNS"><a href="#高性能、高可用DNS" class="headerlink" title="高性能、高可用DNS"></a>高性能、高可用DNS</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-31.png" alt="3-31"></p>
<p>1）高可用</p>
<p>物理层：首先确保两台lvs不在同一机柜、同一物理交换机接入；其次确保将所有dns服务器也做到不在同一机柜、同一物理交换机接入；在不通的idc构建多套dns集群，为客户端提供可切换的配置。</p>
<p>服务层：坚决摒弃lvs上端口检测这种方式，采用自定义脚本检测，为dns的健康检测单独设置一个域名，为了lvs检测dns是否存活而设计。</p>
<p>客户端层：多idc之间的流量切换是通过客户端的健康检测cron实现的，脚本可以按分钟运行一次，分别检测每个dns集群虚地址的可用性。</p>
<pre><code>#!/bin/sh
timeout=5
Q=&quot;&quot;
host=&quot;/usr/bin/host&quot;
if test -z &quot;$1&quot; ; then
    echo &quot;You need to supply a DNS server to check. Quittind&quot;
    exit;
fi
SERVER=$10
ERC=`$host -s -w $timeout $Q SERVER &gt; /dev/null 2&gt;$1; echo $?`
if [ $ERC -eq 0 ] ; then
    exit 0
else
    exit 10
fi
</code></pre><p>2）高性能</p>
<p>   通过lvs可以对每个集群做横向扩容，是否需要扩容的依据是对现有系统的压测结果，以及实时的监控数据。或者可以在最靠近应用层处，加上一次cache-only集群，但前提是你的线上环境中，没有任何系统依赖于dns负载均衡。</p>
<h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><p>将bind-9.9.9-P1.tar.gz下载到合适的目录下</p>
<p>下载bind源码:</p>
<pre><code>wget http://ftp.isc.org/isc/bind9/9.9.1-P1/bind-9.9.9-P1.tar.gz
</code></pre><p>解压: </p>
<pre><code>tar -xvf bind-9.9.9-P1.tar.gz
cd /bind-9.9.9-P1/contrib/queryperf
</code></pre><p>编译:</p>
<pre><code>./configure
make
</code></pre><p>此目录下生成queryperf文件</p>
<pre><code>cp queryperf /usr/bin
</code></pre><p>压测自己创建的DNS服务，创建一个文件test.txt，内容如下（前面为域名，后面为A记录）</p>
<pre><code>view.viewyjs.com A
view.viewyjs.com A
view.viewyjs.com A
view.viewyjs.com A
view.viewyjs.com A
</code></pre><p>执行命令： </p>
<pre><code>queryperf -d test.txt -s 192.168.16.111
</code></pre><p>结果：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-32.png" alt="3-32"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DNS简介&quot;&gt;&lt;a href=&quot;#DNS简介&quot; class=&quot;headerlink&quot; title=&quot;DNS简介&quot;&gt;&lt;/a&gt;DNS简介&lt;/h1&gt;&lt;h2 id=&quot;DNS概况&quot;&gt;&lt;a href=&quot;#DNS概况&quot; class=&quot;headerlink&quot; title=&quot;DNS
    
    </summary>
    
      <category term="运维技能" scheme="http://yjscloud.com/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Linux技术" scheme="http://yjscloud.com/tags/Linux%E6%8A%80%E6%9C%AF/"/>
    
      <category term="DNS" scheme="http://yjscloud.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>saltstack自动化运维（一）</title>
    <link href="http://yjscloud.com/2018/03/01/saltstack%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yjscloud.com/2018/03/01/saltstack自动化运维（一）/</id>
    <published>2018-03-01T04:39:43.000Z</published>
    <updated>2018-03-01T05:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="saltstack简介"><a href="#saltstack简介" class="headerlink" title="saltstack简介"></a>saltstack简介</h1><p>（1）saltstack介绍</p>
<p>SaltStack是一个新的基础平台管理工具，只需要花费数分钟即可运行起来，可以支撑管理上万台服务器的规模，数秒钟即可完成数据传递。SaltStack是使用Python语言开发的，同时提供Rest API方便二次开发以及和其它平台进行集成，同时官方也发布了一个Web管理界面halite。</p>
<p>（2）saltstack运行方式</p>
<p>saltstack有三种运行方式</p>
<ul>
<li>Local</li>
<li>Master/Minion</li>
<li>Salt SSH<br>SaltStack的传统运行模式为Master/Minion（C/S结构），需要在被管理的节点上安装Minion。同时SaltStack也支持SSH的方式，无需安装Agent，通过SSH实现管理。</li>
</ul>
<p>（3）saltstack目前拥有三大功能</p>
<ul>
<li>远程执行</li>
<li>配置管理</li>
<li>云管理</li>
</ul>
<h1 id="saltstack实战部署"><a href="#saltstack实战部署" class="headerlink" title="saltstack实战部署"></a>saltstack实战部署</h1><p>SaltStack支持多种操作系统，如CentOS、RedHat、Debian、Ubuntu、FreeBSD、Solaris、Fedora、SuSe、Gentoo、MAC OS X、Archlinux等，以及Windows（仅支持Minion）。</p>
<p>saltstack服务器基本设置：CentOS7.2最小化安装，关闭防火墙，selinux设置为disabled，虚拟机网卡这里为桥接模式</p>
<h2 id="安装saltstack源"><a href="#安装saltstack源" class="headerlink" title="安装saltstack源"></a>安装saltstack源</h2><p>对于Centos和RedHat用户，使用yum安装时最直接和快捷的。首先需要CentOS和epel仓库。saltstack官方源在国外下载使用需要vpn，我直接将saltstack2016.3的源同步到本地搭建了一个本地yum源，需要下载saltstack源的朋友请自带小飞机到<code>https://repo.saltstack.com</code>去下载，以下是我的repo的配置文件：</p>
<p>CentOS和epel的repo：</p>
<pre><code>[centos]
name=centos7.2
baseurl= http://192.168.16.198:8080/centos7.2/7.2/os/x86_64/
enabled=1
gpgcheck=0

[epel]
name=epel
baseurl= http://192.168.16.198:8080/epel/7/x86_64/
enabled=1
gpgcheck=0
</code></pre><p>saltstack的repo：</p>
<pre><code>[saltstack]
name=saltstack-2016.3
baseurl= http://192.168.16.198:8080/saltstack-2016.3/
enabled=1
gpgcheck=0
</code></pre><h2 id="安装saltstack"><a href="#安装saltstack" class="headerlink" title="安装saltstack"></a>安装saltstack</h2><p>saltstack01为master，saltstack02为minion</p>
<p>在saltstack01</p>
<pre><code>yum -y install salt-master salt-minion
</code></pre><p>在saltstack02</p>
<pre><code>yum -y install salt-minion
</code></pre><h2 id="启动saltstack"><a href="#启动saltstack" class="headerlink" title="启动saltstack"></a>启动saltstack</h2><p>在saltstack01上</p>
<pre><code>systemctl start salt-master
systemctl enable salt-master
</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在saltstack01上</p>
<pre><code>vim /etc/salt/minion
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-1.png" alt="2-1"></p>
<p>启动salt-minion</p>
<pre><code>systemctl start salt-minion
systemctl enable salt-minion
</code></pre><p>在saltstack02上</p>
<pre><code>vim /etc/salt/minion2
</code></pre><p>启动salt-minion</p>
<pre><code>systemctl start salt-minion
systemctl enable salt-minion
</code></pre><h2 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-2.png" alt="2-2"></p>
<p>认证命令：salt-key</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-3.png" alt="2-3"></p>
<p>同意公钥key</p>
<pre><code>salt-key -a saltstack01
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-4.png" alt="2-4"></p>
<p>还可以使用通配符：</p>
<pre><code>salt-key -a saltstack*  #-A表示同意所有
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-5.png" alt="2-5"></p>
<p>同意后查看pki</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-6.png" alt="2-6"></p>
<p>远程执行命令:</p>
<pre><code>语法： 命令 目标 模块.方法 方法参数
salt &apos;*&apos; test.ping
</code></pre><p> 上面的命令用来查看有哪些Minion节点连接到Master。* 指的是选定的目标Minion，很显然代表所有。就是所有Minion端了。test.ping是salt远程执行的一个模块。（注意：这并不是一个ICMP ping。）</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-7.png" alt="2-7"></p>
<pre><code>salt &apos;saltstack01&apos; cmd.run &apos;w&apos;
</code></pre><p> <img src="http://opnq5yeqm.bkt.clouddn.com/2-8.png" alt="2-8"></p>
<pre><code>salt &apos;saltstack01&apos; cmd.run &apos;mkdir /tmp/yjscloud&apos;
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-9.png" alt="2-9"></p>
<h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p> Salt使用State模块文件进行配置管理，使用YAML编写，以.sls结尾。如果进行配置管理首先需要再Master的配置文件中指定”file roots”的选项，Salt支持环境的配置，比如开发环节、测试环境、生产环境，但是base环境是必须的。而且Base环境必须包含入口文件top.sls。</p>
<p>YAML: 三板斧</p>
<pre><code>1.缩进
     2个空格，不能试用Tab。
2.冒号 
     key: value
3.短横线  
      - list1
      - list2
</code></pre><p>第一步：设置file_roots<br>在saltstack01修改Master配置文件，指定file_roots：vim /etc/salt/master</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-10.png" alt="2-10"></p>
<p>重启master: systemctl restart salt-master</p>
<p>创建目录：mkdir /srv/salt</p>
<p>第二步：设置top.sls</p>
<p>在top.sls入口文件设置环境（如生产、开发、测试对应不同的minion和模块）。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-11.png" alt="2-11"></p>
<p>解释：所有的Minion均执行base目录下的init模块下的pkg-init.sls。我们可以把很多的sls放在一个目录中，方便管理。在top.sls只需要指定目录结构即可。</p>
<p>第三步：编写状态文件<br>在这个目录下创建web目录，在这个目录下编辑文件apache.sls，文件内容为：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-12.png" alt="2-12"></p>
<p>第四步：执行状态</p>
<p>执行这个文件：salt ‘*’ state.sls web.apache</p>
<p>根据上面的设置，执行完状态后。Salt会检查Minion上是否有上面编写的三个软件包。如果没有就会自动使用Yum安装上。</p>
<p>在saltstack02端查看：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-13.png" alt="2-13"></p>
<p>saltstack01将描述文件发往saltstack02让其执行</p>
<h1 id="saltstack与ZeroMQ"><a href="#saltstack与ZeroMQ" class="headerlink" title="saltstack与ZeroMQ"></a>saltstack与ZeroMQ</h1><p>saltstack底层是基于ZeroMQ进行高效的网络通信</p>
<h2 id="ZeroMQ简介"><a href="#ZeroMQ简介" class="headerlink" title="ZeroMQ简介"></a>ZeroMQ简介</h2><p>ØMQ （也拼写作ZeroMQ，0MQ或ZMQ)是一个为可伸缩的分布式或并发应用程序设计的高性能异步消息库。它提供一个消息队列, 但是与面向消息的中间件不同，ZeroMQ的运行不需要专门的消息代理（message broker）。该库设计成常见的套接字风格的API。能够提供进程内(inproc)、进程间(IPC)、网络(TCP)和广播方式的消息信道， 并支持扇出(fan-out)、发布-订阅(pub-sub)、任务分发（task distribution）、请求/响应（request-reply）等通信模式。</p>
<h2 id="saltstack第一种模式：发布与订阅"><a href="#saltstack第一种模式：发布与订阅" class="headerlink" title="saltstack第一种模式：发布与订阅"></a>saltstack第一种模式：发布与订阅</h2><p>ZeroMQ支持Publish/Subscribe，即发布与订阅模式，我们经常简称Pub/Sub。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-14.png" alt="2-14"></p>
<p>Salt Master运行两个网络服务，其中一个是ZeroMQ PUB系统，默认监听4505端口。可以通过修改/etc/salt/master配置文件的publish_port参数设置。它是salt的消息发布系统，如果查看4505端口，会发现所有的Minion连接到Master的4505端口，TCP状态持续保持为ESTABLISHED。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-15.png" alt="2-15"></p>
<h2 id="saltstack第一种模式：请求与响应"><a href="#saltstack第一种模式：请求与响应" class="headerlink" title="saltstack第一种模式：请求与响应"></a>saltstack第一种模式：请求与响应</h2><p>ZeroMQ支持Request-Reply，即请求与响应模式，我们经常简称REQ/REP。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-16.png" alt="2-16"></p>
<p>Salt Master运行的第二个网络服务就是ZeroMQ REP系统，默认监听4506端口，可以通过修改/etc/salt/master配置文件的ret_port参数设置。</p>
<p>它是salt客户端与服务端通信的端口。比如说Minion执行某个命令后的返回值就是发送给Master的4506这个REP端口</p>
<p>如果安装了python-setproctitle软件包，所以我们可以直接看到Salt Master启动的进程的名称。</p>
<pre><code>yum  install  -y python-setproctitle
</code></pre><p>重启master和minion</p>
<pre><code>systemctl restart salt-master
systemctl restart salt-minion
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-17.png" alt="2-17"></p>
<p>备注：</p>
<pre><code>/usr/bin/salt-master  -d ProcessManager   # 中心进程管理器
/usr/bin/salt-master  -d _clear_old_jobs   # 清除旧的Jobs文件及更新fileserver
/usr/bin/salt-master  -d Publisher        # 将任务PUB到Minion端
/usr/bin/salt-master  -d EventPublisher   # Event Publisher进程
/usr/bin/salt-master  -d ReqServer_ProcessManager  # ReqServer进程管理器
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorkerQueue  # 将Ret接口(ROUTER)数据转发到Worker(DEALER)
</code></pre><h1 id="saltstack数据系统"><a href="#saltstack数据系统" class="headerlink" title="saltstack数据系统"></a>saltstack数据系统</h1><p>saltstack数据系统分为Grian和Pillar</p>
<h2 id="Grains"><a href="#Grains" class="headerlink" title="Grains"></a>Grains</h2><p>静态数据，当Minion启动的时候收集的MInion本地的相关信息。（包含操作系统版本、内核版本、CPU、内存、硬盘、设备型号等）</p>
<p>备注：不重启minion，这些信息数据是不会改变的。</p>
<p> 1)信息管理，包括资产管理</p>
<p> eg:</p>
<pre><code>salt  &apos;saltstack01&apos;  grains. ls   # 列出ID为saltstack01的主机，grains的所有key
salt  &apos; saltstack*&apos;  grains.items   # 列出主机的详细信息，可用于资产管理
salt  &apos;*&apos;  grains.item os   # 列出所有主机的系统版本
salt  &apos;*&apos;  grains.item fqdn_ip4   # 列出所有主机的IP地址
</code></pre><p>2)用于目标选择（查询具体id的主机，查询系统版本为centos的主机等场景）</p>
<p>eg:</p>
<pre><code>salt -G  &apos;os:Centos&apos;  test . ping   # 所有主机系统为centos版本ping测试
salt -G  &apos;os:Centos&apos;  cmd.run  &apos;echo 123&apos;   # 所有主机系统为centos版本执行命令&apos;echo 123&apos;
</code></pre><p>3)配置管理中使用</p>
<p>自定义grains的item</p>
<p>方式一：修改配置文件 vim /etc/salt/minion</p>
<p> 重启：systemctl restart salt-minion</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-18.png" alt="2-18"></p>
<p>通过自定义的item，可以实现重启所有角色为apache的主机</p>
<pre><code>salt  &apos;*&apos;  grains.item roles   # 获取所有主机的roles
salt -G  &apos;roles:apache&apos;  cmd.run  &apos;systemctl restart httpd&apos;   # 所有主机roles为apache的执行命令systemctl restart httpd
</code></pre><p>方式二：（生产环境使用）</p>
<p>修改配置文件 vim /etc/salt/grains，写法</p>
<pre><code>cloud: openstack
</code></pre><p>重启:</p>
<pre><code>systemctl restart salt-minion
salt  &apos;*&apos;  grains.item cloud   # 获取所有主机的cloud
</code></pre><p>修改/etc/salt/grains不重启服务的方法，刷新命令如下（备注：方式一和方式二修改配置文件，通过此命令都可以不用重启服务）</p>
<pre><code>salt &apos;*&apos; saltutil.sync_grains
</code></pre><p>3）grains在top file中的使用案例</p>
<pre><code>vim /srv/salt/top.sls
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-19.png" alt="2-19"></p>
<p>grains脚本目录，必须是base下创建_grains目录（如：/srv/salt/_grains）</p>
<p>创建一个python脚本在/srv/salt/_grains目录下</p>
<p>脚本名：my_grains.py</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-20.png" alt="2-20"></p>
<p>通过master同步脚本文件至每台minion</p>
<pre><code>salt &apos;*&apos; saltutil.sync_grains
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-21.png" alt="2-21"></p>
<p>文件放在minion主机的/var/cache/salt/minion/extmods/grains目录下</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-22.png" alt="2-22"></p>
<pre><code>salt  &apos;*&apos;  grains.item edu   # 获取所有主机的edu
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-23.png" alt="2-23"></p>
<p>grains优先级（item名称相同的情况下）： </p>
<ul>
<li>系统自带 </li>
<li>grains文件写到 </li>
<li>minion配置文件写的</li>
<li>自己写的脚本</li>
</ul>
<h2 id="Pillar"><a href="#Pillar" class="headerlink" title="Pillar"></a>Pillar</h2><p>动态数据，给特定的minion指定特定的数据。只有指定的minion自己能看到自己的数据。</p>
<pre><code>salt  &apos;*&apos;  pillar.items
</code></pre><p>开启系统自带，修改配置文件</p>
<pre><code>vim /etc/salt/master
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-24.png" alt="2-24"></p>
<p>重启systemctl restart salt-master</p>
<p>执行salt ‘*’ pillar.items 可以看到系统自带的item</p>
<p>piller存在文件路径设置</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-25.png" alt="2-25"></p>
<pre><code>mkdir /srv/pillar
</code></pre><p>重启systemctl restart salt-master</p>
<p>实现pillar流程</p>
<p>1）创建一个piller文件，python jinja2写法</p>
<pre><code>mkdir  /srv/pillar/web
cd  /srv/pillar/web
vim apache.sls
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-26.png" alt="2-26"></p>
<p>2）创建top file文件</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-27.png" alt="2-27"></p>
<pre><code>salt  &apos;*&apos;  saltutil.refresh_pillar   # 刷新
salt  &apos;*&apos;  pillar.items apache
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-28.png" alt="2-28"></p>
<p>目标选择</p>
<pre><code>salt -I  &apos;apache:httpd&apos;  test . ping
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-29.png" alt="2-29"></p>
<h2 id="Grains-VS-Pillar"><a href="#Grains-VS-Pillar" class="headerlink" title="Grains VS Pillar"></a>Grains VS Pillar</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-30.png" alt="2-30"></p>
<h1 id="深入学习saltstack远程执行"><a href="#深入学习saltstack远程执行" class="headerlink" title="深入学习saltstack远程执行"></a>深入学习saltstack远程执行</h1><p>语法例： salt ‘*’ cmd.run ‘w’</p>
<p>命令：  salt</p>
<p>目标： ‘*’</p>
<p>模块： cmd.run  自带150+模块。  自己写模块</p>
<p>返回： 执行后结果返回，Returnners</p>
<h2 id="目标：Targeting"><a href="#目标：Targeting" class="headerlink" title="目标：Targeting"></a>目标：Targeting</h2><p>两种：一种和Minion　ID有关</p>
<p>　　　一种和Minion　ID无关</p>
<p>1)Minion ID有关的方法</p>
<p> 指定具体的minion ID    </p>
<pre><code>salt &apos;saltstack01&apos; test.ping
</code></pre><p> 通配符</p>
<pre><code>salt  &apos;*&apos;  test . ping 
salt  &apos;saltstack *&apos;  test . ping
salt  &apos; saltstack[1|2]&apos;  test . ping
salt  &apos; saltstack[1-2]&apos;  test . ping
salt  &apos; saltstack[!2]&apos;  test . ping
salt  &apos; saltstack?&apos;  test . ping
</code></pre><p> 列表</p>
<pre><code>salt -L  &apos;saltstack01 ,saltstack02 &apos;  test . ping
</code></pre><p> 正则表达式</p>
<pre><code>salt -E &apos;saltstack(01|02)&apos; test.ping
salt -E &apos;saltstack(01|02)*&apos; test.ping
</code></pre><p>备注: 所有匹配目标的方式，都可以用到top file里面来指定目标。minion ID设置方案：IP地址、根据业务来进行设置</p>
<p>eg:</p>
<pre><code>redis-node1-redis04-idc04-h5web.example.com
redis-node1   # redis第一个节点
redis04   # 集群
idc04   # 机房
h5web   # 业务线
</code></pre><p> 2）minion ID无关的方法</p>
<p>   IP地址、子网</p>
<pre><code>salt -S 192.168.16.100 test.ping
salt -S 192.168.16.0/24 test.ping
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-31.png" alt="2-31"></p>
<p>分组，需要配置master文件</p>
<pre><code>vim  /etc/salt/master
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-32.png" alt="2-32"></p>
<p>重启systemctl restart salt-master</p>
<p>混合匹配</p>
<p>具体内容查看<a href="https://docs.saltstack.com/en/latest/topics/targeting/compound.html" target="_blank" rel="external">官方文档</a></p>
<p> 批处理</p>
<p> 可用于重启所有主机或进程场景，百分比或固定数量的一点一点重启主机或进程</p>
<p> 具体内容查看<a href="https://docs.saltstack.com/en/latest/topics/targeting/batch.html" target="_blank" rel="external">官方文档</a></p>
<h1 id="执行模块"><a href="#执行模块" class="headerlink" title="执行模块"></a>执行模块</h1><p>具体内容查看<a href="https://docs.saltstack.com/en/latest/ref/modules/all/index.html#all-salt-modules" target="_blank" rel="external">官方文档</a></p>
<p>列出salt所有模块，以及如何使用的帮助文档</p>
<p>通过yum默认安装salt所有模块存放路径 /usr/lib/python2.7/site-packages/salt/modules（centos 7）</p>
<p>eg:</p>
<pre><code>salt  &apos;*&apos;  network.active_tcp   # 列出所有主机运行的tcp连接
salt  &apos;*&apos;  network.arp   # 列出所有主机arp
salt  &apos;*&apos;  service.available sshd   # 列出所有主机sshd
salt  &apos;*&apos;  service.get_all   # 列出所有主机的所有运行服务
salt  &apos;*&apos;  service.status sshd   # 列出所有主机sshd运行状态
salt- cp  &apos;*&apos;  /etc/hosts  /tmp/test   # 将master上/etc/hosts文件拷贝到所有主机的/tmp/test 
salt  &apos;*&apos;  state.show_top   # 查看top
salt  &apos;*&apos;  state.single pkg.installed name= lsof   # 所有主机安装lsof
</code></pre><h1 id="编写执行模块"><a href="#编写执行模块" class="headerlink" title="编写执行模块"></a>编写执行模块</h1><h2 id="放置路径"><a href="#放置路径" class="headerlink" title="放置路径"></a>放置路径</h2><pre><code>cd  /srv/salt
mkdir  _modules
</code></pre><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>文件名就是模块名</p>
<p>eg:</p>
<pre><code> my_disk.py

vim  /srv/salt/_modules/my_disk .py
def list():
     cmd =  &apos;df -h&apos;
     ret = __salt__[ &apos;cmd.run&apos; ](cmd)
     return  ret
</code></pre><h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><pre><code>salt  &apos;*&apos;  saltutil.sync_modules
</code></pre><p> <img src="http://opnq5yeqm.bkt.clouddn.com/2-33.png" alt="2-33"></p>
<p> 会放到指定目标的/var/cache/salt/minion下:</p>
<p> <img src="http://opnq5yeqm.bkt.clouddn.com/2-34.png" alt="2-34"></p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><pre><code>salt  &apos;*&apos;  my_disk.list
</code></pre><p> <img src="http://opnq5yeqm.bkt.clouddn.com/2-35.png" alt="2-35"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;saltstack简介&quot;&gt;&lt;a href=&quot;#saltstack简介&quot; class=&quot;headerlink&quot; title=&quot;saltstack简介&quot;&gt;&lt;/a&gt;saltstack简介&lt;/h1&gt;&lt;p&gt;（1）saltstack介绍&lt;/p&gt;
&lt;p&gt;SaltStack是一个
    
    </summary>
    
      <category term="运维技能" scheme="http://yjscloud.com/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Linux技术" scheme="http://yjscloud.com/tags/Linux%E6%8A%80%E6%9C%AF/"/>
    
      <category term="saltstack" scheme="http://yjscloud.com/tags/saltstack/"/>
    
  </entry>
  
  <entry>
    <title>cobbler实践指南</title>
    <link href="http://yjscloud.com/2018/03/01/cobbler%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"/>
    <id>http://yjscloud.com/2018/03/01/cobbler实践指南/</id>
    <published>2018-03-01T01:48:05.000Z</published>
    <updated>2018-03-01T04:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cobbler简介"><a href="#cobbler简介" class="headerlink" title="cobbler简介"></a>cobbler简介</h1><h2 id="cobbler介绍"><a href="#cobbler介绍" class="headerlink" title="cobbler介绍"></a>cobbler介绍</h2><p>Cobbler是一个Linux服务器安装的服务，可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理DHCP，DNS等。</p>
<p>Cobbler可以使用命令行方式管理，也提供了基于Web的界面管理工具(cobbler-web)，还提供了API接口，可以方便二次开发使用。</p>
<p>Cobbler是较早前的kickstart的升级版，优点是比较容易配置，还自带web界面比较易于管理。</p>
<p>Cobbler内置了一个轻量级配置管理系统，但它也支持和其它配置管理系统集成，如Puppet，暂时不支持SaltStack。</p>
<h2 id="cobbler集成的服务"><a href="#cobbler集成的服务" class="headerlink" title="cobbler集成的服务"></a>cobbler集成的服务</h2><ul>
<li>PXE服务支持</li>
<li>DHCP服务管理</li>
<li>DNS服务管理(可选bind,dnsmasq)</li>
<li>电源管理</li>
<li>Kickstart服务支持</li>
<li>YUM仓库管理</li>
<li>TFTP(PXE启动时需要)</li>
<li>Apache(提供kickstart的安装源，并提供定制化的kickstart配置）</li>
</ul>
<h1 id="cobbler部署"><a href="#cobbler部署" class="headerlink" title="cobbler部署"></a>cobbler部署</h1><p>cobbler服务器基本设置：CentOS7最小化安装，关闭防火墙，selinux设置为disabled，虚拟机网卡这里为桥接模式</p>
<h2 id="安装EPEL源"><a href="#安装EPEL源" class="headerlink" title="安装EPEL源"></a>安装EPEL源</h2><pre><code>rpm -ivh http://mirrors.kernel.org/fedora-epel/7/x86_64/e/epel-release-7-10.noarch.rpm
yum repolist
</code></pre><h2 id="yum安装cobbler"><a href="#yum安装cobbler" class="headerlink" title="yum安装cobbler"></a>yum安装cobbler</h2><pre><code>yum install -y httpd dhcp tftp cobbler cobbler-web pykickstart
</code></pre><p>用命令（rpm -ql cobbler）查看安装的文件，下面列出部分。</p>
<p>配置文件目录 /etc/cobbler</p>
<pre><code>/etc/cobbler                  # 配置文件目录
/etc/cobbler/settings         # cobbler主配置文件，这个文件是YAML格式，Cobbler是python写的程序。
/etc/cobbler/dhcp.template    # DHCP服务的配置模板
/etc/cobbler/tftpd.template   # tftp服务的配置模板
/etc/cobbler/rsync.template   # rsync服务的配置模板
/etc/cobbler/iso              # iso模板配置文件目录
/etc/cobbler/pxe              # pxe模板文件目录/etc/cobbler/power            # 电源的配置文件目录
/etc/cobbler/users.conf       # Web服务授权配置文件
/etc/cobbler/users.digest     # 用于web访问的用户名密码配置文件
/etc/cobbler/dnsmasq.template # DNS服务的配置模板
/etc/cobbler/modules.conf     # Cobbler模块配置文件
</code></pre><p> 数据目录</p>
<pre><code>/var/lib/cobbler              # Cobbler数据目录
/var/lib/cobbler/config       # 用于存放distros,system,profiles等信息配置文件
/var/lib/cobbler/kickstarts   # 默认存放kickstart文件
/var/lib/cobbler/loaders      # 存放的各种引导程序
</code></pre><p> 镜像目录</p>
<pre><code>/var/www/cobbler              # 系统安装镜像目录
/var/www/cobbler/ks_mirror    # 导入的发行版系统的所有数据
/var/www/cobbler/images       # 导入发行版的kernel和initrd镜像用于远程网络启动
/var/www/cobbler/repo_mirror  # yum源存储目录
</code></pre><p> 日志目录</p>
<pre><code>/var/log/cobbler              # 日志目录
/var/log/cobbler/install.log  # 客户端系统安装日志
/var/log/cobbler/cobbler.log  # cobbler日志
</code></pre><h2 id="启动并检测cobbler"><a href="#启动并检测cobbler" class="headerlink" title="启动并检测cobbler"></a>启动并检测cobbler</h2><pre><code>systemctl start httpd
systemctl enable httpd
systemctl start cobblerd
systemctl enable cobblerd
cobbler check
</code></pre><p>附加解析：</p>
<pre><code>cobbler check 核对当前设置是否有问题
cobbler list 列出所有的cobbler元素
cobbler report 列出元素的详细信息
cobbler sync 同步配置到数据目录,更改配置最好都要执行下
cobbler reposync 同步yum仓库
cobbler distro 查看导入的发行版系统信息
cobbler system 查看添加的系统信息
cobbler profile 查看配置信息
</code></pre><h2 id="修改cobbler主配置文件"><a href="#修改cobbler主配置文件" class="headerlink" title="修改cobbler主配置文件"></a>修改cobbler主配置文件</h2><pre><code>vim /etc/cobbler/settings
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-1.png" alt="1-1"></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-2.png" alt="1-2"></p>
<h2 id="保证xinetd服务为开机自动启动状态"><a href="#保证xinetd服务为开机自动启动状态" class="headerlink" title="保证xinetd服务为开机自动启动状态"></a>保证xinetd服务为开机自动启动状态</h2><pre><code>vim /etc/xinetd.d/tftp
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-3.png" alt="1-3"></p>
<h2 id="启动rsyncd服务"><a href="#启动rsyncd服务" class="headerlink" title="启动rsyncd服务"></a>启动rsyncd服务</h2><pre><code>systemctl start rsyncd
cobbler get-loaders
</code></pre><h2 id="生成cobbler安装系统root初始密码"><a href="#生成cobbler安装系统root初始密码" class="headerlink" title="生成cobbler安装系统root初始密码"></a>生成cobbler安装系统root初始密码</h2><pre><code>openssl passwd -1 -salt &apos;cobler&apos; &apos;cobler&apos;
$1$cobler$XJnisBweZJlhL651HxAM00
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-4.png" alt="1-4"></p>
<h2 id="将上面的加密串加入cobbler配置文件中"><a href="#将上面的加密串加入cobbler配置文件中" class="headerlink" title="将上面的加密串加入cobbler配置文件中"></a>将上面的加密串加入cobbler配置文件中</h2><pre><code>vim /etc/cobbler/settings
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-5.png" alt="1-5"></p>
<h2 id="重启cobblerd服务："><a href="#重启cobblerd服务：" class="headerlink" title="重启cobblerd服务："></a>重启cobblerd服务：</h2><pre><code>systemctl restart cobblerd
cobbler check
</code></pre><h2 id="让cobblerd管理dhcp"><a href="#让cobblerd管理dhcp" class="headerlink" title="让cobblerd管理dhcp"></a>让cobblerd管理dhcp</h2><pre><code>vim /etc/cobbler/settings
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-6.png" alt="1-6"></p>
<h2 id="修改dhcp模板文件："><a href="#修改dhcp模板文件：" class="headerlink" title="修改dhcp模板文件："></a>修改dhcp模板文件：</h2><pre><code>vim /etc/cobbler/dhcp.template
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-7.png" alt="1-7"></p>
<h2 id="重启cobblerd"><a href="#重启cobblerd" class="headerlink" title="重启cobblerd"></a>重启cobblerd</h2><pre><code>systemctl restart cobblerd
</code></pre><p>同步：</p>
<pre><code>cobbler sync
</code></pre><h2 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-8.png" alt="1-8"></p>
<pre><code>mount /dev/cdrom /mnt
cobbler import --path=/mnt/ --name=CentOS-7-x86_64 --arch=x86_64
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-9.png" alt="1-9"></p>
<p>导入centos6的步骤在这里略去！</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-10.png" alt="1-10"></p>
<p>CentOS-6-x86_64.cfg配置文件：</p>
<pre><code># Kickstart file automatically generated by anaconda.

#version=DEVEL

install  #表示是安装，而不是升级

text #文本方式安装

cdrom #安装方式，如果是网络安装的话可以写成 url ––url ftp://192.168.1.254/dir 或者 nfs --server=192.168.0.241 --dir=/centosinstall

key –skip #这个是我另外添加的，如果是RedHat的系统，会要求输入key，这里配置为跳过，如果不配置安装时会停在那里要求用户输入key

lang en_US.UTF-8  #语言

keyboard us #键盘样式

network --onboot no --device eth0 --noipv4 --noipv6 #网络配置 配置具体参数样例：network –onboot yes --bootproto=static --ip=192.168.1.1 --netmask=255.255.255.0 其他网关，DNS等格式和ifcfg-ethx的方式一样

rootpw  --iscrypted $6$PEJ49S7OkrNra3UM #管理员密码，是加密过的 要是使用不加密的方式则这样写：rootpw 123456

firewall --service=ssh #开启防火墙，并打开ssh端口

authconfig --enableshadow --passalgo=sha512 #用户认证和密码加密方式

selinux --enforcing #强制打开selinux

timezone --utc Etc/GMT+8 #时区设置

zerombr yes #清空磁盘的mbr

bootloader --location=mbr --driveorder=sda #引导程序相关参数

# The following is the partition information you requested
# Note that any partitions you deleted are not expressed
# here so unless you clear all partitions first, this is
# not guaranteed to work

clearpart –all –initlabel #初始化磁盘

part / --fstype=ext4 --size=18000 #开始分区
part swap --grow --size=1024
repo --name=&quot;CentOS&quot;  --baseurl=cdrom:sr0 --cost=100

reboot


%packages --nobase #安装的软件包，这里由于我安装的是最小mini版，所以只安装了核心软件包组
@core


%post #后安装脚本（这里是我另外添加的，原来文件中没有）
id lustlost &amp;&gt;; /dev/null || useradd lustlost #检查是否有lustlost用户，如果没有则添加
echo 123456 | passwd –stdin lustlost #配置密码

cat &gt;&gt; /etc/yum.repos.d/base.repo &lt;&lt; eof
[base]
name=baseserver
baseurl=http://192.168.1.254/yum
gpgcheck=0
enable=1
eof                                 #这里在安装系统成功后执行脚本自动配置一个yum源,其他脚本可以按照需要定义

%end
</code></pre><p>CentOS-7-x86_64.cfg配置文件：</p>
<pre><code># Cobbler for Kickstart Configurator for CentOS 7 by clsn
install
url --url=$tree
text
lang en_US.UTF-8
keyboard us
zerombr
bootloader --location=mbr --driveorder=sda --append=&quot;crashkernel=auto rhgb quiet&quot;
#Network information
$SNIPPET(&apos;network_config&apos;)
#network --bootproto=dhcp --device=eth0 --onboot=yes --noipv6 --    hostname=CentOS7
timezone --utc Asia/Shanghai
authconfig --enableshadow --passalgo=sha512
rootpw  --iscrypted $default_password_crypted
clearpart --all --initlabel
part /boot --fstype xfs --size 1024
part swap --size 1024
part / --fstype xfs --size 1 --grow
firstboot --disable
selinux --disabled
firewall --disabled
logging --level=info
reboot

%pre
$SNIPPET(&apos;log_ks_pre&apos;)
$SNIPPET(&apos;kickstart_start&apos;)
$SNIPPET(&apos;pre_install_network_config&apos;)
# Enable installation monitoring
$SNIPPET(&apos;pre_anamon&apos;)
%end

%packages
@^minimal
@compat-libraries
@core
@debugging
@development
bash-completion
chrony
dos2unix
kexec-tools
lrzsz
nmap
sysstat
telnet
tree
vim
wget
%end

%post
systemctl disable postfix.service

$yum_config_stanza
%end
</code></pre><p>上传配置文件到/var/lib/cobbler/kickstarts目录下</p>
<p>修改自定义配置文件：</p>
<pre><code>cobbler profile edit --name=CentOS-7-x86_64 --kickstart=/var/lib/cobbler/kickstarts/CentOS-7-x86_64.cfg
cobbler profile edit --name=CentOS-6-x86_64 --kickstart=/var/lib/cobbler/kickstarts/CentOS-6-x86_64.cfg
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-11.png" alt="1-11">    </p>
<p>定义自动化安装时centos7的网卡信息文件（自动生成eth1,eth2）</p>
<pre><code>cobbler profile edit --name=CentOS-7-x86_64 --kopts=&apos;net.ifnames=O biosdevname=O&apos;
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-12.png" alt="1-12"></p>
<p>cobbler sync #使修改的配置文件生效</p>
<p>然后随便添加一台虚拟机，开机！</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-13.png" alt="1-13">    </p>
<p>cobbler服务器端查看日志</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-14.png" alt="1-14"></p>
<p>（14）安装xinetd</p>
<pre><code>yum -y install xinetd
systemctl start xinetd
</code></pre><p>安装好后就会可以选择安装centos版本，选择对应版本后就会自动执行安装程序！</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-15.png" alt="1-15"><br><img src="http://opnq5yeqm.bkt.clouddn.com/1-16.png" alt="1-16">    </p>
<h1 id="自动重装和cobbler-web"><a href="#自动重装和cobbler-web" class="headerlink" title="自动重装和cobbler-web"></a>自动重装和cobbler-web</h1><h2 id="安装koan"><a href="#安装koan" class="headerlink" title="安装koan"></a>安装koan</h2><pre><code>yum -y install koan
</code></pre><p>查看可以重装的系统：</p>
<pre><code>koan --server=192.168.0.100 --list=profiles    
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-17.png" alt="1-17">    </p>
<h2 id="指定要重装成centos6："><a href="#指定要重装成centos6：" class="headerlink" title="指定要重装成centos6："></a>指定要重装成centos6：</h2><pre><code>koan --replace-self --server=192.168.0.100 --profile=CentOS-6-x86_64
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-18.png" alt="1-18"></p>
<h2 id="通过web访问cobbler"><a href="#通过web访问cobbler" class="headerlink" title="通过web访问cobbler"></a>通过web访问cobbler</h2><p>在浏览器输入：<a href="https://192.168.0.100/cobbler_web，用户名和密码都是默认的cobbler" target="_blank" rel="external">https://192.168.0.100/cobbler_web，用户名和密码都是默认的cobbler</a></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-19.png" alt="1-19"></p>
<h2 id="cobbler修改密码"><a href="#cobbler修改密码" class="headerlink" title="cobbler修改密码"></a>cobbler修改密码</h2><pre><code>htdigest /etc/cobbler/users.digest &quot;Cobbler&quot; cobbler
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-20.png" alt="1-20"></p>
<p>所有操作都可在web界面进行</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-21.png" alt="1-21"><br><img src="http://opnq5yeqm.bkt.clouddn.com/1-22.png" alt="1-22"></p>
<h2 id="修改提示信息的选单"><a href="#修改提示信息的选单" class="headerlink" title="修改提示信息的选单"></a>修改提示信息的选单</h2><pre><code>vim /etc/cobbler/pxe/pxedefault.template
</code></pre><p>修改前:</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-23.png" alt="1-23"></p>
<p>修改后：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-24.png" alt="1-24"></p>
<p>然后执行命令：cobbler sync</p>
<p>新建一台虚拟机查看效果：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-25.png" alt="1-25"></p>
<h1 id="cobbler自定义yum源"><a href="#cobbler自定义yum源" class="headerlink" title="cobbler自定义yum源"></a>cobbler自定义yum源</h1><h2 id="添加repo"><a href="#添加repo" class="headerlink" title="添加repo"></a>添加repo</h2><pre><code>cobbler repo add --name=openstack-ocata --mirror=http://192.168.0.5:8080/openstack-ocata/ --arch=x86_64 --breed=yum
</code></pre><p>注：<a href="http://192.168.0.5:8080/openstack-ocata/为我本地搭建的本地yum源" target="_blank" rel="external">http://192.168.0.5:8080/openstack-ocata/为我本地搭建的本地yum源</a></p>
<h2 id="同步repo"><a href="#同步repo" class="headerlink" title="同步repo"></a>同步repo</h2><pre><code>cobbler reposync
</code></pre><h2 id="添加repo到对应的repolist"><a href="#添加repo到对应的repolist" class="headerlink" title="添加repo到对应的repolist"></a>添加repo到对应的repolist</h2><pre><code>cobbler profile edit --name=CentOS-7-x86_64 --repos=&quot;openstack-ocata&quot;
</code></pre><h2 id="修改kicstart文件"><a href="#修改kicstart文件" class="headerlink" title="修改kicstart文件"></a>修改kicstart文件</h2><pre><code>%post
systemctl disable postfix.service

$yum_config_stanza
%end
</code></pre><h2 id="添加定时任务，定期同步repo"><a href="#添加定时任务，定期同步repo" class="headerlink" title="添加定时任务，定期同步repo"></a>添加定时任务，定期同步repo</h2><pre><code>echo &quot;1 3 * * * /usr/bin/cobbler reposync --tries=3 --no-fail&quot; &gt;&gt; /var/spool/cron/root
</code></pre><h1 id="cobbler自定义系统安装"><a href="#cobbler自定义系统安装" class="headerlink" title="cobbler自定义系统安装"></a>cobbler自定义系统安装</h1><h2 id="自动化装机平台基本信息"><a href="#自动化装机平台基本信息" class="headerlink" title="自动化装机平台基本信息"></a>自动化装机平台基本信息</h2><p>mac地址：00:50:56:3E:3D:06</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-26.png" alt="1-26"></p>
<p>主机名：cobbler-test03<br>IP：192.168.0.111<br>掩码：255.255.255.0<br>网关：192.168.0.1<br>DNS：192.168.0.1</p>
<h2 id="执行安装的命令"><a href="#执行安装的命令" class="headerlink" title="执行安装的命令"></a>执行安装的命令</h2><pre><code>cobbler system add --name=cobbler-test03 --mac=00:50:56:3E:3D:06 --profile=CentOS-7-x86_64 \
--ip-address=192.168.0.111 --subnet=255.255.255.0 --gateway=192.168.0.1 --intterface=eth0 \
--static=1 --hostname=cobbler-test03 --name-servers=&quot;192.168.0.1&quot; \
--kickstart=/var/lib/cobbler/kickstarts/CentOS-7-x86_64.cfg
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-27.png" alt="1-27"></p>
<p>同步：cobbler sync</p>
<p>启动虚拟机跳过选择界面自动安装：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-28.png" alt="1-28"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;cobbler简介&quot;&gt;&lt;a href=&quot;#cobbler简介&quot; class=&quot;headerlink&quot; title=&quot;cobbler简介&quot;&gt;&lt;/a&gt;cobbler简介&lt;/h1&gt;&lt;h2 id=&quot;cobbler介绍&quot;&gt;&lt;a href=&quot;#cobbler介绍&quot; class
    
    </summary>
    
      <category term="运维技能" scheme="http://yjscloud.com/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Linux技术" scheme="http://yjscloud.com/tags/Linux%E6%8A%80%E6%9C%AF/"/>
    
      <category term="cobbler" scheme="http://yjscloud.com/tags/cobbler/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（十）：面向对象（基础篇）</title>
    <link href="http://yjscloud.com/2018/01/23/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>http://yjscloud.com/2018/01/23/Python当歌（十）：面向对象（基础篇）/</id>
    <published>2018-01-23T02:30:17.000Z</published>
    <updated>2018-02-08T10:27:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>（1）面向过程：根据业务逻辑从上到下写垒代码</p>
<p>（2）函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可</p>
<p>（3）面向对象：对函数进行分类和封装，让开发“更快更好更强…”</p>
<p>面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程中最常见的操作就是粘贴复制，即：将之前实现的代码块复制到现需功能处。</p>
<pre><code>while True：
    if cpu利用率 &gt; 90%:
        #发送邮件提醒
        连接邮箱服务器
        发送邮件
        关闭连接

    if 硬盘使用空间 &gt; 90%:
        #发送邮件提醒
        连接邮箱服务器
        发送邮件
        关闭连接

    if 内存占用 &gt; 80%:
        #发送邮件提醒
        连接邮箱服务器
        发送邮件
        关闭连接
</code></pre><p>随着时间的推移，开始使用了函数式编程，增强代码的重用性和可读性，就变成了这样：</p>
<pre><code>def 发送邮件(内容)
    #发送邮件提醒
    连接邮箱服务器
    发送邮件
    关闭连接

while True：

    if cpu利用率 &gt; 90%:
        发送邮件(&apos;CPU报警&apos;)

    if 硬盘使用空间 &gt; 90%:
        发送邮件(&apos;硬盘报警&apos;)

    if 内存占用 &gt; 80%:
        发送邮件(&apos;内存报警&apos;)
</code></pre><h1 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h1><p>面向对象编程是一种编程方式，此编程方式的落地需要使用 “类” 和 “对象” 来实现，所以，面向对象编程其实就是对 “类” 和 “对象” 的使用。</p>
<p>类就是一个模板，模板里可以包含多个函数，函数里实现一些功能</p>
<p>对象则是根据模板创建的实例，通过实例对象可以执行类中的函数</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-1.png" alt="10-1"></p>
<p>（1）class是关键字，表示类</p>
<p>（2）创建对象，类名称后加括号即可</p>
<p>ps：类中的函数第一个参数必须是self（详细见：类的三大特性之封装）<br>　　 类中定义的函数叫做 “方法”</p>
<pre><code># 创建类
class Foo:

    def Bar(self):
        print &apos;Bar&apos;

    def Hello(self, name):
        print &apos;i am %s&apos; %name

# 根据类Foo创建对象obj
obj = Foo()
obj.Bar()            #执行Bar方法
obj.Hello(‘Pan&apos;) #执行Hello方法　
</code></pre><h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><p>面向对象的三大特性是指：封装、继承和多态。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。要明确的区分内外,内部的实现逻辑，外部无法知晓，并且为封装到内部的逻辑提供一个访问接口给外部使用，类中定义私有的，只在类的内部使用，外部无法访问。所以，在使用面向对象的封装特性时，需要：</p>
<ul>
<li>将内容封装到某处</li>
<li>从某处调用被封装的内容</li>
</ul>
<p>第一步：将内容封装到某处</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-2.png" alt="10-2"></p>
<p>self 是一个形式参数，当执行 obj1 = Foo(‘Pan’, 18 ) 时，self 等于 obj1；</p>
<p>   当执行 obj2 = Foo(‘xwq’, 78 ) 时，self 等于 obj2</p>
<p>所以，内容其实被封装到了对象 obj1 和 obj2 中，每个对象中都有 name 和 age 属性，在内存里类似于下图来保存。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-3.png" alt="10-3"></p>
<p>第二步：从某处调用被封装的内容</p>
<p>调用被封装的内容时，有两种情况：</p>
<ul>
<li>通过对象直接调用</li>
<li>通过self间接调用</li>
</ul>
<p>（1）通过对象直接调用被封装的内容</p>
<p>上图展示了对象 obj1 和 obj2 在内存中保存的方式，根据保存格式可以如此调用被封装的内容：对象.属性名</p>
<pre><code>class Foo:

    def __init__(self, name, age):
        self.name = name
        self.age = age

obj1 = Foo(&apos;Pan&apos;, 18)
print obj1.name    # 直接调用obj1对象的name属性
print obj1.age     # 直接调用obj1对象的age属性

obj2 = Foo(&apos;xwq&apos;, 19)
print obj2.name    # 直接调用obj2对象的name属性
print obj2.age     # 直接调用obj2对象的age属性
</code></pre><p>（2）通过self间接调用被封装的内容</p>
<p>执行类中的方法时，需要通过self间接调用被封装的内容</p>
<pre><code>class Foo:

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def detail(self):
        print self.name
        print self.age

obj1 = Foo(&apos;Pan&apos;, 18)
obj1.detail()  # Python默认会将obj1传给self参数，即：obj1.detail(obj1)，所以，此时方法内部的 self ＝ obj1，即：self.name 是 Pan ；self.age 是 18

obj2 = Foo(&apos;xwq&apos;, 73)
obj2.detail()  # Python默认会将obj2传给self参数，即：obj1.detail(obj2)，所以，此时方法内部的 self ＝ obj2，即：self.name 是 xwq ； self.age 是 78
</code></pre><p>综上所述，对于面向对象的封装来说，其实就是使用构造方法将内容封装到对象 中，然后通过对象直接或者self间接获取被封装的内容。</p>
<p>（3）如何隐藏类的内部属性</p>
<p>在python中用双下划线开头的方式将属性隐藏起来（设置成私有的），其实这仅仅这是一种变形操作且仅仅只在类定义阶段发生变形，类中所有双下划线开头的名称如<strong>x都会在类定义时自动变形成：_类名</strong>x的形式：</p>
<pre><code>class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self):
        self.__X=10 #变形为self._A__X
    def __foo(self): #变形为_A__foo
        print(&apos;from A&apos;)
    def bar(self):
        self.__foo() #只有在类内部才可以通过__foo的形式访问到.

 #A._A__N是可以访问到的，这种，在外部是无法通过__x这个名字访问到。
</code></pre><p>这种变形需要注意的问题是：</p>
<p>1.这种机制也并没有真正意义上限制我们从外部直接访问属性，知道了类名和属性名就可以拼出名字：_类名<strong>属性，然后就可以访问了，如a._A</strong>N，即这种操作并不是严格意义上的限制外部访问，仅仅只是一种语法意义上的变形，主要用来限制外部的直接访问。</p>
<p>2.变形的过程只在类的定义时发生一次,在定义后的赋值操作，不会变形</p>
<p>3.在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-4.png" alt="10-4"></p>
<p>（4）封装不是单纯意义的隐藏</p>
<p>1：封装数据：将数据隐藏起来这不是目的。隐藏起来然后对外提供操作该数据的接口，然后我们可以在接口附加上对该数据操作的限制，以此完成对数据属性操作的严格控制。</p>
<pre><code>class Teacher:
    def __init__(self,name,age):
        # self.__name=name
        # self.__age=age
        self.set_info(name,age)

    def tell_info(self):
        print(&apos;姓名:%s,年龄:%s&apos; %(self.__name,self.__age))
    def set_info(self,name,age):
        if not isinstance(name,str):
            raise TypeError(&apos;姓名必须是字符串类型&apos;)
        if not isinstance(age,int):
            raise TypeError(&apos;年龄必须是整型&apos;)
        self.__name=name
        self.__age=age


t=Teacher(&apos;egon&apos;,18)
t.tell_info()

t.set_info(&apos;egon&apos;,19)
t.tell_info()
</code></pre><p>2：封装方法：目的是隔离复杂度</p>
<p>取款是功能,而这个功能有很多功能组成:插卡、密码认证、输入金额、打印账单、取钱。对使用者来说,只需要知道取款这个功能即可,其余功能我们都可以隐藏起来,很明显这么做。隔离了复杂度,同时也提升了安全性</p>
<pre><code>class ATM:
    def __card(self):
        print(&apos;插卡&apos;)
    def __auth(self):
        print(&apos;用户认证&apos;)
    def __input(self):
        print(&apos;输入取款金额&apos;)
    def __print_bill(self):
        print(&apos;打印账单&apos;)
    def __take_money(self):
        print(&apos;取款&apos;)

    def withdraw(self):
        self.__card()
        self.__auth()
        self.__input()
        self.__print_bill()
        self.__take_money()

a=ATM()
a.withdraw()
</code></pre><p>（5）封装与扩展性</p>
<p>封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用用者只知道一个接口(函数)，只要接口（函数）名、参数不变，使用者的代码永远无需改变。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。</p>
<pre><code>#类的设计者
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    def tell_area(self): #对外提供的接口，隐藏了内部的实现细节，此时我们想求的是面积
        return self.__width * self.__length

#使用者
&gt;&gt;&gt; r1=Room(&apos;卧室&apos;,&apos;egon&apos;,20,20,20)
&gt;&gt;&gt; r1.tell_area() #使用者调用接口tell_area


#类的设计者，轻松的扩展了功能，而类的使用者完全不需要改变自己的代码
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    def tell_area(self): #对外提供的接口，隐藏内部实现，此时我们想求的是体积,内部逻辑变了,只需求修该下列一行就可以很简答的实现,而且外部调用感知不到,仍然使用该方法，但是功能已经变了

       return self.__width * self.__length * self.__high

#对于仍然在使用tell_area接口的人来说，根本无需改动自己的代码，就可以用上新功能
&gt;&gt;&gt; r1.tell_area()
</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容。</p>
<p>例如：<br>　　<br>　　猫可以：喵喵叫、吃、喝、拉、撒</p>
<p>狗可以：汪汪叫、吃、喝、拉、撒</p>
<p>如果我们要分别为猫和狗创建一个类，那么就需要为 猫 和 狗 实现他们所有的功能，如下所示：</p>
<pre><code>(伪代码)
class cat：

    def cat_mews(self):
        print (‘喵喵叫’)

    def eat(self):
        # do something

    def drink(self):
        # do something

    def pull(self):
        # do something

    def cast(self):
        # do something

class dog：

    def bark(self):
        print (‘汪汪叫’)

    def eat(self):
        # do something

    def drink(self):
        # do something

    def pull(self):
        # do something

    def cast(self):
        # do something
</code></pre><p>上述代码不难看出，吃、喝、拉、撒是猫和狗都具有的功能，而我们却分别的猫和狗的类中编写了两次。如果使用 继承 的思想，如下实现：</p>
<p>　　动物：吃、喝、拉、撒</p>
<p>　　   猫：喵喵叫（猫继承动物的功能）</p>
<p>　　   狗：汪汪叫（狗继承动物的功能）</p>
<pre><code>（伪代码）
class animal:

    def eat(self):
        # do something

    def drink(self):
        # do something

    def pull(self):
        # do something

    def cast(self):
        # do something

# 在类后面括号中写入另外一个类名，表示当前类继承另外一个类

class cat(animal)：

    def cat_mews(self):
        print &apos;喵喵叫&apos;

# 在类后面括号中写入另外一个类名，表示当前类继承另外一个类
class dog(animal)：

    def bark(self):
        print &apos;汪汪叫&apos;

（代码实现）
class Animal:
    def eat(self):
        print(&apos;%s eat&apos;%(self.name))

    def drink(self):
        print(&apos;%s drink&apos; %(self.name))

    def shit(self):
        print(&apos;%s pull&apos; %(self.name))

    def pee(self):
        print(&apos;%s cast&apos; %(self.name))


class Cat(Animal):
    def __init__(self, name):
        self.name = name
        self.breed = &apos;猫&apos;

    def cry(self):
        print(&apos;喵喵叫&apos;)


class Dog(Animal):
    def __init__(self, name):
        self.name = name
        self.breed = &apos;狗&apos;

    def cry(self):
        print(&apos;汪汪叫&apos;)
</code></pre><p># ######### 执行 #########</p>
<pre><code>c1 = Cat(&apos;小白家的小黑猫&apos;)
c1.eat()

c2 = Cat(&apos;小黑的小白猫&apos;)
c2.drink()

d1 = Dog(&apos;胖子家的小瘦狗&apos;)
d1.eat()
</code></pre><p>所以，对于面向对象的继承来说，其实就是将多个类共有的方法提取到父类中，子类仅需继承父类而不必一一实现每个方法。</p>
<p>注：除了子类和父类的称谓，你可能看到过 派生类 和 基类 ，他们与子类和父类只是叫法不同而已。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-5.png" alt="10-5"></p>
<p>那么问题又来了，多继承呢？</p>
<p>是否可以继承多个类</p>
<p>如果继承的多个类每个类中都定了相同的函数，那么那一个会被使用呢？</p>
<p>1、Python的类可以继承多个类，Java和C#中则只能继承一个类</p>
<p>2、Python的类如果继承了多个类，那么其寻找方法的方式有两种，分别是：深度优先和广度优先</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-6.png" alt="10-6"></p>
<p>当类是经典类时，多继承情况下，会按照深度优先方式查找</p>
<p>当类是新式类时，多继承情况下，会按照广度优先方式查找</p>
<p>经典类和新式类，从字面上可以看出一个老一个新，新的必然包含了跟多的功能，也是之后推荐的写法，从写法上区分的话，如果当前类或者父类继承了object类，那么该类便是新式类，否则便是经典类。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-7.png" alt="10-7"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-8.png" alt="10-8"></p>
<p>（经典类多继承）<br>class D:</p>
<pre><code>def bar(self):
    print (&apos;D.bar&apos;)
</code></pre><p>class C(D):</p>
<pre><code>def bar(self):
    print (&apos;C.bar&apos;)
</code></pre><p>class B(D):</p>
<pre><code>def bar(self):
    print (&apos;B.bar&apos;)
</code></pre><p>class A(B, C):</p>
<pre><code>def bar(self):
    print (&apos;A.bar&apos;)

a = A()
</code></pre><p>执行bar方法时首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错,所以，查找顺序：A –&gt; B –&gt; D –&gt; C。在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了a.bar()</p>
<pre><code>(新式类多继承)
class D(object):

    def bar(self):
        print (&apos;D.bar&apos;)

class C(D):

    def bar(self):
        print (&apos;C.bar&apos;)

class B(D):

    def bar(self):
        print (&apos;B.bar&apos;)

class A(B, C):

    def bar(self):
        print (&apos;A.bar&apos;)

a = A()
</code></pre><p>执行bar方法时，首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错，所以，查找顺序：A –&gt; B –&gt; C –&gt; D，在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了a.bar()</p>
<p>经典类：首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错</p>
<p>新式类：首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错</p>
<p>注意：在上述查找过程中，一旦找到，则寻找过程立即中断，便不会再继续找了</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>类的继承有两层意义：1、改变  2、扩展</p>
<p>多态就是类的这两层意义的一个具体的实现机制。即调用不同的类实例化的对象下的相同的方法，实现的过程不一样。python中的标准类型就是多态概念的一个很好的示范。</p>
<p>多态的概念指出了对象如何通过他们共同的属性和动作来操作及访问，而不需要考虑他们的具体的类。多态一定是反应在运行时的状态。</p>
<p>（1）理解多态</p>
<p>多态指的是一类事物有多种形态</p>
<p>动物有多种形态：人，狗，猪</p>
<pre><code>import abc
class Animal(metaclass=abc.ABCMeta): #同一类事物:动物
    @abc.abstractmethod
    def talk(self):
        pass

class People(Animal): #动物的形态之一:人
    def talk(self):
        print(&apos;say hello&apos;)

class Dog(Animal): #动物的形态之二:狗
    def talk(self):
        print(&apos;say wangwang&apos;)

class Pig(Animal): #动物的形态之三:猪
    def talk(self):
        print(&apos;say aoao&apos;)
</code></pre><p>文件有多种形态：文本文件，可执行文件</p>
<pre><code>import abc
class File(metaclass=abc.ABCMeta): #同一类事物:文件
    @abc.abstractmethod
    def click(self):
        pass

class Text(File): #文件的形态之一:文本文件
    def click(self):
        print(&apos;open file&apos;)

class ExeFile(File): #文件的形态之二:可执行文件
    def click(self):
        print(&apos;execute file&apos;)
</code></pre><p>（2）多态性</p>
<p>多态性是指在不考虑实例类型的情况下使用实例</p>
<p>在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p>
<p>比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同。</p>
<p>多态性分为静态多态性和动态多态性</p>
<p>静态多态性：如任何类型都可以用运算符+进行运算</p>
<p>动态多态性：如下</p>
<pre><code>peo=People()
dog=Dog()
pig=Pig()

#peo、dog、pig都是动物,只要是动物肯定有talk方法
#于是我们可以不用考虑它们三者的具体是什么类型,而直接使用
peo.talk()
dog.talk()
pig.talk()

#更进一步,我们可以定义一个统一的接口来使用
def func(obj):
    obj.talk()
</code></pre><p>（3）为什么要使用多态性</p>
<p>1.增加了程序的灵活性</p>
<p>以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal)</p>
<p>2.增加了程序额可扩展性</p>
<p>通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用</p>
<pre><code>class Cat(Animal): #属于动物的另外一种形态：猫
     def talk(self):
         print(&apos;say miao&apos;)

def func(animal): #对于使用者来说，自己的代码根本无需改动
     animal.talk()

cat1=Cat() #实例出一只猫
func(cat1) #甚至连调用方式也无需改变，就能调用猫的talk功能
</code></pre><p>这样我们新增了一个形态Cat，由Cat类产生的实例cat1，使用者可以在完全不需要修改自己代码的情况下。使用和人、狗、猪一样的方式调用cat1的talk方法，即func(cat1)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;（1）面向过程：根据业务逻辑从上到下写垒代码&lt;/p&gt;
&lt;p&gt;（2）函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可&lt;/p
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（九）：模块</title>
    <link href="http://yjscloud.com/2018/01/22/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9D%97/"/>
    <id>http://yjscloud.com/2018/01/22/Python当歌（九）：模块/</id>
    <published>2018-01-22T09:37:20.000Z</published>
    <updated>2018-02-07T11:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块-amp-包"><a href="#模块-amp-包" class="headerlink" title="模块&amp;包"></a>模块&amp;包</h1><h2 id="模块-modue-的概念："><a href="#模块-modue-的概念：" class="headerlink" title="模块(modue)的概念："></a>模块(modue)的概念：</h2><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</p>
<p>使用模块有什么好处？<br>最大的好处是大大提高了代码的可维护性。</p>
<p>其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。<br>所以，模块一共三种：</p>
<ul>
<li>python标准库</li>
<li>第三方模块</li>
<li>应用程序自定义模块</li>
</ul>
<p>另外，使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。</p>
<h2 id="模块导入方法"><a href="#模块导入方法" class="headerlink" title="模块导入方法"></a>模块导入方法</h2><p>（1）import语法</p>
<pre><code>import module1[, module2[,... moduleN]
</code></pre><p>（2）from…import语句</p>
<pre><code>from modname import name1[, name2[, ... nameN]]
</code></pre><p>（3）From…import* 语句</p>
<pre><code>from modname import *
</code></pre><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义</p>
<p>（4）运行本质</p>
<pre><code>import test
from test import add
</code></pre><p>无论1还是2，首先通过sys.path找到test.py,然后执行test脚本（全部执行），区别是1会将test这个变量名加载到名字空间，而2只会将add这个变量名加载进来。　</p>
<h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><p>如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p>
<p>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。</p>
<p>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-1.png" alt="9-1"></p>
<p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，view.py模块的名字就变成了hello_django.app01.views，类似的，manage.py的模块名则是hello_django.manage。</p>
<p>请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录(文件夹)，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是对应包的名字。</p>
<p>调用包就是执行包下的__init__.py文件</p>
<h2 id="注意点（important）"><a href="#注意点（important）" class="headerlink" title="注意点（important）"></a>注意点（important）</h2><p>1、——————-</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-2.png" alt="9-2"></p>
<p>在nod1里import  hello是找不到的，有同学说可以找到呀，那是因为你的pycharm为你把myapp这一层路径加入到了sys.path里面，所以可以找到，然而程序一旦在命令行运行，则报错。有同学问那怎么办？简单啊，自己把这个路径加进去不就OK啦：</p>
<pre><code>import sys,os
BASE_DIR=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(BASE_DIR)
import hello
hello.hello1()
</code></pre><p>2、————————–</p>
<pre><code>if __name__==&apos;__main__&apos;:
    print(&apos;ok&apos;)

“Make a .py both importable and executable”
</code></pre><p>如果我们是直接执行某个.py文件的时候，该文件中那么”__name__ == ‘__main__’“是True,但是我们如果从另外一个.py文件通过import导入该文件的时候，这时__name__的值就是我们这个py文件的名字而不是__main__。</p>
<p>这个功能还有一个用处：调试代码的时候，在”if __name__ == ‘__main__’“中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！</p>
<h1 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h1><p>三种时间表示</p>
<p>在Python中，通常有这几种方式来表示时间：</p>
<p>（1）时间戳(timestamp)：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</p>
<p>（2）格式化的时间字符串</p>
<p>（3）元组(struct_time)：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天，夏令时)<br>import time</p>
<p>#    1 time() :返回当前时间的时间戳</p>
<p>time.time()  #1473525444.037215</p>
<p>#———————————————————-</p>
<p># 2 localtime([secs])</p>
<p># 将一个时间戳转换为当前时区的struct_time。secs参数未提供，则以当前时间为准。</p>
<p>time.localtime() #time.struct_time(tm_year=2016, tm_mon=9, tm_mday=11, tm_hour=0,</p>
<p># tm_min=38, tm_sec=39, tm_wday=6, tm_yday=255, tm_isdst=0)</p>
<p>time.localtime(1473525444.037215)</p>
<p>#———————————————————-</p>
<p># 3 gmtime([secs]) 和localtime()方法类似，gmtime()方法是将一个时间戳转换为UTC时区（0时区）的struct_time。</p>
<p>#———————————————————-</p>
<p># 4 mktime(t) : 将一个struct_time转化为时间戳。</p>
<p>print(time.mktime(time.localtime()))#1473525749.0</p>
<p>#———————————————————-</p>
<p># 5 asctime([t]) : 把一个表示时间的元组或者struct_time表示为这种形式：’Sun Jun 20 23:21:05 1993’。</p>
<p># 如果没有参数，将会将time.localtime()作为参数传入。</p>
<p>print(time.asctime())#Sun Sep 11 00:43:43 2016</p>
<p>#———————————————————-</p>
<p># 6 ctime([secs]) : 把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果参数未给或者为None的时候，将会默认time.time()为参数。它的作用相当于time.asctime(time.localtime(secs))。</p>
<p>print(time.ctime())  # Sun Sep 11 00:46:38 2016</p>
<p>print(time.ctime(time.time()))  # Sun Sep 11 00:46:38 2016</p>
<p>#———————————————————-</p>
<p># 7 strftime(format[, t]) : 把一个代表时间的元组或者struct_time（如由time.localtime()和time.gmtime()返回）转化为格式化的时间字符串。如果t未指定，将传入<br>time.localtime()。如果元组中任何一个元素越界，ValueError的错误将会被抛出。</p>
<p>print(time.strftime(“%Y-%m-%d %X”, time.localtime()))#2016-09-11 00:49:56</p>
<p>#———————————————————-</p>
<p># 8 time.strptime(string[, format])</p>
<p># 把一个格式化时间字符串转化为struct_time。实际上它和strftime()是逆操作。</p>
<p>print(time.strptime(‘2011-05-05 16:37:06’, ‘%Y-%m-%d %X’))</p>
<p># time.struct_time(tm_year=2011, tm_mon=5, tm_mday=5, tm_hour=16, tm_min=37, tm_sec=6,</p>
<p>#  tm_wday=3, tm_yday=125, tm_isdst=-1)</p>
<p># 在这个函数中，format默认为：”%a %b %d %H:%M:%S %Y”。</p>
<p>#———————————————————-</p>
<p># 9 sleep(secs)<br># 线程推迟指定的时间运行，单位为秒。</p>
<p>#———————————————————-</p>
<p># 10 clock()<br># 这个需要注意，在不同的系统上含义不同。在UNIX系统上，它返回的是“进程时间”，它是用秒表示的浮点数（时间戳）。而在WINDOWS中，第一次调用，返回的是进程运行的实际时间。而第二次之后的调用是自第一次调用以后到现在的运行时间，即两次时间差。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-3.png" alt="9-3"><br><img src="http://p3q1rwnbl.bkt.clouddn.com/9-4.png" alt="9-4"></p>
<h1 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h1><pre><code>import random

print(random.random())    #(0,1)----float

print(random.randint(1,3))  #[1,3]

print(random.randrange(1,3)) #[1,3)

print(random.choice([1,&apos;23&apos;,[4,5]]))     #23

print(random.sample([1,&apos;23&apos;,[4,5]],2))  #[[4, 5], &apos;23&apos;]

print(random.uniform(1,3))  #1.927109612082716


item=[1,3,5,7,9]
random.shuffle(item)
print(item)
</code></pre><p>随机验证码代码:</p>
<pre><code>import random

def v_code():

    code = &apos;&apos;
    for i in range(5):

        num=random.randint(0,9)
        alf=chr(random.randint(65,90))
        add=random.choice([num,alf])
        code += str(add)
    return code

print(v_code())
</code></pre><h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><p>os模块是与操作系统交互的一个接口</p>
<p>os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</p>
<p>os.chdir(“dirname”)  改变当前脚本工作目录；相当于shell下cd</p>
<p>os.curdir  返回当前目录: (‘.’)</p>
<p>os.pardir  获取当前目录的父目录字符串名：(‘..’)</p>
<p>os.makedirs(‘dirname1/dirname2’)    可生成多层递归目录</p>
<p>os.removedirs(‘dirname1’)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</p>
<p>os.mkdir(‘dirname’)    生成单级目录；相当于shell中mkdir dirname</p>
<p>os.rmdir(‘dirname’)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</p>
<p>os.listdir(‘dirname’)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</p>
<p>os.remove()  删除一个文件</p>
<p>os.rename(“oldname”,”newname”)  重命名文件/目录</p>
<p>os.stat(‘path/filename’)  获取文件/目录信息</p>
<p>os.sep    输出操作系统特定的路径分隔符，win下为”\“,Linux下为”/“</p>
<p>os.linesep    输出当前平台使用的行终止符，win下为”\t\n”,Linux下为”\n”</p>
<p>os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</p>
<p>os.name    输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’</p>
<p>os.system(“bash command”)  运行shell命令，直接显示</p>
<p>os.environ  获取系统环境变量</p>
<p>os.path.abspath(path)  返回path规范化的绝对路径</p>
<p>os.path.split(path)  将path分割成目录和文件名二元组返回</p>
<p>os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</p>
<p>os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</p>
<p>os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</p>
<p>os.path.isabs(path)  如果path是绝对路径，返回True</p>
<p>os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</p>
<p>os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</p>
<p>os.path.join(path1[, path2[, …]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</p>
<p>os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</p>
<p>os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</p>
<h1 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h1><p>sys.argv           命令行参数List，第一个元素是程序本身路径</p>
<p>sys.exit(n)        退出程序，正常退出时exit(0)</p>
<p>sys.version        获取Python解释程序的版本信息</p>
<p>sys.maxint         最大的Int值</p>
<p>sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</p>
<p>sys.platform       返回操作系统平台名称</p>
<p>进度条代码：</p>
<pre><code>import sys,time
for i in range(10):
    sys.stdout.write(&apos;#&apos;)
    time.sleep(1)
    sys.stdout.flush()
</code></pre><h1 id="json-amp-pickle"><a href="#json-amp-pickle" class="headerlink" title="json&amp;pickle"></a>json&amp;pickle</h1><p>用eval内置方法可以将一个字符串转成python对象，不过，eval方法是有局限性的，对于普通的数据类型，json.loads和eval都能用，但遇到特殊类型的时候，eval就不管用了,所以eval的重点还是通常用来执行一个字符串表达式，并返回表达式的值。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-5.png" alt="9-5"></p>
<h2 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h2><p>我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。<br>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-6.png" alt="9-6"></p>
<p>#—————————-序列化</p>
<pre><code>import json

dic={&apos;name&apos;:&apos;alvin&apos;,&apos;age&apos;:23,&apos;sex&apos;:&apos;male&apos;}
print(type(dic))#&lt;class &apos;dict&apos;&gt;

j=json.dumps(dic)
print(type(j))#&lt;class &apos;str&apos;&gt;

f=open(&apos;序列化对象&apos;,&apos;w&apos;)
f.write(j)  #-------------------等价于json.dump(dic,f)
f.close()
</code></pre><p>#—————————–反序列化<br></p>
<pre><code>import json
f=open(&apos;序列化对象&apos;)
data=json.loads(f.read())#  等价于data=json.load(f)
</code></pre><p>注意：</p>
<pre><code>import json
#dct=&quot;{&apos;1&apos;:111}&quot;#json 不认单引号
#dct=str({&quot;1&quot;:111})#报错,因为生成的数据还是单引号:{&apos;one&apos;: 1}

dct=&apos;{&quot;1&quot;:&quot;111&quot;}&apos;
print(json.loads(dct))

#conclusion:
#无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads
</code></pre><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><p>#—————————-序列化</p>
<pre><code>import pickle

dic={&apos;name&apos;:&apos;alvin&apos;,&apos;age&apos;:23,&apos;sex&apos;:&apos;male&apos;}

print(type(dic))#&lt;class &apos;dict&apos;&gt;

j=pickle.dumps(dic)
print(type(j))#&lt;class &apos;bytes&apos;&gt;

f=open(&apos;序列化对象_pickle&apos;,&apos;wb&apos;)#注意是w是写入str,wb是写入bytes,j是&apos;bytes&apos;
f.write(j)  #-------------------等价于pickle.dump(dic,f)

f.close()
</code></pre><p>#————————-反序列化</p>
<pre><code>import pickle
f=open(&apos;序列化对象_pickle&apos;,&apos;rb&apos;)

data=pickle.loads(f.read())#  等价于data=pickle.load(f)

print(data[&apos;age&apos;])  
</code></pre><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>
<h1 id="xml模块"><a href="#xml模块" class="headerlink" title="xml模块"></a>xml模块</h1><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，在json还没诞生的黑暗年代，大家只能选择用xml，至今很多传统公司如金融行业的很多系统的接口还主要是xml。</p>
<p>xml的格式如下，就是通过&lt;&gt;节点来区别数据结构的:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;data&gt;
    &lt;country name=&quot;Liechtenstein&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;2&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;
        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;
    &lt;/country&gt;
    &lt;country name=&quot;Singapore&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;5&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;
    &lt;/country&gt;
    &lt;country name=&quot;Panama&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;69&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor name=&quot;Costa Rica&quot; direction=&quot;W&quot;/&gt;
        &lt;neighbor name=&quot;Colombia&quot; direction=&quot;E&quot;/&gt;
    &lt;/country&gt;
&lt;/data&gt;
</code></pre><p>xml协议在各个语言里的都 是支持的，在python中可以用以下模块操作xml：</p>
<pre><code>import xml.etree.ElementTree as ET 
tree = ET.parse(&quot;xmltest.xml&quot;)
root = tree.getroot()
print(root.tag)
</code></pre><p>#遍历xml文档</p>
<pre><code>for child in root:
    print(child.tag, child.attrib)
    for i in child:
        print(i.tag,i.text)
</code></pre><p>#只遍历year 节点</p>
<pre><code>for node in root.iter(&apos;year&apos;):
    print(node.tag,node.text)
</code></pre><p>#—————————————</p>
<pre><code>import xml.etree.ElementTree as ET

tree = ET.parse(&quot;xmltest.xml&quot;)
root = tree.getroot()
</code></pre><p>#修改</p>
<pre><code>for node in root.iter(&apos;year&apos;):
    new_year = int(node.text) + 1
    node.text = str(new_year)
    node.set(&quot;updated&quot;,&quot;yes&quot;)

tree.write(&quot;xmltest.xml&quot;)
</code></pre><p>#删除node</p>
<pre><code>for country in root.findall(&apos;country&apos;):
    rank = int(country.find(&apos;rank&apos;).text)
    if rank &gt; 50:
     root.remove(country)

tree.write(&apos;output.xml&apos;)
</code></pre><p>自己创建xml文档：</p>
<pre><code>import xml.etree.ElementTree as ET

new_xml = ET.Element(&quot;namelist&quot;)
name = ET.SubElement(new_xml,&quot;name&quot;,attrib={&quot;enrolled&quot;:&quot;yes&quot;})
age = ET.SubElement(name,&quot;age&quot;,attrib={&quot;checked&quot;:&quot;no&quot;})
sex = ET.SubElement(name,&quot;sex&quot;)
sex.text = &apos;33&apos;
name2 = ET.SubElement(new_xml,&quot;name&quot;,attrib={&quot;enrolled&quot;:&quot;no&quot;})
age = ET.SubElement(name2,&quot;age&quot;)
age.text = &apos;19&apos;

et = ET.ElementTree(new_xml) #生成文档对象
et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;,xml_declaration=True)

ET.dump(new_xml) #打印生成的格式
</code></pre><h1 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h1><p>(1)简单应用</p>
<pre><code>import logging  
logging.debug(&apos;debug message&apos;)  
logging.info(&apos;info message&apos;)  
logging.warning(&apos;warning message&apos;)  
logging.error(&apos;error message&apos;)  
logging.critical(&apos;critical message&apos;)
</code></pre><p>输出：</p>
<pre><code>WARNING:root:warning message
ERROR:root:error message
CRITICAL:root:critical message
</code></pre><p>可见，默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET），默认的日志格式为日志级别：Logger名称：用户输出消息。</p>
<p>（2)灵活配置日志级别，日志格式，输出位置</p>
<pre><code>import logging

logging.basicConfig(level=logging.DEBUG,
format=&apos;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;,
datefmt=&apos;%a, %d %b %Y %H:%M:%S&apos;,
filename=&apos;test.log&apos;,
filemode=&apos;w&apos;)

logging.debug(&apos;debug message&apos;)
logging.info(&apos;info message&apos;)
logging.warning(&apos;warning message&apos;)
logging.error(&apos;error message&apos;)
logging.critical(&apos;critical message&apos;)
</code></pre><p>查看输出：</p>
<pre><code>Wed, 24 Jan 2018 16:48:57 logging_test.py[line:11] DEBUG debug message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:12] INFO info message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:13] WARNING warning message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:14] ERROR error message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:15] CRITICAL critical message
</code></pre><p>可见在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有:</p>
<p>filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。</p>
<p>filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。</p>
<p>format：指定handler使用的日志显示格式。 </p>
<p>datefmt：指定日期时间格式。 </p>
<p>level：设置rootlogger（后边会讲解具体概念）的日志级别 </p>
<p>stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</p>
<p>format参数中可能用到的格式化串：</p>
<p>%(name)s Logger的名字</p>
<p>%(levelno)s 数字形式的日志级别</p>
<p>%(levelname)s 文本形式的日志级别</p>
<p>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</p>
<p>%(filename)s 调用日志输出函数的模块的文件名</p>
<p>%(module)s 调用日志输出函数的模块名</p>
<p>%(funcName)s 调用日志输出函数的函数名</p>
<p>%(lineno)d 调用日志输出函数的语句所在的代码行</p>
<p>%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</p>
<p>%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</p>
<p>%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</p>
<p>%(thread)d 线程ID。可能没有</p>
<p>%(threadName)s 线程名。可能没有</p>
<p>%(process)d 进程ID。可能没有</p>
<p>%(message)s用户输出的消息</p>
<p>（3)logger对象</p>
<p>上述几个例子中我们了解到了logging.debug()、logging.info()、logging.warning()、logging.error()、logging.critical()（分别用以记录不同级别的日志信息），logging.basicConfig()（用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到root logger（根Logger）中）这几个logging模块级别的函数，另外还有一个模块级别的函数是logging.getLogger([name])（返回一个logger对象，如果没有指定名字将返回root logger）</p>
<p>先看一个最简单的过程：</p>
<pre><code>import logging

logger = logging.getLogger()
# 创建一个handler，用于写入日志文件
fh = logging.FileHandler(&apos;test.log&apos;)

# 再创建一个handler，用于输出到控制台
ch = logging.StreamHandler()

formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;)

fh.setFormatter(formatter)
ch.setFormatter(formatter)

logger.addHandler(fh) #logger对象可以添加多个fh和ch对象
logger.addHandler(ch)

logger.debug(&apos;logger debug message&apos;)
logger.info(&apos;logger info message&apos;)
logger.warning(&apos;logger warning message&apos;)
logger.error(&apos;logger error message&apos;)
logger.critical(&apos;logger critical message&apos;)
</code></pre><p>先简单介绍一下，logging库提供了多个组件：Logger、Handler、Filter、Formatter。Logger对象提供应用程序可直接使用的接口，Handler发送日志到适当的目的地，Filter提供了过滤日志信息的方法，Formatter指定日志显示格式。</p>
<p>Logger是一个树形层级结构，输出信息之前都要获得一个Logger（如果没有显示的获取则自动创建并使用root Logger，如第一个例子所示）。</p>
<p>logger = logging.getLogger()返回一个默认的Logger也即root Logger，并应用默认的日志级别、Handler和Formatter设置。</p>
<p>当然也可以通过Logger.setLevel(lel)指定最低的日志级别，可用的日志级别有logging.DEBUG、logging.INFO、logging.WARNING、logging.ERROR、logging.CRITICAL。</p>
<p>Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()输出不同级别的日志，只有日志等级大于或等于设置的日志级别的日志才会被输出。</p>
<pre><code>logger.debug(&apos;logger debug message&apos;)  
logger.info(&apos;logger info message&apos;)  
logger.warning(&apos;logger warning message&apos;)  
logger.error(&apos;logger error message&apos;)  
logger.critical(&apos;logger critical message&apos;)  
</code></pre><p>只输出了</p>
<pre><code>2018-01-24 12:54:43,222 - root - WARNING - logger warning message
2018-01-24 12:54:43,223 - root - ERROR - logger error message
2018-01-24 12:54:43,224 - root - CRITICAL - logger critical message
</code></pre><p>从这个输出可以看出logger = logging.getLogger()返回的Logger名为root。这里没有用logger.setLevel(logging.Debug)显示的为logger设置日志级别，所以使用默认的日志级别WARNIING，故结果只输出了大于等于WARNIING级别的信息。</p>
<p>如果我们再创建两个logger对象：</p>
<pre><code>logger1 = logging.getLogger(&apos;mylogger&apos;)
logger1.setLevel(logging.DEBUG)

logger2 = logging.getLogger(&apos;mylogger&apos;)
logger2.setLevel(logging.INFO)

logger1.addHandler(fh)
logger1.addHandler(ch)

logger2.addHandler(fh)
logger2.addHandler(ch)

logger1.debug(&apos;logger1 debug message&apos;)
logger1.info(&apos;logger1 info message&apos;)
logger1.warning(&apos;logger1 warning message&apos;)
logger1.error(&apos;logger1 error message&apos;)
logger1.critical(&apos;logger1 critical message&apos;)

logger2.debug(&apos;logger2 debug message&apos;)
logger2.info(&apos;logger2 info message&apos;)
logger2.warning(&apos;logger2 warning message&apos;)
logger2.error(&apos;logger2 error message&apos;)
logger2.critical(&apos;logger2 critical message&apos;)
</code></pre><p>结果：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-7.png" alt="9-7"></p>
<p>这里有两个个问题：</p>
<p><1>我们明明通过logger1.setLevel(logging.DEBUG)将logger1的日志级别设置为了DEBUG，为何显示的时候没有显示出DEBUG级别的日志信息，而是从INFO级别的日志开始显示呢？</1></p>
<p>原来logger1和logger2对应的是同一个Logger实例，只要logging.getLogger（name）中名称参数name相同则返回的Logger实例就是同一个，且仅有一个，也即name与Logger实例一一对应。在logger2实例中通过logger2.setLevel(logging.INFO)设置mylogger的日志级别为logging.INFO，所以最后logger1的输出遵从了后来设置的日志级别。</p>
<p><2>为什么logger1、logger2对应的每个输出分别显示两次?</2></p>
<p>这是因为我们通过logger = logging.getLogger()显示的创建了root Logger，而logger1 = logging.getLogger(‘mylogger’)创建了root Logger的孩子(root.)mylogger,logger2同样。而孩子,孙子，重孙……既会将消息分发给他的handler进行处理也会传递给所有的祖先Logger处理。</p>
<p>ok,那么现在我们把</p>
<p># logger.addHandler(fh)<br># logger.addHandler(ch)  注释掉，我们再来看效果：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-8.png" alt="9-8"></p>
<p>因为我们注释了logger对象显示的位置，所以才用了默认方式，即标准输出方式。因为它的父级没有设置文件显示方式，所以在这里只打印了一次。孩子,孙子，重孙……可逐层继承来自祖先的日志级别、Handler、Filter设置，也可以通过Logger.setLevel(lel)、Logger.addHandler(hdlr)、Logger.removeHandler(hdlr)、Logger.addFilter(filt)、Logger.removeFilter(filt)。设置自己特别的日志级别、Handler、Filter。若不设置则使用继承来的值。</p>
<p><3>Filter</3></p>
<p>限制只有满足过滤规则的日志才会输出。</p>
<p>比如我们定义了filter = logging.Filter(‘a.b.c’),并将这个Filter添加到了一个Handler上，则使用该Handler的Logger中只有名字带 a.b.c前缀的Logger才能输出其日志。</p>
<pre><code>filter = logging.Filter(&apos;mylogger&apos;) 

logger.addFilter(filter)
</code></pre><p>这是只对logger这个对象进行筛选,如果想对所有的对象进行筛选，则：</p>
<pre><code>filter = logging.Filter(&apos;mylogger&apos;) 

fh.addFilter(filter)

ch.addFilter(filter)
</code></pre><p> 这样，所有添加fh或者ch的logger对象都会进行筛选。</p>
<h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>就其本质而言，正则表达式（或 RE）是一种小型的、高度专业化的编程语言，（在Python中）它内嵌在Python中，并通过 re 模块实现。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。</p>
<p>字符匹配（普通字符，元字符）：</p>
<p>（1）普通字符：大多数字符和字母都会和自身匹配</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-9.png" alt="9-9"></p>
<p>(2)元字符：<code>. ^ $ * + ? { } [ ] | ( ) \</code></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-10.png" alt="9-10"></p>
<p>注意：前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配</p>
<p>（3）元字符之字符集［］：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-11.png" alt="9-11"></p>
<p>在字符集里有功能的符号: - ^ \</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-12.png" alt="9-12"></p>
<p>（4)元字符之转义符\</p>
<p>反斜杠后边跟元字符去除特殊功能,比如.</p>
<p>反斜杠后边跟普通字符实现特殊功能,比如\d</p>
<p>\d  匹配任何十进制数；它相当于类 [0-9]。</p>
<p>\D 匹配任何非数字字符；它相当于类 [^0-9]。</p>
<p>\s  匹配任何空白字符；它相当于类 [ \t\n\r\f\v]。</p>
<p>\S 匹配任何非空白字符；它相当于类 [^ \t\n\r\f\v]。</p>
<p>\w 匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。</p>
<p>\W 匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]</p>
<p>\b  匹配一个特殊字符边界，比如空格 ，&amp;，＃等</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-13.png" alt="9-13"></p>
<p>一个小坑：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-14.png" alt="9-14"></p>
<p>选择\b是因为\b在ASCII表中是有意义的</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-15.png" alt="9-15"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-16.png" alt="9-16"></p>
<p>（5)元字符之分组()</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-17.png" alt="9-17"></p>
<p>(6)元字符之｜</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-18.png" alt="9-18"></p>
<p>(7)re模块下的常用方法</p>
<pre><code>import  re

#1
re.findall(&apos;a&apos;,&apos;alvin yuan&apos;)    #返回所有满足匹配条件的结果,放在列表里

#2
re.search(&apos;a&apos;,&apos;alvin yuan&apos;).group()  #函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以
# 通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。

#3
re.match(&apos;a&apos;,&apos;abc&apos;).group()     #同search,不过尽在字符串开始处进行匹配

#4
ret=re.split(&apos;[ab]&apos;,&apos;abcd&apos;)     #先按&apos;a&apos;分割得到&apos;&apos;和&apos;bcd&apos;,在对&apos;&apos;和&apos;bcd&apos;分别按&apos;b&apos;分割
print(ret)#[&apos;&apos;, &apos;&apos;, &apos;cd&apos;]

#5
ret=re.sub(&apos;\d&apos;,&apos;abc&apos;,&apos;alvin5yuan6&apos;,1)
print(ret)#alvinabcyuan6
ret=re.subn(&apos;\d&apos;,&apos;abc&apos;,&apos;alvin5yuan6&apos;)
print(ret)#(&apos;alvinabcyuanabc&apos;, 2)

#6
obj=re.compile(&apos;\d{3}&apos;)
ret=obj.search(&apos;abc123eeee&apos;)
print(ret.group())#123

#7
ret=re.finditer(&apos;\d&apos;,&apos;ds3sy4784a&apos;)
print(ret)        #&lt;callable_iterator object at 0x10195f940&gt;
print(next(ret).group())
print(next(ret).group())

注意：
import re

ret=re.findall(&apos;www.(baidu|163).com&apos;,&apos;www.baidu.com&apos;)
print(ret)#[&apos;baidu&apos;]     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可

ret=re.findall(&apos;www.(?:baidu|163.com&apos;,&apos;www.163.com&apos;)
print(ret)#[&apos;www.163.com&apos;]
</code></pre><p>PS: Python支持的正则表达式元字符和语法汇总表</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-19.png" alt="9-19"></p>
<p>(8)正则表达式使用总结：</p>
<p>1、用法</p>
<p>^ 匹配字符串的开始。</p>
<p>$ 匹配字符串的结尾。</p>
<p>\b 匹配一个单词的边界。</p>
<p>\d 匹配任意数字。</p>
<p>\D 匹配任意非数字字符。</p>
<p>x? 匹配一个可选的 x 字符 (换言之，它匹配 1 次或者 0 次 x 字符)。</p>
<p>x* 匹配0次或者多次 x 字符。</p>
<p>x+ 匹配1次或者多次 x 字符。</p>
<p>x{n,m} 匹配 x 字符，至少 n 次，至多 m 次。</p>
<p>(a|b|c) 要么匹配 a，要么匹配 b，要么匹配 c。</p>
<p>(x) 一般情况下表示一个记忆组 (remembered group)。你可以利用 re.search 函数返回对象的 groups() 函数获取它的值。</p>
<p>正则表达式中的点号通常意味着 “匹配任意单字符”</p>
<p>2、解题思路：</p>
<p>匹配出所有的整数：1-2*(60+(-40.35/5)-(-4*3))</p>
<p>A、既然是提取数字，那么数字的形式一般是：整数，小数，整数加小数；</p>
<p>B、所以一般是形如：—-.—–或者就是—-</p>
<p>C、根据上述正则表达式的含义，可写出如下的表达式：“-?\d+.\d*|(-?\d+) “；</p>
<p>D、-？\d+匹配1次或者0次负号；.这个是匹配小数点的；\d*这个是匹配小数点之后的数字的，所以是0个或者多个；|表示左右表达式任意匹配一个 ；</p>
<p>3.代码</p>
<pre><code>import  re
ret=re.findall(r&quot;-?\d+\.\d*|(-?\d+)&quot;,&quot;1-2*(60+(-40.35/5)-(-4*3))&quot;)
ret.remove(&quot;&quot;)
print(ret)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模块-amp-包&quot;&gt;&lt;a href=&quot;#模块-amp-包&quot; class=&quot;headerlink&quot; title=&quot;模块&amp;amp;包&quot;&gt;&lt;/a&gt;模块&amp;amp;包&lt;/h1&gt;&lt;h2 id=&quot;模块-modue-的概念：&quot;&gt;&lt;a href=&quot;#模块-modue-的概念：&quot; c
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（八）：装饰器</title>
    <link href="http://yjscloud.com/2018/01/21/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yjscloud.com/2018/01/21/Python当歌（八）：装饰器/</id>
    <published>2018-01-21T08:04:24.000Z</published>
    <updated>2018-02-07T11:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>讲 Python 装饰器前，我想先举个例子，虽有点污，但跟装饰器这个话题很贴切。每个人都有的内裤主要功能是用来遮羞，但是到了冬天它没法为我们防风御寒，咋办？我们想到的一个办法就是把内裤改造一下，让它变得更厚更长，这样一来，它不仅有遮羞功能，还能提供保暖，不过有个问题，这个内裤被我们改造成了长裤后，虽然还有遮羞功能，但本质上它不再是一条真正的内裤了。于是聪明的人们发明长裤，在不影响内裤的前提下，直接把长裤套在了内裤外面，这样内裤还是内裤，有了长裤后宝宝再也不冷了。装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。</p>
<p>谈装饰器前，还要先要明白一件事，Python 中的函数和 Java、C++不太一样，Python 中的函数可以像普通变量一样当做参数传递给另外一个函数，例如：</p>
<pre><code>def foo():
    print(&quot;foo&quot;)

def bar(func):
    func()

bar(foo)
</code></pre><p>正式回到我们的主题。装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：时间计算、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<p>先来看一个简单例子：</p>
<pre><code>import time

def foo():
    time.sleep(3)
    print(&quot;运行时间是%s&quot; %(stop_time - start_time))
</code></pre><p>现在有一个新的需求，希望可以记录下函数运行的时间，于是在代码中添加计算时间的代码：</p>
<pre><code>import time

def foo():
    start_time = time.time()
    time.sleep(3)
    stop_time = time.time()
    print(&quot;运行时间是%s&quot; %(stop_time - start_time))
</code></pre><p>如果函数 bar()、bar2() 也有类似的需求，怎么做？再写一个 类似的代码在 bar 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门计算函数运行时间 ，时间计算完成之后再执行真正的业务代码。</p>
<pre><code>import time

def timmer(func): #func=test
    start_time=time.time()
    func() #就是在运行test()
    stop_time = time.time()
    print(&apos;运行时间是%s&apos; %(stop_time-start_time))

def test():
     time.sleep(3)
     print(&apos;test函数运行完毕&apos;)

timmer(test)
</code></pre><p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑test函数，而是换成了timmer函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个test函数作为参数传递给test函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>
<h1 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h1><pre><code>import time
def timmer(func): #func=test
    def wrapper():
        start_time=time.time()
        func() #就是在运行test()
        stop_time = time.time()
        print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper

def test():
    time.sleep(3)
print(&apos;test函数运行完毕&apos;)

test = timmer(test)  #因为装饰器 timmer(test) 返回的时函数对象 wrapper，这条语句相当于test = wrapper
test()    #执行test()就相当与执行wrapper()
</code></pre><p>timmer就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 test 被 timmer 装饰了一样，timmer返回的也是一个函数，这个函数的名字叫 wrapper。在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为面向切面的编程。</p>
<h1 id="语法糖"><a href="#语法糖" class="headerlink" title="@ 语法糖"></a>@ 语法糖</h1><p>如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。</p>
<pre><code>import time
def timmer(func): #func=test
    def wrapper():
        start_time=time.time()
        func() #就是在运行test()
        stop_time = time.time()
        print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper

@timmer
def test():
    time.sleep(3)
print(&apos;test函数运行完毕&apos;)

test()
</code></pre><p>如上所示，有了 @ ，我们就可以省去test = timmer(test)这一句了，直接调用 test() 即可得到想要的结果。你们看到了没有，test() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>
<p>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p>
<h1 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="*args、**kwargs"></a>*args、**kwargs</h1><p>如果我的业务逻辑函数 foo 需要参数怎么办？比如：</p>
<pre><code>def test(name):
    time.sleep(3)
    print(“test函数运行完毕,名字是【%s】” %name)
</code></pre><p>我们可以在定义 wrapper 函数的时候指定参数：</p>
<pre><code>def wrapper(name):
    start_time=time.time()
    func(name)        
     stop_time = time.time()
     print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper
</code></pre><p>这样 test的参数就可以定义在 wrapper 函数中。如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，就多个。当装饰器不知道 test个参数时，我们可以用 * args 来代替：</p>
<pre><code>def wrapper(*args):
    start_time=time.time()
    func(*args)        
    stop_time = time.time()
    print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper
</code></pre><p>如此一来，甭管 test定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 test的业务逻辑了。这时还有读者会问，如果 test函数还定义了一些关键字参数呢？比如：</p>
<pre><code>def test(name,age,gender):
    time.sleep(1)
    print(&apos;test1函数运行完毕,名字是【%s】 年龄是【%s】 性别【%s】&apos; %(name,age,gender))
    return &apos;这是test的返回值&apos;
</code></pre><p>这时，你就可以把 wrapper 函数指定关键字函数：</p>
<pre><code>def wrapper(*args,**kwargs):
    start_time=time.time()
    func(*args,**kwargs)
    stop_time = time.time()
    print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper
</code></pre><h1 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h1><p>装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数test 。装饰器的语法允许我们在调用时，提供其它参数，比如@timmer()。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定如何计算时间，因为不同业务函数可能需要的计算时间方式是不一样的。</p>
<pre><code>import time

def cal_time(timing):
    def timmer(func):
        def wrapper(*args, **kwargs):
                start_time = time.time()
                func(*args, **kwargs)
                stop_time = time.time()
                if timing == &quot;True&quot;:
                    print(&quot;运行时间是%s&quot; %(stop_time - start_time))
                else:
                    print(&quot;鬼知道他运行了多长时间&quot;)
        return wrapper
    return timmer

@cal_time(timing=&quot;True&quot;)
def test():
    time.sleep(3)
    print(&quot;test函数运行完毕&quot;)

test()
</code></pre><p>上面的cal_time是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用@cal_time(timing=”True”)调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。</p>
<p> @cal_time(timing=”True”等价于@timmer</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;讲 Python 装饰器前，我想先举个例子，虽有点污，但跟装饰器这个话题很贴切。每个人都有的内裤主要功能是用来遮羞，但是到了冬天它没法为我们
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（七）：闭包</title>
    <link href="http://yjscloud.com/2018/01/20/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85/"/>
    <id>http://yjscloud.com/2018/01/20/Python当歌（七）：闭包/</id>
    <published>2018-01-20T07:54:22.000Z</published>
    <updated>2018-02-07T11:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是程序运行时变量可被访问的范围，定义在函数内的变量是局部变量，局部变量的作用范围只能是函数内部范围内，它不能在函数外引用。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-1.png" alt="7-1"></p>
<p>定义在模块最外层的变量是全局变量，它是全局范围内可见的，当然在函数里面也可以读取到全局变量的。例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-2.png" alt="7-2"></p>
<h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><p>函数不仅可以定义在模块的最外层，还可以定义在另外一个函数的内部，像这种定义在函数里面的函数称之为嵌套函数（nested function）例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-3.png" alt="7-3"></p>
<p>对于嵌套函数，它可以访问到其外层作用域中声明的非局部（non-local）变量，比如代码示例中的变量 msg 可以被嵌套函数 printer 正常访问。</p>
<p>那么有没有一种可能即使脱离了函数本身的作用范围，局部变量还可以被访问得到呢？答案是闭包。</p>
<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>函数身为第一类对象，它可以作为函数的返回值返回，现在我们来考虑如下的例子：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-4.png" alt="7-4"></p>
<p>这段代码和前面例子的效果完全一样，同样输出 “python”。不同的地方在于内部函数 printer 直接作为返回值返回了。</p>
<p>一般情况下，函数中的局部变量仅在函数的执行期间可用，一旦 print_msg() 执行过后，我们会认为 msg变量将不再可用。然而，在这里我们发现 print_msg 执行完之后，在调用 another 的时候 msg 变量的值正常输出了，这就是闭包的作用，闭包使得局部变量在函数外被访问成为可能。<br>这里的 another 就是一个闭包，闭包本质上是一个函数，它有两部分组成，printer 函数和变量 msg。闭包使得这些变量的值始终保存在内存中。</p>
<p>闭包，顾名思义，就是一个封闭的包裹，里面包裹着自由变量，就像在类里面定义的属性值一样，自由变量的可见范围随同包裹，哪里可以访问到这个包裹，哪里就可以访问到这个自由变量。</p>
<h1 id="为什么要使用闭包"><a href="#为什么要使用闭包" class="headerlink" title="为什么要使用闭包"></a>为什么要使用闭包</h1><p>闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。这一点与面向对象编程是非常类似的，在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。一般来说，当对象中只有一个方法时，这时使用闭包是更好的选择。来看一个例子：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-5.png" alt="7-5"></p>
<p>这比用类来实现更优雅，此外装饰器也是基于闭包的一中应用场景。<br>所有函数都有一个 <strong>closure</strong>属性，如果这个函数是一个闭包的话，那么它返回的是一个由 cell 对象 组成的元组对象。cell 对象的cell_contents 属性就是闭包中的自由变量。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-6.png" alt="7-6"></p>
<p>这解释了为什么局部变量脱离函数之后，还可以在函数之外被访问的原因的，因为它存储在了闭包的 cell_contents中了。</p>
<p>原文地址：<a href="https://foofish.net/python-closure.html" target="_blank" rel="external">一步一步教你认识Python闭包</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念。&lt;/p&gt;
&lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;p&gt;作用域是程序运行时变
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（六）：迭代器、生成器</title>
    <link href="http://yjscloud.com/2018/01/19/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yjscloud.com/2018/01/19/Python当歌（六）：迭代器、生成器/</id>
    <published>2018-01-19T03:15:23.000Z</published>
    <updated>2018-02-07T11:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="迭代的概念"><a href="#迭代的概念" class="headerlink" title="迭代的概念"></a>迭代的概念</h2><p>迭代器即迭代的工具，那什么是迭代呢？</p>
<p>迭代是一个重复的过程，每次重复即一次迭代，并且每次迭代的结果都是下一次迭代的初始值</p>
<pre><code>while True: #只是单纯地重复，因而不是迭代
    print(&apos;===&gt;&apos;) 

l=[1,2,3]
count=0
while count &lt; len(l): #迭代
    print(l[count])
count+=1
</code></pre><h2 id="理解迭代器"><a href="#理解迭代器" class="headerlink" title="理解迭代器"></a>理解迭代器</h2><p>(1)为何要有迭代器？</p>
<p>对于序列类型：字符串、列表、元组，我们可以使用索引的方式迭代取出其包含的元素。但对于字典、集合、文件等类型是没有索引的，若还想取出其内部包含的元素，则必须找出一种不依赖于索引的迭代方式，这就是迭代器</p>
<p>(2)什么是可迭代对象？</p>
<p>可迭代对象指的是内置有<strong>iter</strong>方法的对象，即obj.<strong>iter</strong>，如下</p>
<pre><code>&apos;hello&apos;.__iter__
(1,2,3).__iter__
[1,2,3].__iter__
{&apos;a&apos;:1}.__iter__
{&apos;a&apos;,&apos;b&apos;}.__iter__
open(&apos;a.txt&apos;).__iter__
</code></pre><p>（3）什么是迭代器对象？</p>
<p>可迭代对象执行obj.<strong>iter</strong>()得到的结果就是迭代器对象</p>
<p>而迭代器对象指的是即内置有<strong>iter</strong>又内置有<strong>next</strong>方法的对象</p>
<p>文件类型是迭代器对象</p>
<pre><code>open(&apos;a.txt&apos;).__iter__()
open(&apos;a.txt&apos;).__next__()
</code></pre><p>（4）注意：</p>
<p>迭代器对象一定是可迭代对象，而可迭代对象不一定是迭代器对象</p>
<h2 id="迭代器对象的使用"><a href="#迭代器对象的使用" class="headerlink" title="迭代器对象的使用"></a>迭代器对象的使用</h2><pre><code>dic={&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3}
iter_dic=dic.__iter__() #得到迭代器对象，迭代器对象即有__iter__又有__next__，
</code></pre><p>但是：迭代器.<strong>iter</strong>()得到的仍然是迭代器本身</p>
<pre><code>iter_dic.__iter__() is iter_dic #True
print(iter_dic.__next__()) #等同于next(iter_dic)
print(iter_dic.__next__()) #等同于next(iter_dic)
print(iter_dic.__next__()) #等同于next(iter_dic)
print(iter_dic.__next__()) #抛出异常StopIteration，或者说结束标志
</code></pre><p>有了迭代器，我们就可以不依赖索引迭代取值了</p>
<pre><code>iter_dic=dic.__iter__()
while 1:
    try:
        k=next(iter_dic)
        print(dic[k])
    except StopIteration:
        break
</code></pre><p>这么写太丑陋了，需要我们自己捕捉异常，控制next，python这么牛逼，能不能帮我解决呢？能，请看for循环</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>基于for循环，我们可以完全不再依赖索引去取值了</p>
<pre><code>dic={&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3}
for k in dic:
    print(dic[k])
</code></pre><p>for循环的工作原理</p>
<p>1：执行in后对象的dic.<strong>iter</strong>()方法，得到一个迭代器对象iter_dic</p>
<p>2: 执行next(iter_dic),将得到的值赋值给k,然后执行循环体代码</p>
<p>3: 重复过程2，直到捕捉到异常StopIteration,结束循环</p>
<h2 id="迭代器的优缺点"><a href="#迭代器的优缺点" class="headerlink" title="迭代器的优缺点"></a>迭代器的优缺点</h2><p>优点：</p>
<ul>
<li>提供一种统一的、不依赖于索引的迭代方式</li>
<li>惰性计算，节省内存</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法获取长度（只有在next完毕才知道到底有几个值）</li>
<li>一次性的，只能往后走，不能往前退</li>
</ul>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h2><p>通函数用 return 返回一个值，和 Java 等其他语言是一样的，然而在 Python 中还有一种函数，用关键字 yield 来返回值，这种函数叫生成器函数，函数被调用时会返回一个生成器对象，生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁。</p>
<p>最简单的生成器函数：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-1.png" alt="6-1"></p>
<p>func 就是一个生成器函数，调用该函数时返回对象就是生成器 g ，这个生成器对象的行为和迭代器是非常相似的，可以用在 for 循环等场景中。注意 yield 对应的值在函数被调用时不会立刻返回，而是调用next方法时（本质上 for 循环也是调用 next 方法）才返回</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-2.png" alt="6-2"></p>
<p>那为什么要用生成器呢？显然，用生成器在逼格上要比迭代器高几个等级，它没有那么多冗长代码了，而且性能上一样的高效，为什么不用呢？来看看用生成器实现斐波那契数列有多简单。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-3.png" alt="6-3"></p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，但是它返回的是一个生成器对象而不是列表对象。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-4.png" alt="6-4"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h1&gt;&lt;h2 id=&quot;迭代的概念&quot;&gt;&lt;a href=&quot;#迭代的概念&quot; class=&quot;headerlink&quot; title=&quot;迭代的概念&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（五）：文件读写</title>
    <link href="http://yjscloud.com/2018/01/18/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://yjscloud.com/2018/01/18/Python当歌（五）：文件读写/</id>
    <published>2018-01-18T02:40:14.000Z</published>
    <updated>2018-02-07T11:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>计算机系统分为：计算机硬件，操作系统，应用程序三部分。</p>
<p>我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。<br>有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程：</p>
<ol>
<li>打开文件，得到文件句柄并赋值给一个变量</li>
<li>通过句柄对文件进行操作</li>
<li>关闭文件</li>
</ol>
<h1 id="在python中"><a href="#在python中" class="headerlink" title="在python中"></a>在python中</h1><p>(1)打开文件，得到文件句柄并赋值给一个变量</p>
<p>f=open(‘a.txt’,’r’,encoding=’utf-8’) #默认打开模式就为r</p>
<p>(2) 通过句柄对文件进行操作</p>
<p>data=f.read()</p>
<p>(3) 关闭文件</p>
<p>f.close()</p>
<p>分析一下f=open(‘a.txt’,’r’)过程：</p>
<p>1、由应用程序向操作系统发起系统调用open(…)</p>
<p>2、操作系统打开该文件，并返回一个文件句柄给应用程序</p>
<p>3、应用程序将文件句柄赋值给变量f</p>
<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p>1、强调第一点：</p>
<p>打开一个文件包含两部分资源：操作系统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源一个不落地回收，回收方法为：</p>
<p>（1）f.close() #回收操作系统级打开的文件</p>
<p>（2）del f #回收应用程序级的变量</p>
<p>其中del f一定要发生在f.close()之后，否则就会导致操作系统打开的文件还没有关闭，白白占用资源，而python自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close()。</p>
<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>
<pre><code>with open(&apos;a.txt&apos;,&apos;w&apos;) as f:
    pass

with open(&apos;a.txt&apos;,&apos;r&apos;) as read_f,open(&apos;b.txt&apos;,&apos;w&apos;) as write_f:
    data=read_f.read()
write_f.write(data)
</code></pre><p>2、强调第二点：</p>
<p>f=open(…)是由操作系统打开文件，那么如果我们没有为open指定编码，那么打开文件的默认编码很明显是操作系统说了算了，操作系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。若要保证不乱码，文件以什么方式存的，就要以什么方式打开。<br>f=open(‘a.txt’,’r’,encoding=’utf-8’)</p>
<p>3、强调第三点</p>
<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
<pre><code>try:
    f = open(&apos;/path/to/file&apos;, &apos;r&apos;)
    print(f.read())
finally:
    if f:
        f.close()
</code></pre><h1 id="打开文件的模式"><a href="#打开文件的模式" class="headerlink" title="打开文件的模式"></a>打开文件的模式</h1><p>（1）打开文件的模式有(默认为文本模式)：</p>
<ul>
<li>r ，只读模式【默认模式，文件必须存在，不存在则抛出异常】</li>
<li>w，只写模式【不可读；不存在则创建；存在则清空内容】</li>
<li>a， 之追加写模式【不可读；不存在则创建；存在则只追加内容】</li>
</ul>
<p>（2）对于非文本文件，我们只能使用b模式，”b”表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式）</p>
<ul>
<li>rb </li>
<li>wb</li>
<li>ab</li>
</ul>
<p>注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码</p>
<p>（3）了解部分</p>
<ul>
<li>“+” 表示可以同时读写某个文件</li>
<li>r+， 读写【可读，可写】</li>
<li>w+，写读【可读，可写】</li>
<li>a+， 写读【可读，可写】</li>
<li>x， 只写模式【不可读；不存在则创建，存在则报错】</li>
<li>x+ ，写读【可读，可写】</li>
</ul>
<h1 id="操作文件的方法"><a href="#操作文件的方法" class="headerlink" title="操作文件的方法"></a>操作文件的方法</h1><p>（1）掌握</p>
<ul>
<li>f.read() #读取所有内容,光标移动到文件末尾</li>
<li>f.readline() #读取一行内容,光标移动到第二行首部</li>
<li>f.readlines() #读取每一行内容,存放于列表中</li>
<li>f.write(‘1111\n222\n’) #针对文本模式的写,需要自己写换行符</li>
<li>f.write(‘1111\n222\n’.encode(‘utf-8’)) #针对b模式的写,需要自己写换行符</li>
<li>f.writelines([‘333\n’,’444\n’]) #文件模式</li>
<li>f.writelines([bytes(‘333\n’,encoding=’utf-8’),’444\n’.encode(‘utf-8’)]) #b模式</li>
</ul>
<p>（2）了解</p>
<ul>
<li>f.readable() #文件是否可读</li>
<li>f.writable() #文件是否可读</li>
<li>f.closed #文件是否关闭</li>
<li>f.encoding #如果文件打开模式为b,则没有该属性</li>
<li>f.flush() #立刻将文件内容从内存刷到硬盘</li>
<li>f.name</li>
</ul>
<h1 id="文件内光标移动"><a href="#文件内光标移动" class="headerlink" title="文件内光标移动"></a>文件内光标移动</h1><p>（1）read(3)：</p>
<ul>
<li>文件打开方式为文本模式时，代表读取3个字符</li>
<li>文件打开方式为b模式时，代表读取3个字节</li>
</ul>
<p>（2）其余的文件内光标移动都是以字节为单位如seek，tell，truncate</p>
<p>注意：</p>
<ul>
<li>seek有三种移动方式0，1，2，其中1和2必须在b模式下进行，但无论哪种模式，都是以bytes为单位移动的</li>
<li><p>truncate是截断文件，所以文件的打开方式必须可写，但是不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果：</p>
<pre><code>import time
with open(&apos;test.txt&apos;,&apos;rb&apos;) as f:
    f.seek(0,2)
while True:
    line=f.readline()
    if line:
        print(line.decode(&apos;utf-8&apos;))
    else:
        time.sleep(0.2)
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;计算机系统分为：计算机硬件，操作系统，应用程序三部分。&lt;/p&gt;
&lt;p&gt;我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
