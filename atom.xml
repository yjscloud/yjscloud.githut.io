<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>戏子登台</title>
  <subtitle>唱一曲词，戏子登台，人生若只初相见，卖弄风骚为谁演。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yjscloud.com/"/>
  <updated>2018-03-11T12:34:22.000Z</updated>
  <id>http://yjscloud.com/</id>
  
  <author>
    <name>Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python当歌（十二）面向对象进阶</title>
    <link href="http://yjscloud.com/2018/03/11/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
    <id>http://yjscloud.com/2018/03/11/Python当歌（十二）面向对象进阶/</id>
    <published>2018-03-11T11:42:14.000Z</published>
    <updated>2018-03-11T12:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="isinstance和issubclass"><a href="#isinstance和issubclass" class="headerlink" title="isinstance和issubclass"></a>isinstance和issubclass</h1><p>（1）isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。</p>
<p>isinstance() 与 type() 区别：type() 不会认为子类是一种父类类型，不考虑继承关系。isinstance() 会认为子类是一种父类类型，考虑继承关系。如果要判断两个类型是否相同推荐使用 isinstance()。</p>
<p>以下是 isinstance() 方法的语法:</p>
<pre><code>isinstance(object, classinfo)
        object -- 实例对象。
        classinfo -- 可以是直接或间接类名、基本类型或者有它们组成的元组。
</code></pre><p>如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。</p>
<p>例子：</p>
<pre><code>&gt;&gt;&gt;a = 2
&gt;&gt;&gt; isinstance (a,int)
True
&gt;&gt;&gt; isinstance (a,str)
False
&gt;&gt;&gt; isinstance (a,(str,int,list))    # 是元组中的一个返回 True
True
</code></pre><p>type() 与 isinstance()区别：</p>
<pre><code>class A:
    pass

class B(A):
    pass

isinstance(A(), A)    # returns True
type(A()) == A        # returns True
isinstance(B(), A)    # returns True
type(B()) == A        # returns False
</code></pre><p>（2）issubclass() 方法用于判断参数 class 是否是类型参数 classinfo 的子类。</p>
<p>以下是 issubclass() 方法的语法:</p>
<pre><code>issubclass(class, classinfo)
        class -- 类。
        classinfo -- 类。
</code></pre><p>如果 class 是 classinfo 的子类返回 True，否则返回 False。</p>
<p>basestring 函数的实例：</p>
<pre><code>class A:
    pass
class B(A):
    pass

print(issubclass(B,A))    # 返回 True
</code></pre><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>（1）定义：主要指程序可以访问、监测和修改它本身状态或行为的一种能力（自省）。</p>
<p>（2）python面向对象中的反射：通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射）</p>
<p>四个可以实现自省的函数：</p>
<p>hasattr(obj, attr):这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。</p>
<p>getattr(obj, attr):调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为’bar’，则返回obj.bar。</p>
<p>setattr(obj, attr, val):调用这个方法将给obj的名为attr的值的属性赋值为val。例如如果attr为’bar’，则相当于obj.bar = val。</p>
<p>delattr(obj, attr)：函数用于删除属性。delattr(x, ‘foobar’) 相等于 del x.foobar。</p>
<p>四个方法的使用演示：</p>
<pre><code>class BlackMedium:
    feature=&apos;Ugly&apos;
    def __init__(self,name,addr):
        self.name=name
        self.addr=addr

    def sell_house(self):
        print(&apos;%s 黑中介卖房子啦,傻逼才买呢,但是谁能证明自己不傻逼&apos; %self.name)
    def rent_house(self):
        print(&apos;%s 黑中介租房子啦,傻逼才租呢&apos; %self.name)

b1=BlackMedium(&apos;万成置地&apos;,&apos;回龙观天露园&apos;)

#检测是否含有某属性
print(hasattr(b1,&apos;name&apos;))
print(hasattr(b1,&apos;sell_house&apos;))

#获取属性
n=getattr(b1,&apos;name&apos;)
print(n)
func=getattr(b1,&apos;rent_house&apos;)
func()

# getattr(b1,&apos;aaaaaaaa&apos;) #报错
print(getattr(b1,&apos;aaaaaaaa&apos;,&apos;不存在啊&apos;))

#设置属性
setattr(b1,&apos;sb&apos;,True)
setattr(b1,&apos;show_name&apos;,lambda self:self.name+&apos;sb&apos;)
print(b1.__dict__)
print(b1.show_name(b1))

#删除属性
delattr(b1,&apos;addr&apos;)
delattr(b1,&apos;show_name&apos;)
delattr(b1,&apos;show_name111&apos;)#不存在,则报错

print(b1.__dict__)
</code></pre><p>类也是对象：</p>
<pre><code>class Foo(object):
    staticField = &quot;old boy&quot;

    def __init__(self):
        self.name = &apos;wupeiqi&apos;

    def func(self):
        return &apos;func&apos;

    @staticmethod
    def bar():
        return &apos;bar&apos;


print(getattr(Foo, &apos;staticField&apos;))
print(getattr(Foo, &apos;func&apos;))
print(getattr(Foo, &apos;bar&apos;))
</code></pre><p>反射当前模块属性：</p>
<pre><code>import sys

def s1():
    print(&apos;s1&apos;)


def s2():
    print(&apos;s2&apos;)


this_module = sys.modules[__name__]

print(hasattr(this_module, &apos;s1&apos;))
print(getattr(this_module, &apos;s2&apos;))
</code></pre><p>导入其他模块，利用反射查找该模块是否存在某个方法<br>module_test.py文件：</p>
<pre><code># -*- coding:utf-8 -*-

def test():
print(&apos;from the test&apos;)
</code></pre><p>index.py文件：</p>
<pre><code># -*- coding:utf-8 -*-
</code></pre><p>程序目录：</p>
<pre><code>module_test.py
index.py
</code></pre><p>当前文件：</p>
<p>index.py</p>
<pre><code>import module_test as obj

#obj.test()

print(hasattr(obj,&apos;test&apos;))

getattr(obj,&apos;test&apos;)()
</code></pre><p>（3）用反射的好处</p>
<p>好处一：实现可插拔机制</p>
<p>服务端编写的程序由于什么情况中断没有继续编写，客户端那边需要用到服务端的类，这是客户端可以使用反射机制继续完成自己的代码，等服务端回来后再继续完成类的定义并去实现客户端想要的功能。<br>总之反射的好处就是，可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种‘后期绑定’，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能。</p>
<p>服务端还未实现的全部功能：</p>
<pre><code>class FtpClient:
    &apos;ftp客户端,但是还么有实现具体的功能&apos;
    def __init__(self,addr):
        print(&apos;正在连接服务器[%s]&apos; %addr)
        self.addr=addr
</code></pre><p>不影响客户端的代码编写：</p>
<pre><code>#from module import FtpClient
f1=FtpClient(&apos;192.168.1.1&apos;)
if hasattr(f1,&apos;get&apos;):
    func_get=getattr(f1,&apos;get&apos;)
    func_get()
else:
    print(&apos;----&gt;不存在此方法&apos;)
print(&apos;处理其他的逻辑&apos;)
</code></pre><p>好处二：动态导入模块（基于反射当前模块成员）</p>
<p><img src="" alt="12-1"></p>
<h1 id="setattr-delattr-getattr"><a href="#setattr-delattr-getattr" class="headerlink" title="__setattr__,__delattr__,__getattr__"></a>__setattr__,__delattr__,__getattr__</h1><pre><code>class Foo:
    x=1
    def __init__(self,y):
        self.y=y

    def __getattr__(self, item):
        print(&apos;----&gt; from getattr:你找的属性不存在&apos;)


    def __setattr__(self, key, value):
        print(&apos;----&gt; from setattr&apos;)
        # self.key=value #这就无限递归了,你好好想想
        # self.__dict__[key]=value #应该使用它

    def __delattr__(self, item):
        print(&apos;----&gt; from delattr&apos;)
        # del self.item #无限递归了
        self.__dict__.pop(item)

#__setattr__添加/修改属性会触发它的执行
f1=Foo(10)
print(f1.__dict__) # 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值
f1.z=3
print(f1.__dict__)

#__delattr__删除属性的时候会触发
f1.__dict__[&apos;a&apos;]=3#我们可以直接修改属性字典,来完成添加/修改属性的操作
del f1.a
print(f1.__dict__)

#__getattr__只有在使用点调用属性且属性不存在的时候才会触发
f1.xxxxxx
</code></pre><h1 id="二次加工标准类型-包装"><a href="#二次加工标准类型-包装" class="headerlink" title="二次加工标准类型(包装)"></a>二次加工标准类型(包装)</h1><p>包装：python为大家提供了标准数据类型，以及丰富的内置方法，其实在很多场景下我们都需要基于标准数据类型来定制我们自己的数据类型，新增/改写方法，这就用到了继承/派生知识（其他的标准类型均可以通过下面的方式进行二次加工）</p>
<p>二次加工标准类型(基于继承实现)：</p>
<pre><code>class List(list): #继承list所有的属性，也可以派生出自己新的，比如append和mid
    def append(self, p_object):
        &apos; 派生自己的append：加上类型检查&apos;
        if not isinstance(p_object,int):
            raise TypeError(&apos;must be int&apos;)
        super().append(p_object)

    @property
    def mid(self):
        &apos;新增自己的属性&apos;
        index=len(self)//2
        return self[index]

l=List([1,2,3,4])
print(l)
l.append(5)
print(l)
# l.append(&apos;1111111&apos;) #报错，必须为int类型

print(l.mid)

#其余的方法都继承list的
l.insert(0,-123)
print(l)
l.clear()
print(l)
</code></pre><p>授权：授权是包装的一个特性, 包装一个类型通常是对已存在的类型的一些定制,这种做法可以新建,修改或删除原有产品的功能。其它的则保持原样。授权的过程,即是所有更新的功能都是由新类的某部分来处理,但已存在的功能就授权给对象的默认属性。</p>
<p>实现授权的关键点就是覆盖<strong>getattr</strong>方法</p>
<p>授权示范一：</p>
<pre><code>import time
class FileHandle:
    def __init__(self,filename,mode=&apos;r&apos;,encoding=&apos;utf-8&apos;):
        self.file=open(filename,mode,encoding=encoding)
    def write(self,line):
        t=time.strftime(&apos;%Y-%m-%d %T&apos;)
        self.file.write(&apos;%s %s&apos; %(t,line))

    def __getattr__(self, item):
        return getattr(self.file,item)

f1=FileHandle(&apos;b.txt&apos;,&apos;w+&apos;)
f1.write(&apos;你好啊&apos;)
f1.seek(0)
print(f1.read())
f1.close()
</code></pre><p>授权示范二</p>
<pre><code>#我们来加上b模式支持
import time
class FileHandle:
    def __init__(self,filename,mode=&apos;r&apos;,encoding=&apos;utf-8&apos;):
        if &apos;b&apos; in mode:
            self.file=open(filename,mode)
        else:
            self.file=open(filename,mode,encoding=encoding)
        self.filename=filename
        self.mode=mode
        self.encoding=encoding

    def write(self,line):
        if &apos;b&apos; in self.mode:
            if not isinstance(line,bytes):
                raise TypeError(&apos;must be bytes&apos;)
        self.file.write(line)

    def __getattr__(self, item):
        return getattr(self.file,item)

    def __str__(self):
        if &apos;b&apos; in self.mode:
            res=&quot;&lt;_io.BufferedReader name=&apos;%s&apos;&gt;&quot; %self.filename
        else:
            res=&quot;&lt;_io.TextIOWrapper name=&apos;%s&apos; mode=&apos;%s&apos; encoding=&apos;%s&apos;&gt;&quot; %(self.filename,self.mode,self.encoding)
        return res
f1=FileHandle(&apos;b.txt&apos;,&apos;wb&apos;)
# f1.write(&apos;你好啊啊啊啊啊&apos;) #自定制的write,不用在进行encode转成二进制去写了,简单,大气
f1.write(&apos;你好啊&apos;.encode(&apos;utf-8&apos;))
print(f1)
f1.close()

练习题（授权）
class List:
    def __init__(self,seq,permission=False):
        self.seq=seq
        self.permission=permission
    def clear(self):
        if not self.permission:
            raise PermissionError(&apos;not allow the operation&apos;)
        self.seq.clear()

    def __getattr__(self, item):
        return getattr(self.seq,item)

    def __str__(self):
        return str(self.seq)
l=List([1,2,3])
# l.clear() #此时没有权限，抛出异常

l.permission=True
print(l)
l.clear()
print(l)

#基于授权，获得insert方法
l.insert(0,-123)
print(l)
</code></pre><h1 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a>__getattribute__</h1><p>（1）回顾<strong>getattr</strong></p>
<pre><code>class Foo:
    def __init__(self,x):
        self.x=x

    def __getattr__(self, item):
        print(&apos;执行的是我&apos;)
        # return self.__dict__[item]

f1=Foo(10)
print(f1.x)
f1.xxxxxx #不存在的属性访问，触发__getattr__
</code></pre><p>（2）<strong>getattribute</strong></p>
<pre><code>class Foo:
    def __init__(self,x):
        self.x=x

    def __getattribute__(self, item):
        print(&apos;不管是否存在,我都会执行&apos;)

f1=Foo(10)
f1.x
f1.xxxxxx
</code></pre><p>（3）二者同时出现</p>
<pre><code>#_*_coding:utf-8_*_

class Foo:
    def __init__(self,x):
        self.x=x

    def __getattr__(self, item):
        print(&apos;执行的是我&apos;)
        # return self.__dict__[item]
    def __getattribute__(self, item):
        print(&apos;不管是否存在,我都会执行&apos;)
        raise AttributeError(&apos;哈哈&apos;)

f1=Foo(10)
f1.x
f1.xxxxxx

#当__getattribute__与__getattr__同时存在,只会执行__getattrbute__,除非__getattribute__在执行过程中抛出异常AttributeError
</code></pre><h1 id="setitem-getitem-delitem"><a href="#setitem-getitem-delitem" class="headerlink" title="__setitem__,__getitem__,__delitem__"></a>__setitem__,__getitem__,__delitem__</h1><p><code>__setitem__(self,key,value)</code>：设置给定键的值<br><code>__getitem__(self,key)</code>:返回键对应的值。<br><code>__delitem__(self,key)</code>:删除给定键对应的元素。</p>
<p>例子：</p>
<pre><code>class Foo(object):
    def __getitem__(self, key):
        print(&apos;__getitem__&apos;, key)

    def __setitem__(self, key, value):
        print(&apos;__setitem__&apos;, key, value)

    def __delitem__(self, key):
        print(&apos;__delitem__&apos;, key)


obj = Foo()

result = obj[&apos;k1&apos;]  # 自动触发执行 __getitem__
obj[&apos;k2&apos;] = &apos;Pan&apos;  # 自动触发执行 __setitem__
del obj[&apos;k1&apos;]  # 自动触发执行 __delitem__
</code></pre><h1 id="str-repr-format"><a href="#str-repr-format" class="headerlink" title="__str__,__repr__,__format__"></a>__str__,__repr__,__format__</h1><p>改变对象的字符串显示<code>__str__</code>,<code>__repr__</code></p>
<p>自定制格式化字符串<code>__format__</code></p>
<p>例子：</p>
<pre><code>format_dict={
    &apos;nat&apos;:&apos;{obj.name}-{obj.addr}-{obj.type}&apos;,#学校名-学校地址-学校类型
    &apos;tna&apos;:&apos;{obj.type}:{obj.name}:{obj.addr}&apos;,#学校类型:学校名:学校地址
    &apos;tan&apos;:&apos;{obj.type}/{obj.addr}/{obj.name}&apos;,#学校类型/学校地址/学校名
}
class School:
    def __init__(self,name,addr,type):
        self.name=name
        self.addr=addr
        self.type=type

    def __repr__(self):
        return &apos;School(%s,%s)&apos; %(self.name,self.addr)
    def __str__(self):
        return &apos;(%s,%s)&apos; %(self.name,self.addr)

    def __format__(self, format_spec):
        # if format_spec
        if not format_spec or format_spec not in format_dict:
            format_spec=&apos;nat&apos;
        fmt=format_dict[format_spec]
        return fmt.format(obj=self)

s1=School(&apos;oldboy1&apos;,&apos;北京&apos;,&apos;私立&apos;)
print(&apos;from repr: &apos;,repr(s1))
print(&apos;from str: &apos;,str(s1))
print(s1)
</code></pre><p>str函数或者print函数—&gt;<code>obj.__str__()</code></p>
<p>repr或者交互式解释器—&gt;<code>obj.__repr__()</code></p>
<p>如果<strong>str</strong>没有被定义,那么就会使用<strong>repr</strong>来代替输出</p>
<p>注意:这俩方法的返回值必须是字符串,否则抛出异常</p>
<pre><code>print(format(s1,&apos;nat&apos;))
print(format(s1,&apos;tna&apos;))
print(format(s1,&apos;tan&apos;))
print(format(s1,&apos;asfdasdffd&apos;))
</code></pre><h1 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h1><p>（1）<strong>slots</strong>是什么:是一个类变量,变量值可以是列表,元祖,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性)</p>
<p>（2）    引子:使用点来访问属性本质就是在访问类或者对象的<strong>dict</strong>属性字典(类的字典是共享的,而每个实例的是独立的)</p>
<p>（3）为何使用<strong>slots</strong>:字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用<strong>slots</strong>取代实例的<strong>dict</strong>。<br>当你定义<strong>slots</strong>后,<strong>slots</strong>就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个。<br>字典,这跟元组或列表很类似。在<strong>slots</strong>中列出的属性名在内部被映射到这个数组的指定小标上。使用<strong>slots</strong>一个不好的地方就是我们不能再给。<br>实例添加新的属性了,只能使用在<strong>slots</strong>中定义的那些属性名。</p>
<p>（4）注意事项:<strong>slots</strong>的很多特性都依赖于普通的基于字典的实现。另外,定义了<strong>slots</strong>后的类不再支持一些普通类特性了,比如多继承。大多数情况下,你应该。<br>只在那些经常被使用到的用作数据结构的类上定义<strong>slots</strong>比如在程序中需要创建某个类的几百万个实例对象。<br>关于<strong>slots</strong>的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用<strong>slots</strong>可以达到这样的目的,但是这个并不是它的初衷。           更多的是用来作为一个内存优化工具。</p>
<p>例一：</p>
<pre><code>class Foo:
    __slots__=&apos;x&apos;

f1=Foo()
f1.x=1
f1.y=2#报错
print(f1.__slots__) #f1不再有__dict__

class Bar:
    __slots__=[&apos;x&apos;,&apos;y&apos;]

n=Bar()
n.x,n.y=1,2
n.z=3#报错
</code></pre><p>例二：</p>
<pre><code>class Foo:
    __slots__=[&apos;name&apos;,&apos;age&apos;]

f1=Foo()
f1.name=&apos;alex&apos;
f1.age=18
print(f1.__slots__)

f2=Foo()
f2.name=&apos;egon&apos;
f2.age=19
print(f2.__slots__)

print(Foo.__dict__)
#f1与f2都没有属性字典__dict__了,统一归__slots__管,节省内存
</code></pre><h1 id="next-和-iter-实现迭代器协议"><a href="#next-和-iter-实现迭代器协议" class="headerlink" title="__next__和__iter__实现迭代器协议"></a>__next__和__iter__实现迭代器协议</h1><p>（1）简单实现：</p>
<pre><code>class Foo:
    def __init__(self,x):
        self.x=x

    def __iter__(self):
        return self

    def __next__(self):
        n=self.x
        self.x+=1
        return self.x

f=Foo(3)
for i in f:
print(i)
</code></pre><p>（2）简单模拟range，加上步长：</p>
<pre><code>class Range:
    def __init__(self,n,stop,step):
        self.n=n
        self.stop=stop
        self.step=step

    def __next__(self):
        if self.n &gt;= self.stop:
            raise StopIteration
        x=self.n
        self.n+=self.step
        return x

    def __iter__(self):
        return self

for i in Range(1,7,3): #
print(i)
</code></pre><p>（3）斐波那契数列</p>
<pre><code>class Fib:
    def __init__(self):
        self._a=0
        self._b=1

    def __iter__(self):
        return self

    def __next__(self):
        self._a,self._b=self._b,self._a + self._b
        return self._a

f1=Fib()

print(f1.__next__())
print(next(f1))
print(next(f1))

for i in f1:
    if i &gt; 100:
        break
print(&apos;%s &apos; %i,end=&apos;&apos;)
</code></pre><h1 id="doc"><a href="#doc" class="headerlink" title="__doc__"></a>__doc__</h1><p><strong>doc</strong>是类的描述信息</p>
<pre><code>class Foo:
    &apos;我是描述信息&apos;
    pass

print(Foo.__doc__)

该属性无法继承给子类
class Foo:
    &apos;我是描述信息&apos;
    pass

class Bar(Foo):
    pass
print(Bar.__doc__) #该属性无法继承给子类
</code></pre><h1 id="module-和-class"><a href="#module-和-class" class="headerlink" title="__module__和__class__"></a>__module__和__class__</h1><p><code>__module__</code> 表示当前操作的对象在那个模块</p>
<p><code>__class__</code>   表示当前操作的对象的类是什么</p>
<pre><code>class C:

    def __init__(self):
        self.name = ‘SB&apos;

from lib.aa import C

obj = C()
print obj.__module__  # 输出 lib.aa，即：输出模块
print obj.__class__      # 输出 lib.aa.C，即：输出类
</code></pre><h1 id="del"><a href="#del" class="headerlink" title="__del__"></a>__del__</h1><p>析构方法，当对象在内存中被释放时，自动触发执行。</p>
<p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p>
<pre><code>class Foo:

    def __del__(self):
        pass
</code></pre><h1 id="enter-和-exit"><a href="#enter-和-exit" class="headerlink" title="__enter__和__exit__"></a>__enter__和__exit__</h1><p>我们知道在操作文件对象的时候可以这么写</p>
<pre><code>with open(&apos;a.txt&apos;) as f:
    &apos;代码块&apos;
</code></pre><p>上述叫做上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象的类中声明<strong>enter</strong>和<strong>exit</strong>方法</p>
<pre><code>class Open:
    def __init__(self,name):
        self.name=name

    def __enter__(self):
        print(&apos;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&apos;)
        # return self
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&apos;with中代码块执行完毕时执行我啊&apos;)


with Open(&apos;a.txt&apos;) as f:
    print(&apos;=====&gt;执行代码块&apos;)
# print(f,f.name)
</code></pre><p><code>__exit__</code>()中的三个参数分别代表异常类型，异常值和追溯信息,with语句中代码块出现异常，则with后的代码都无法执行</p>
<pre><code>class Open:
    def __init__(self,name):
        self.name=name

    def __enter__(self):
        print(&apos;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&apos;)

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&apos;with中代码块执行完毕时执行我啊&apos;)
        print(exc_type)
        print(exc_val)
        print(exc_tb)



with Open(&apos;a.txt&apos;) as f:
    print(&apos;=====&gt;执行代码块&apos;)
    raise AttributeError(&apos;***着火啦,救火啊***&apos;)
print(&apos;0&apos;*100) #-------------------------------&gt;不会执行
</code></pre><p>如果__exit()返回值为True,那么异常会被清空，就好像啥都没发生一样，with后的语句正常执行</p>
<pre><code>class Open:
    def __init__(self,name):
        self.name=name

    def __enter__(self):
        print(&apos;出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量&apos;)

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&apos;with中代码块执行完毕时执行我啊&apos;)
        print(exc_type)
        print(exc_val)
        print(exc_tb)
        return True

with Open(&apos;a.txt&apos;) as f:
    print(&apos;=====&gt;执行代码块&apos;)
    raise AttributeError(&apos;***着火啦,救火啊***&apos;)
print(&apos;0&apos;*100) #-------------------------------&gt;会执行
</code></pre><p>模拟Open：</p>
<pre><code>class Open:
    def __init__(self,filepath,mode=&apos;r&apos;,encoding=&apos;utf-8&apos;):
        self.filepath=filepath
        self.mode=mode
        self.encoding=encoding

    def __enter__(self):
        # print(&apos;enter&apos;)
        self.f=open(self.filepath,mode=self.mode,encoding=self.encoding)
        return self.f

    def __exit__(self, exc_type, exc_val, exc_tb):
        # print(&apos;exit&apos;)
        self.f.close()
        return True 
    def __getattr__(self, item):
        return getattr(self.f,item)

with Open(&apos;a.txt&apos;,&apos;w&apos;) as f:
    print(f)
    f.write(&apos;aaaaaa&apos;)
f.wasdf #抛出异常，交给__exit__处理
</code></pre><p>用途或者说好处：</p>
<p>1.使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预</p>
<p>2.在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在<strong>exit</strong>中定制自动释放资源的机制，你无须再去关系这个问题，这将大有用处</p>
<h1 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h1><p>对象后面加括号，触发执行。</p>
<p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p>
<pre><code>class Foo:

    def __init__(self):
        pass

    def __call__(self, *args, **kwargs):

        print(&apos;__call__&apos;)


obj = Foo() # 执行 __init__
obj()       # 执行 __call__
</code></pre><h1 id="描述符-get-set-delete"><a href="#描述符-get-set-delete" class="headerlink" title="描述符(__get__,__set__,__delete__)"></a>描述符(__get__,__set__,__delete__)</h1><p>１）描述符是什么:描述符本质就是一个新式类,在这个新式类中,至少实现了</p>
<pre><code>__get__(),__set__(),__delete__()中的一个,这也被称为描述符协议。
__get__():调用一个属性时,触发
__set__():为一个属性赋值时,触发
__delete__():采用del删除属性时,触发
</code></pre><p>定义一个描述符</p>
<pre><code>class Foo: #在python3中Foo是新式类,它实现了三种方法,这个类就被称作一个描述符
    def __get__(self, instance, owner):
        pass
    def __set__(self, instance, value):
        pass
    def __delete__(self, instance):
        pass
</code></pre><p>2)描述符是干什么的:描述符的作用是用来代理另外一个类的属性的(必须把描述符定义成这个类的类属性，不能定义到构造函数中)</p>
<p>引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行</p>
<pre><code>class Foo:
    def __get__(self, instance, owner):
        print(&apos;触发get&apos;)
    def __set__(self, instance, value):
        print(&apos;触发set&apos;)
    def __delete__(self, instance):
        print(&apos;触发delete&apos;)

#包含这三个方法的新式类称为描述符,由这个类产生的实例进行属性的调用/赋值/删除,并不会触发这三个方法
f1=Foo()
f1.name=&apos;egon&apos;
f1.name
del f1.name
#疑问:何时,何地,会触发这三个方法的执行

描述符应用之何时?何地?
#描述符Str
class Str:
    def __get__(self, instance, owner):
        print(&apos;Str调用&apos;)
    def __set__(self, instance, value):
        print(&apos;Str设置...&apos;)
    def __delete__(self, instance):
        print(&apos;Str删除...&apos;)

#描述符Int
class Int:
    def __get__(self, instance, owner):
        print(&apos;Int调用&apos;)
    def __set__(self, instance, value):
        print(&apos;Int设置...&apos;)
    def __delete__(self, instance):
        print(&apos;Int删除...&apos;)

class People:
    name=Str()
    age=Int()
    def __init__(self,name,age): #name被Str类代理,age被Int类代理,
        self.name=name
        self.age=age

#何地？：定义成另外一个类的类属性

#何时？：且看下列演示

p1=People(&apos;alex&apos;,18)

#描述符Str的使用
p1.name
p1.name=&apos;egon&apos;
del p1.name

#描述符Int的使用
p1.age
p1.age=18
del p1.age

#我们来瞅瞅到底发生了什么
print(p1.__dict__)
print(People.__dict__)

#补充
print(type(p1) == People) #type(obj)其实是查看obj是由哪个类实例化来的
print(type(p1).__dict__ == People.__dict__)
</code></pre><p>3)描述符分为两种</p>
<p>（1）数据描述符:至少实现了<code>__get__()</code>和<code>__set__()</code></p>
<pre><code>class Foo:
     def __set__(self, instance, value):
         print(&apos;set&apos;)
     def __get__(self, instance, owner):
        print(&apos;get&apos;)
</code></pre><p>（2）非数据描述符:没有实现<code>__set__()</code></p>
<pre><code>class Foo:
     def __get__(self, instance, owner):
         print(&apos;get&apos;)
</code></pre><p>4）注意事项:</p>
<p>一） 描述符本身应该定义成新式类,被代理的类也应该是新式类</p>
<p>二 ）必须把描述符定义成这个类的类属性，不能为定义到构造函数中</p>
<p>三 ）要严格遵循该优先级,优先级由高到底分别是</p>
<p>1.类属性</p>
<p>2.数据描述符</p>
<p>3.实例属性</p>
<p>4.非数据描述符</p>
<p>5.找不到的属性触发<strong>getattr</strong>()</p>
<p>5）描述符总结</p>
<p>描述符是可以实现大部分python类特性中的底层魔法,包括@classmethod,@staticmethd,@property甚至是<strong>slots</strong>属性。<br>描述父是很多高级库和框架的重要工具之一,描述符通常是使用到装饰器或者元类的大型框架中的一个组件.</p>
<p>6）利用描述符原理完成一个自定制@property,实现延迟计算（本质就是把一个函数属性利用装饰器原理做成一个描述符：类的属性字典中函数名为key，value为描述符类产生的对象）</p>
<p>@property回顾</p>
<pre><code>class Room:
    def __init__(self,name,width,length):
        self.name=name
        self.width=width
        self.length=length

    @property
    def area(self):
        return self.width * self.length

r1=Room(&apos;alex&apos;,1,1)
print(r1.area)
</code></pre><p>自己做一个@property</p>
<pre><code>class Lazyproperty:
    def __init__(self,func):
        self.func=func
    def __get__(self, instance, owner):
        print(&apos;这是我们自己定制的静态属性,r1.area实际是要执行r1.area()&apos;)
        if instance is None:
            return self
        return self.func(instance) #此时你应该明白,到底是谁在为你做自动传递self的事情

class Room:
    def __init__(self,name,width,length):
        self.name=name
        self.width=width
        self.length=length

    @Lazyproperty #area=Lazyproperty(area) 相当于定义了一个类属性,即描述符
    def area(self):
        return self.width * self.length

r1=Room(&apos;alex&apos;,1,1)
print(r1.area)
</code></pre><h1 id="元类metaclass"><a href="#元类metaclass" class="headerlink" title="元类metaclass"></a>元类metaclass</h1><p>1）引子</p>
<pre><code>class Foo:
    pass

f1=Foo() #f1是通过Foo类实例化的对象
</code></pre><p>python中一切皆是对象，类本身也是一个对象，当使用关键字class的时候，python解释器在加载class的时候就会创建一个对象(这里的对象指的是类而非类的实例)。<br>上例可以看出f1是由Foo这个类产生的对象，而Foo本身也是对象，那它又是由哪个类产生的呢？</p>
<pre><code>#type函数可以查看类型，也可以用来查看对象的类，二者是一样的
print(type(f1)) # 输出：&lt;class &apos;__main__.Foo&apos;&gt;     表示，obj 对象由Foo类创建
print(type(Foo)) # 输出：&lt;type &apos;type&apos;&gt;
</code></pre><p>2）什么是元类？</p>
<p>元类是类的类，是类的模板</p>
<p>元类是用来控制如何创建类的，正如类是创建对象的模板一样</p>
<p>元类的实例为类，正如类的实例为对象(f1对象是Foo类的一个实例，Foo类是 type 类的一个实例)</p>
<p>type是python的一个内建元类，用来直接控制生成类，python中任何class定义的类其实都是type类实例化的对象。</p>
<p>3）创建类的两种方式</p>
<p>方式一：</p>
<pre><code>class Foo:
    def func(self):
        print(&apos;from func&apos;)
</code></pre><p>方式二：</p>
<pre><code>def func(self):
    print(&apos;from func&apos;)
x=1
Foo=type(&apos;Foo&apos;,(object,),{&apos;func&apos;:func,&apos;x&apos;:1})
</code></pre><p>4）一个类没有声明自己的元类，默认他的元类就是type，除了使用元类type，用户也可以通过继承type来自定义元类（顺便我们也可以瞅一瞅元类如何控制类的创建，工作流程是什么）</p>
<pre><code>class Mytype(type):
    def __init__(self,what,bases=None,dict=None):
        print(what,bases,dict)

    def __call__(self, *args, **kwargs):
        print(&apos;---&gt;&apos;)
        obj=object.__new__(self)
        self.__init__(obj,*args,**kwargs)
        return obj
class Room(metaclass=Mytype):
    def __init__(self,name):
        self.name=name

r1=Room(&apos;alex&apos;)
print(r1.__dict__)
</code></pre><p>5）元类总结</p>
<pre><code>class Mymeta(type):
    def __init__(self,name,bases,dic):
        print(&apos;===&gt;Mymeta.__init__&apos;)

    def __new__(cls, *args, **kwargs):
        print(&apos;===&gt;Mymeta.__new__&apos;)
        return type.__new__(cls,*args,**kwargs)

    def __call__(self, *args, **kwargs):
        print(&apos;aaa&apos;)
        obj=self.__new__(self)
        self.__init__(self,*args,**kwargs)
        return obj

class Foo(object,metaclass=Mymeta):
    def __init__(self,name):
        self.name=name
    def __new__(cls, *args, **kwargs):
        return object.__new__(cls)
</code></pre><p>需要记住一点:名字加括号的本质(即,任何name()的形式),都是先找到name的爹,然后执行:爹.<strong>call</strong></p>
<p>而爹.<strong>call</strong>一般做两件事:</p>
<p>1.调用name.<strong>new</strong>方法并返回一个对象</p>
<p>2.进而调用name.<strong>init</strong>方法对儿子name进行初始化<br>class 定义Foo,并指定元类为Mymeta,这就相当于要用Mymeta创建一个新的对象Foo,于是相当于执行Foo=Mymeta(‘foo’,(…),{…})因此我们可以看到,只定义class就会有如下执行效果</p>
<p>===&gt;Mymeta.<strong>new</strong></p>
<p>===&gt;Mymeta.<strong>init</strong></p>
<p>实际上class Foo(metaclass=Mymeta)是触发了Foo=Mymeta(‘Foo’,(…),{…})操作,遇到了名字加括号的形式,即Mymeta(…),于是就去找Mymeta的爹type,然后执<code>type.__call__(...)</code>方法，于是触发Mymeta.<strong>new</strong>方法得到一个具体的对象,然后触发Mymeta.<strong>init</strong>方法对对象进行初始化obj=Foo(‘egon’)的原理同上</p>
<p>总结:元类的难点在于执行顺序很绕,其实我们只需要记住两点就可以了</p>
<p>1.谁后面跟括号,就从谁的爹中找<strong>call</strong>方法执行</p>
<p>type-&gt;Mymeta-&gt;Foo-&gt;obj</p>
<p>Mymeta()触发type.<strong>call</strong></p>
<p>Foo()触发Mymeta.<strong>call</strong></p>
<p>obj()触发Foo.<strong>call</strong></p>
<p>2.<strong>call</strong>内按先后顺序依次调用儿子的<strong>new</strong>和<strong>init</strong>方法</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;isinstance和issubclass&quot;&gt;&lt;a href=&quot;#isinstance和issubclass&quot; class=&quot;headerlink&quot; title=&quot;isinstance和issubclass&quot;&gt;&lt;/a&gt;isinstance和issubclass&lt;/
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（十一）三个class方法</title>
    <link href="http://yjscloud.com/2018/03/11/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%B8%89%E4%B8%AAclass%E6%96%B9%E6%B3%95/"/>
    <id>http://yjscloud.com/2018/03/11/Python当歌（十一）三个class方法/</id>
    <published>2018-03-10T17:36:41.000Z</published>
    <updated>2018-03-11T12:27:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Property（特性）"><a href="#Property（特性）" class="headerlink" title="Property（特性）"></a>Property（特性）</h1><h2 id="什么是特性property"><a href="#什么是特性property" class="headerlink" title="什么是特性property"></a>什么是特性property</h2><p>property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值</p>
<p>例一：BMI指数（bmi是计算而来的，但很明显它听起来像是一个属性而非方法，如果我们将其做成一个属性，更便于理解）</p>
<p>成人的BMI数值：</p>
<p>过轻：低于18.5</p>
<p>正常：18.5-23.9</p>
<p>过重：24-27</p>
<p>肥胖：28-32</p>
<p>非常肥胖, 高于32</p>
<p>　　体质指数（BMI）=体重（kg）÷身高^2（m）</p>
<p>EX：70kg÷（1.75×1.75）=22.86</p>
<pre><code>class People:
    def __init__(self,name,weight,height):
       self.name=name
       self.weight=weight
       self.height=height
   @property
   def bmi(self):
       return self.weight / (self.height**2)

p1=People(&apos;egon&apos;,75,1.85)
print(p1.bmi)
</code></pre><p>例二：圆的周长和面积</p>
<pre><code>import math
class Circle:
    def __init__(self,radius): #圆的半径radius
       self.radius=radius

    @property
    def area(self):
       return math.pi * self.radius**2 #计算面积

    @property
    def perimeter(self):
       return 2*math.pi*self.radius #计算周长

c=Circle(10)
print(c.radius)
print(c.area) #可以向访问数据属性一样去访问area,会触发一个函数的执行,动态计算出一个值
print(c.perimeter) #同上
</code></pre><p>输出结果:</p>
<p>314.1592653589793</p>
<p>62.83185307179586</p>
<p>注意：此时的特性arear和perimeter不能被赋值，c.area=3 #为特性area赋值</p>
<h2 id="为什么要用property"><a href="#为什么要用property" class="headerlink" title="为什么要用property"></a>为什么要用property</h2><p>将一个类的函数定义成特性以后，对象再去使用的时候obj.name,根本无法察觉自己的name是执行了一个函数然后计算出来的，这种特性的使用方式遵循了统一访问的原则。</p>
<p>除此之外，看下</p>
<p>ps：面向对象的封装有三种方式:</p>
<p>【public】</p>
<p>这种其实就是不封装,是对外公开的</p>
<p>【protected】</p>
<p>这种封装方式对外不公开,但对朋友(friend)或者子类(形象的说法是“儿子”,但我不知道为什么大家 不说“女儿”,就像“parent”本来是“父母”的意思,但中文都是叫“父类”)公开</p>
<p>【private】</p>
<p>这种封装对谁都不公开</p>
<p>python并没有在语法上把它们三个内建到自己的class机制中，在C++里一般会将所有的所有的数据都设置为私有的，然后提供set和get方法（接口）去设置和获取，在python中通过property方法可以实现。</p>
<pre><code>class Foo:
    def __init__(self,val):
    self.__NAME=val #将所有的数据属性都隐藏起来

    @property
    def name(self):
       return self.__NAME #obj.name访问的是self.__NAME(这也是真实值的存放位置)

    @name.setter
    def name(self,value):
       if not isinstance(value,str):  #在设定值之前进行类型检查
          raise TypeError(&apos;%s must be str&apos; %value)
       self.__NAME=value #通过类型检查后,将值value存放到真实的位置self.__NAME

    @name.deleter
    def name(self):
       raise TypeError(&apos;Can not delete&apos;)

f=Foo(&apos;egon&apos;)
print(f.name)
# f.name=10 #抛出异常&apos;TypeError: 10 must be str&apos;
del f.name #抛出异常&apos;TypeError: Can not delete&apos;
</code></pre><p>不用装饰器</p>
<pre><code>class Foo:
    def __init__(self,val):
          self.__NAME=val #将所有的数据属性都隐藏起来

    def getname(self):
       return self.__NAME #obj.name访问的是self.__NAME(这也是真实值的存放位置)

    def setname(self,value):
       if not isinstance(value,str):  #在设定值之前进行类型检查
          raise TypeError(&apos;%s must be str&apos; %value)
        self.__NAME=value #通过类型检查后,将值value存放到真实的位置self.__NAME

    def delname(self):
       raise TypeError(&apos;Can not delete&apos;)

    name=property(getname,setname,delname) #不如装饰器的方式清晰
</code></pre><h1 id="staticmethod（静态方法）"><a href="#staticmethod（静态方法）" class="headerlink" title="staticmethod（静态方法）"></a>staticmethod（静态方法）</h1><p>通常情况下，在类中定义的所有函数（注意了，这里说的就是所有，跟self啥的没关系，self也只是一个再普通不过的参数而已）都是对象的绑定方法，对象在调用绑定方法时会自动将自己作为参数传递给方法的第一个参数。除此之外还有两种常见的方法：静态方法和类方法，二者是为类量身定制的，但是实例非要使用，也不会报错。静态方法的好处是可以不实例化就可以调用类。</p>
<p>是一种普通函数，位于类定义的命名空间中，不会对任何实例类型进行操作，python为我们内置了函数staticmethod来把类中的函数定义成静态方法</p>
<pre><code>class Foo:
    def spam(x,y,z): #类中的一个函数，千万不要懵逼，self和x啥的没有不同都是参数名
       print(x,y,z)
spam=staticmethod(spam) #把spam函数做成静态方法
</code></pre><p>基于之前所学装饰器的知识，@staticmethod 等同于spam=staticmethod(spam),于是</p>
<pre><code>class Foo:
    @staticmethod #装饰器
    def spam(x,y,z):
       print(x,y,z)
</code></pre><p>使用演示</p>
<pre><code>print(type(Foo.spam)) #类型本质就是函数
Foo.spam(1,2,3) #调用函数应该有几个参数就传几个参数

f1=Foo()
f1.spam(3,3,3) #实例也可以使用,但通常静态方法都是给类用的,实例在使用时丧失了自动传值的机制

&lt;class &apos;function&apos;&gt;
2 3
3 3
</code></pre><p>应用场景:编写类时需要采用很多不同的方式来创建实例，而我们只有一个<strong>init</strong>函数，此时静态方法就派上用场了</p>
<pre><code>class Date:
    def __init__(self,year,month,day):
       self.year=year
       self.month=month
        self.day=day
    @staticmethod
    def now(): #用Date.now()的形式去产生实例,该实例用的是当前时间
       t=time.localtime() #获取结构化的时间格式
        return Date(t.tm_year,t.tm_mon,t.tm_mday) #新建实例并且返回
    @staticmethod
    def tomorrow():#用Date.tomorrow()的形式去产生实例,该实例用的是明天的时间
       t=time.localtime(time.time()+86400)
        return Date(t.tm_year,t.tm_mon,t.tm_mday)

a=Date(&apos;1987&apos;,11,27) #自己定义时间
b=Date.now() #采用当前时间
c=Date.tomorrow() #采用明天的时间

print(a.year,a.month,a.day)
print(b.year,b.month,b.day)
print(c.year,c.month,c.day)
</code></pre><h1 id="classmethod（类方法）"><a href="#classmethod（类方法）" class="headerlink" title="classmethod（类方法）"></a>classmethod（类方法）</h1><p>classmethod修饰符对应的函数不需要实例化，不需要 self 参数，但第一个参数需要是表示自身类的cls参数，可以来调用类的属性，类的方法，实例化对象等。</p>
<p>类方法是给类用的，类在使用时会将类本身当做参数传给类方法的第一个参数，python为我们内置了函数classmethod来把类中的函数定义成类方法</p>
<pre><code>class A:
    x=1
    @classmethod
    def test(cls):
       print(cls,cls.x)

class B(A):
    x=2
B.test()
</code></pre><p>输出结果:</p>
<pre><code>&lt;class &apos;__main__.B&apos;&gt; 2
</code></pre><p>应用场景：</p>
<pre><code>import time
class Date:
    def __init__(self,year,month,day):
       self.year=year
        self.month=month
        self.day=day
    @staticmethod
    def now():
       t=time.localtime()
       return Date(t.tm_year,t.tm_mon,t.tm_mday)

class EuroDate(Date):
    def __str__(self):
       return &apos;year:%s month:%s day:%s&apos; %(self.year,self.month,self.day)

e=EuroDate.now()
print(e) #我们的意图是想触发EuroDate.__str__,但是结果为
</code></pre><p>输出结果:</p>
<pre><code>&lt;__main__.Date object at 0x1013f9d68&gt;
</code></pre><p>因为e就是用Date类产生的,所以根本不会触发EuroDate._str__,解决方法就是用classmethod</p>
<pre><code>import time
class Date:
    def __init__(self,year,month,day):
        self.year=year
        self.month=month
        self.day=day
    #@staticmethod
    #def now():
    #        t=time.localtime()
    #         return Date(t.tm_year,t.tm_mon,t.tm_mday)

    @classmethod #改成类方法
    def now(cls):
       t=time.localtime()
       return cls(t.tm_year,t.tm_mon,t.tm_mday) #哪个类来调用,即用哪个类cls来实例化

class EuroDate(Date):
    def __str__(self):
       return &apos;year:%s month:%s day:%s&apos; %(self.year,self.month,self.day)

e=EuroDate.now()
print(e) #我们的意图是想触发EuroDate.__str__,此时e就是由EuroDate产生的,所以会如我们所愿
</code></pre><p>输出结果:</p>
<pre><code>year:2017 month:3 day:3
</code></pre><p>强调，注意注意注意：静态方法和类方法虽然是给类准备的，但是如果实例去用，也是可以用的，只不过实例去调用的时候容易让人混淆，不知道你要干啥</p>
<pre><code>x=e.now() #通过实例e去调用类方法也一样可以使用,静态方法也一样
print(x)
</code></pre><p>输出结果:</p>
<pre><code>year:2017 month:3 day:3
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Property（特性）&quot;&gt;&lt;a href=&quot;#Property（特性）&quot; class=&quot;headerlink&quot; title=&quot;Property（特性）&quot;&gt;&lt;/a&gt;Property（特性）&lt;/h1&gt;&lt;h2 id=&quot;什么是特性property&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GitLab安装与汉化</title>
    <link href="http://yjscloud.com/2018/03/08/GitLab%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B1%89%E5%8C%96/"/>
    <id>http://yjscloud.com/2018/03/08/GitLab安装与汉化/</id>
    <published>2018-03-08T14:30:54.000Z</published>
    <updated>2018-03-08T14:59:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gitlab-ce安装"><a href="#gitlab-ce安装" class="headerlink" title="gitlab-ce安装"></a>gitlab-ce安装</h1><p>GitLab是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。GitLab拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。</p>
<p>1）基础环境准备</p>
<pre><code>yum install curl policycoreutils openssh-server openssh-clients postfix
systemctl start postfix
systemctl enable postfix
systemctl enable sshd
systemctl start sshd
</code></pre><p> 2）安装gitlab-ce</p>
<pre><code>curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash
yum install -y gitlab-ce
</code></pre><p>注：由于网络问题，国内用户，建议使用清华大学的镜像源进行安装：</p>
<pre><code>[root@git ~]# vim /etc/yum.repos.d/gitlab-ce.repo
[gitlab-ce]
name=gitlab-ce
baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/
repo_gpgcheck=0
gpgcheck=0
enabled=1
gpgkey=https://packages.gitlab.com/gpg.key
[root@git ~]# yum makecache
[root@git ~]# yum install gitlab-ce
</code></pre><p>3）配置并启动gitlab-ce</p>
<pre><code>gitlab-ctl reconfigure
</code></pre><p>可以使用gitlab-ctl管理gitlab，例如查看gitlab状态：</p>
<pre><code>[root@git ~]# gitlab-ctl status
run: gitlab-workhorse: (pid 12171) 231s; run: log: (pid 7817) 555s
run: logrotate: (pid 12175) 230s; run: log: (pid 7832) 548s
run: nginx: (pid 12181) 230s; run: log: (pid 7823) 549s
run: postgresql: (pid 12186) 229s; run: log: (pid 7683) 587s
run: redis: (pid 12194) 229s; run: log: (pid 7600) 592s
run: sidekiq: (pid 12198) 229s; run: log: (pid 7806) 558s
run: unicorn: (pid 14967) 6s; run: log: (pid 7774) 560s
关闭gitlab：[root@git ~]# gitlab-ctl stop
启动gitlab：[root@git ~]# gitlab-ctl start
重启gitlab：[root@git ~]# gitlab-ctl restart
</code></pre><p>登录gitlab</p>
<p>第一次登录gitlab，需要为root用户修改密码，root用户也是gitlab的超级管理员。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-1.png" alt="4-1"></p>
<h1 id="配置GitLab主机名"><a href="#配置GitLab主机名" class="headerlink" title="配置GitLab主机名"></a>配置GitLab主机名</h1><p>1）修改/etc/gitlab/gitlab.rb文件</p>
<pre><code>mkdir -p /etc/gitlab
touch /etc/gitlab/gitlab.rb
chmod 600 /etc/gitlab/gitlab.rb
</code></pre><p>找到如下这段代码，把external_url改成部署机器的域名或者IP地址，如我的电脑ip地址就是 192.168.0.14</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-2.png" alt="4-2"></p>
<p>2）修改/var/opt/gitlab/gitlab-rails/etc/gitlab.yml文件</p>
<pre><code>vim /var/opt/gitlab/gitlab-rails/etc/gitlab.yml
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/4-3.png" alt="4-3"></p>
<p>执行命令：gitlab-ctl reconfigure</p>
<p>如果还是不能正常访问的话，查看80端口是否被占用？ 有时候80端口可能被apache给暂用了，针对此问题，直接停用apache服务，或者修改apache的默认端口。</p>
<p>到此为止，gitlab的web管理页面就可以正常访问，并通过自定义域名访问了。</p>
<h1 id="端口被占用"><a href="#端口被占用" class="headerlink" title="端口被占用"></a>端口被占用</h1><p>如果出现如下页面可以尝试修改gitlab的端口</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-4.png" alt="4-4"></p>
<pre><code>vim /etc/gitlab/gitlab.rb
</code></pre><p>将external_url 直接输入 ip加上端口号 ，比如因为80端口被占用，我直接输入7777端口</p>
<pre><code>external_url &apos;http://192.168.0.14:7777
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/4-5.png" alt="4-5"></p>
<p>修改NGINX监听的端口为7777</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-6.png" alt="4-6"></p>
<p>修改完毕之后执行命令：gitlab-ctl reconfigure</p>
<h1 id="修改Gitlab数据存储路径"><a href="#修改Gitlab数据存储路径" class="headerlink" title="修改Gitlab数据存储路径"></a>修改Gitlab数据存储路径</h1><p>默认的Gitlab数据存储路径，在目录/var/opt/gitlab/git-data下，但是新的CentOS服务器根目录分配的空间比较小，为了防止以后数据过大，所以可以修改路径存储为/data/gitlabData。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-7.png" alt="4-7"></p>
<p>修改完毕之后执行命令：gitlab-ctl reconfigure</p>
<p>设置完后，过一段使用时间，可以看到该目录下的resposities，如下所示：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-8.png" alt="4-8"></p>
<h1 id="汉化gitlab"><a href="#汉化gitlab" class="headerlink" title="汉化gitlab"></a>汉化gitlab</h1><p>1) 安装git</p>
<pre><code>yum -y install git
</code></pre><p>2)克隆获取汉化版本库</p>
<p>下载最新的汉化包</p>
<pre><code>git clone https://gitlab.com/xhang/gitlab.git
</code></pre><p> 如果是要下载老版本的汉化包，需要加上老版本的分支，比如今天已经是10.5.2，我依旧想下载10.0.2，可以运行下面的语句</p>
<pre><code>git clone https://gitlab.com/xhang/gitlab.git -b v10.0.2-zh
</code></pre><p>3)查看该汉化补丁及gitlab的版本</p>
<pre><code>cat /opt/gitlab/embedded/service/gitlab-rails/VERSION
cat gitlab/VERSION
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/4-9.png" alt="4-9"></p>
<p>4)停止gitlab服务</p>
<pre><code>gitlab-ctl stop
</code></pre><p>5)切换到gitlab汉化包所在的目录（即步骤二获取的汉化版gitlab）</p>
<pre><code>cd /root/gitlab
</code></pre><p>6)比较汉化标签和原标签，导出 patch 用的 diff 文件到/root下 </p>
<pre><code>git diff v10.5.2 v10.5.2-zh &gt; ../10.5.2-zh.diff
</code></pre><p>7)将10.5.2-zh.diff作为补丁更新到gitlab中 </p>
<pre><code>cd ~
yum install patch -y
patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 10.5.2-zh.diff
</code></pre><p>8)重新配置gitlab </p>
<pre><code>gitlab-ctl start
gitlab-ctl reconfigure
</code></pre><p>登录gitlab界面查看</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/4-10.png" alt="4-10"></p>
<p>汉化完成！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;gitlab-ce安装&quot;&gt;&lt;a href=&quot;#gitlab-ce安装&quot; class=&quot;headerlink&quot; title=&quot;gitlab-ce安装&quot;&gt;&lt;/a&gt;gitlab-ce安装&lt;/h1&gt;&lt;p&gt;GitLab是一个利用 Ruby on Rails 开发的开源应用程
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git学习" scheme="http://yjscloud.com/tags/Git%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>DNS实战</title>
    <link href="http://yjscloud.com/2018/03/01/DNS%E5%AE%9E%E6%88%98/"/>
    <id>http://yjscloud.com/2018/03/01/DNS实战/</id>
    <published>2018-03-01T13:00:23.000Z</published>
    <updated>2018-03-01T15:11:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS简介"><a href="#DNS简介" class="headerlink" title="DNS简介"></a>DNS简介</h1><h2 id="DNS概况"><a href="#DNS概况" class="headerlink" title="DNS概况"></a>DNS概况</h2><p>DNS（Domain Name System，域名系统），因特网上作为域名和IP地址互相映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。</p>
<p>DNS的分布数据库是以域名为索引的，每个域名实际上就是一棵很大的逆向树中路径，这棵逆向树称为域名空间（domain name space），如下图所示树的最大深度不得超过127层，树中每个节点都有一个可以长达63个字符的文本标号。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-1.png" alt="3-1"></p>
<h2 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h2><p>首先，客户端检测自身缓存，如果没有，检测hosts文件，如果没有，客户端发出DNS请求翻译IP地址或者主机名。DNS服务器在收到客户机的请求后：</p>
<p>1）检查DNS服务器的缓存，若查到请求的地址或名字，即向客户机发出应答信息；</p>
<p>2）若没有查到，则在数据库中查找，若查到请求的地址或名字，即向客户机发出应答信息；</p>
<p>3）若没有查到，则将请求发给根域DNS服务器，并依序从根域查找顶级域，由顶级域查找二级域，二级域查找三级，直至找到要解析的地址或名字，即向客户机所在网络的DNS服务器发出应答信息，DNS服务器收到应答后先在缓存中存储，然后将解析结果发给客户机。</p>
<p>4）若没有找到，则返回错误信息。</p>
<h2 id="DNS分类"><a href="#DNS分类" class="headerlink" title="DNS分类"></a>DNS分类</h2><p>主DNS服务器：就是一台存储着原始资料的DNS服务。</p>
<p>从DNS服务器：使用自动更新方式从主DNS服务器同步数据的DNS服务器。也称辅助DNS服务器。</p>
<p>备注：一般生产环境，主DNS服务器做管理使用，从DNS服务器提供服务。</p>
<p>缓存服务器：不负责本地解析，采用递归方式转发客户机查询请求，并返回结果给客户机的DNS服务器。同时缓存查询回来的记过，也叫递归服务器。</p>
<p>转发器：这台DNS发现非本机负责的查询请求时，不再向根域发起请求，而是直接转发给指定的一台或者多台服务器。自身并不缓存查询结果。</p>
<h2 id="DNS中记录类型"><a href="#DNS中记录类型" class="headerlink" title="DNS中记录类型"></a>DNS中记录类型</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-2.png" alt="3-2"></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-3.png" alt="3-3"></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-4.png" alt="3-4"></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-5.png" alt="3-5"></p>
<h2 id="DNS命名规范"><a href="#DNS命名规范" class="headerlink" title="DNS命名规范"></a>DNS命名规范</h2><p>1)26个英文字母</p>
<p>2)“0,1,2,3,4,5,6,7,8,9,”十个数字</p>
<p>3)“-”（英文中的连词号）</p>
<p>4)最多63字节长度</p>
<p>备注：要不按照这个规范命名，bing支不支持？ 支持，不合适，不建议。 非要不按照这个，怎么办？ master-view文件上配置check-name ignore;</p>
<h2 id="DNS三个命令介绍（dig、host、nslookup）"><a href="#DNS三个命令介绍（dig、host、nslookup）" class="headerlink" title="DNS三个命令介绍（dig、host、nslookup）"></a>DNS三个命令介绍（dig、host、nslookup）</h2><p>安装必要软件包：yum  install  bind-utils -y</p>
<h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>工具软件dig可以显示整个查询过程</p>
<pre><code>dig yjscloud.com
</code></pre><p>上面的命令会输出四段信息；</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-6.png" alt="3-6"></p>
<p>第一段是查询参数和统计</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-7.png" alt="3-7"></p>
<p>第二段是查询内容</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-8.png" alt="3-8"></p>
<p>第三段是DNS服务器的答复。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-9.png" alt="3-9"></p>
<p>上面结果表示，yjscloud.com的CNAME记录指向yjscloud.github.io.；而yjscloud.github.io.的CNAME记录指向sni.github.map.fastly.net.；也就是说，用户查询yjscloud.com的时候，实际上返回的是sni.github.map.fastly.net.的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改sni.github.map.fastly.net.这个域名就可以了，用户yjscloud.com域名不用修改。sni.github.map.fastly.net.有一个A记录，即一个IP地址。532、3532、4都是TTL值（time to live的缩写），表示缓存时间，即表示在这些时间内不用重新查询。</p>
<p>第四段是DNS服务器的一些传输信息。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-10.png" alt="3-10"></p>
<p>上面结果显示，本机的DNS服务器是192.168.16.1，查询端口是53（DNS服务器的默认端口），以及回应长度是117字节。</p>
<p>如果不想看到这么多内容，可以使用+short参数</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-11.png" alt="3-11"></p>
<p>使用+trace参数可以显示DNS的整个分级查询过程。</p>
<pre><code>dig yjscloud.com +trace
</code></pre><p>上面命令的第一段列出根域名.的所有NS记录，即所有根域名服务器。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-12.png" alt="3-12"></p>
<p>根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问yjscloud.com的顶级域名服务器com.的NS记录。</p>
<p>最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。</p>
<p>接着是第二段。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-13.png" alt="3-13"></p>
<p>上面结果显示.com域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。</p>
<p>然后，DNS服务器向这些顶级域名服务器发出查询请求，询问yjscloud.com的NS记录。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-14.png" alt="3-14"></p>
<p>上面结果显示yjscloud.com有两条NS记录，同时返回的还有每一条NS记录对应的IP地址。然后，DNS服务器向上面这两台NS服务器查询yjscloud.com的主机名。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-15.png" alt="3-15"></p>
<p>上面结果显示，yjscloud.com有一条CNAME记录，两条NS记录，最先返回结果的NS服务器是f1g1ns1.dnspod.net.，IP地址为58.247.212.36。</p>
<h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p>host命令可以看作dig命令的简化版本，返回当前请求域名的各种记录。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-16.png" alt="3-16"></p>
<p>host命令也可以用于逆向查询，即从IP地址查询域名，等同于dig -x <ip>。</ip></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-17.png" alt="3-17"></p>
<h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>nslookup命令用于互动式地查询域名记录。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-18.png" alt="3-18"></p>
<p><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="external">DNS入门原理</a></p>
<h1 id="DNS安装部署"><a href="#DNS安装部署" class="headerlink" title="DNS安装部署"></a>DNS安装部署</h1><h2 id="192-168-16-111（主DNS）安装"><a href="#192-168-16-111（主DNS）安装" class="headerlink" title="192.168.16.111（主DNS）安装"></a>192.168.16.111（主DNS）安装</h2><p>安装DNS： yum  install  -y bind-utils bind bind-devel bind-chroot</p>
<p>检查是否安装完成：rpm -qa | grep bind</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-19.png" alt="3-19"></p>
<p>配置named.conf文件</p>
<pre><code>mv  /etc/named .conf  /etc/named .conf.bak
vim  /etc/named .conf
</code></pre><p>配置文件的内容为：</p>
<pre><code>options {
   version &quot;1.1.1&quot;;
   listen-on port 53 {any;};
   directory &quot;/var/named/chroot/etc/&quot;;
   pid-file &quot;/var/named/chroot/var/run/named/named.pid&quot;;
   allow-query { any; };
   Dump-file &quot;/var/named/chroot/var/log/binddump.db&quot;;
   Statistics-file &quot;/var/named/chroot/var/log/named_stats&quot;;
   zone-statistics yes;
   memstatistics-file &quot;log/mem_stats&quot;;
   empty-zones-enable no;
   forwarders {202.106.196.115;8.8.8.8; };
};

key &quot;rndc-key&quot; {
        algorithm hmac-md5;
        secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};

controls {
       inet 127.0.0.1 port 953
               allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };
};

logging {
    channel warning {
        file &quot;/var/named/chroot/var/log/dns_warning&quot; versions 10 size 10m;
        severity warning;
        print-category yes;
        print-severity yes;
        print-time yes;
 };
    channel general_dns {
    file &quot;/var/named/chroot/var/log/dns_log&quot; versions 10 size 100m;
    severity info;
    print-category yes;
    print-severity yes;
    print-time yes;
 };
category default {
  warning;
 };
category queries {
  general_dns;
 };
};

include &quot;/var/named/chroot/etc/view.conf&quot;;
</code></pre><p>配置rndc.key文件</p>
<pre><code>vim /etc/rndc.key

key &quot;rndc-key&quot; {
        algorithm hmac-md5;
        secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};
</code></pre><p>配置rndc.conf文件</p>
<pre><code>vim /etc/rndc.conf

key &quot;rndc-key&quot; {
        algorithm hmac-md5;
        secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};

options {
        default-key &quot;rndc-key&quot;;
        default-server 127.0.0.1;
        default-port 953;
};
</code></pre><p>配置view.conf文件</p>
<pre><code>vim /var/named/chroot/etc/view.conf

view &quot;View&quot; {
    zone &quot;yjs.com&quot; {
            type    master;
            file    &quot;yjscloud.com.zone&quot;;
            allow-transfer {
                    192.168.16.112;
            };
            notify  yes;
            also-notify {
                    192.168.16.112;
            };
    };
};
</code></pre><p>配置yjscloud.com.zone文件</p>
<pre><code>vim /var/named/chroot/etc/yjscloud.com.zone

$ORIGIN .
$TTL 3600       ; 1 hour
yjs.com                  IN SOA  op.yjs.com. dns.yjs.com. (
                                2000       ; serial
                                900        ; refresh (15 minutes)
                                600        ; retry (10 minutes)
                                86400      ; expire (1 day)
                                3600       ; minimum (1 hour)
                                )
                        NS      op.yjs.com.
$ORIGIN yjs.com.
shanks              A       1.2.3.4
op              A       1.2.3.4
a               A       1.2.3.4
</code></pre><p>1）Serial：只是一个序号，但这个序号可被用来作为slave与master更新的依据。</p>
<p>举例来说，master序号为100但slave序号为90时，那么这个zone file的资料就会被传送到slave来更新了。由于这个序号代表新旧资料，通常我们建议你可以利用日期来设定。例如上面的资料是在2015/10/20所写的第一次，所以用2015102001作为序号代表。（yyyymmddnn，nn代表这一天是第几次修改）</p>
<p>2）Refresh：除了根据Serial来判断新旧之外，我们可以利用这个refresh（更新）命令slave多久进行一次主动更新、</p>
<p>3）Retry：如果到了Refresh的时间，但是slave却无法连接到master时，那么在多久之后，slave会再次的主动尝试与主机连接。</p>
<p>4）Expire：如果slave一直无法与master连接上，那么经过多久的时间之后，则命令slave不要再连接了。也就是说，此时我们假设masterDNS可能遇到重大问题而无法上线，则等待系统管理员处理完毕后，再重新到slaveDNS重启bind。</p>
<p>5）Minimum：这个类似TTL。<br>修改目录权限，并启动服务</p>
<pre><code>cd /var &amp;&amp; chown -R named.named named/
/etc/init.d/named start
chkconfig named on
</code></pre><p>解析测试</p>
<pre><code>dig @127.0.0.1 a.yjs.com
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-20.png" alt="3-20"></p>
<h2 id="192-168-16-112（从DNS）"><a href="#192-168-16-112（从DNS）" class="headerlink" title="192.168.16.112（从DNS）"></a>192.168.16.112（从DNS）</h2><pre><code>yum install -y bind-utils bind bind-devel bind-chroot
</code></pre><p>配置named.conf文件</p>
<pre><code>mv /etc/named.conf /etc/named.conf.bak
vim /etc/named.conf

options {
    version &quot;1.1.1&quot;;
    listen-on port 53 {any;};
    directory &quot;/var/named/chroot/etc/&quot;;
   pid-file &quot;/var/named/chroot/var/run/named/named.pid&quot;;
   allow-query { any; };
   Dump-file &quot;/var/named/chroot/var/log/binddump.db&quot;;
   Statistics-file &quot;/var/named/chroot/var/log/named_stats&quot;;
   zone-statistics yes;
   memstatistics-file &quot;log/mem_stats&quot;;
   empty-zones-enable no;
   forwarders {202.106.196.115;8.8.8.8; };
};

key &quot;rndc-key&quot; {
        algorithm hmac-md5;
        secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};

controls {
       inet 127.0.0.1 port 953
               allow { 127.0.0.1; } keys { &quot;rndc-key&quot;; };
};

logging {
    channel warning {
        file &quot;/var/named/chroot/var/log/dns_warning&quot; versions 10 size 10m;
        severity warning;
        print-category yes;
        print-severity yes;
        print-time yes;
    };
    channel general_dns {
        file &quot;/var/named/chroot/var/log/dns_log&quot; versions 10 size 100m;
        severity info;
        print-category yes;
        print-severity yes;
        print-time yes;
   };
   category default {
        warning;
    };
   category queries {
     general_dns;
  };
};

include &quot;/var/named/chroot/etc/view.conf&quot;;
</code></pre><p>配置rndc.key文件</p>
<pre><code>vim /etc/rndc.key

key &quot;rndc-key&quot; {
          algorithm hmac-md5;
          secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};
</code></pre><p>配置rndc.conf文件</p>
<pre><code>vim /etc/rndc.conf

key &quot;rndc-key&quot; {
         algorithm hmac-md5;
       secret &quot;Eqw4hClGExUWeDkKBX/pBg==&quot;;
};

options {
         default-key &quot;rndc-key&quot;;
       default-server 127.0.0.1;
         default-port 953;
};
</code></pre><p>备注：主从DNS主机配置named.conf、rndc.key、rndc.conf文件一样</p>
<p>配置view.conf文件</p>
<pre><code>vim /var/named/chroot/etc/view.conf

view &quot;SlaveView&quot; {
        zone &quot;yjs.com&quot; {
                 type    slave;
                 masters {192.168.16.111; };
                 file    &quot;slave.yjscloud.com.zone&quot;;
        };    
};
</code></pre><p>修改目录权限，并启动服务</p>
<pre><code>cd /var &amp;&amp; chown -R named.named named/
/etc/init.d/named start
chkconfig named on
</code></pre><p>进入目录/var/named/chroot/etc</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-21.png" alt="3-21"></p>
<p>如果有slave。yjscloud.com.zone这个文件说明主从已经同步</p>
<h2 id="添加A、CNAME、MX、PTR记录（主DNS）"><a href="#添加A、CNAME、MX、PTR记录（主DNS）" class="headerlink" title="添加A、CNAME、MX、PTR记录（主DNS）"></a>添加A、CNAME、MX、PTR记录（主DNS）</h2><h3 id="A记录"><a href="#A记录" class="headerlink" title="A记录"></a>A记录</h3><p>编辑master节点/var/named/chroot/etc/yjscloud.com.zone，在文件末尾添加记录</p>
<pre><code>a               A       192.168.1.100
将serial + 1
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-22.png" alt="3-22"></p>
<p>执行rndc reload</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-23.png" alt="3-23"></p>
<p>检查从DNS主机，slave.yjscloud.com.zone文件已同步更新。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-24.png" alt="3-24"></p>
<h3 id="CNAME记录"><a href="#CNAME记录" class="headerlink" title="CNAME记录"></a>CNAME记录</h3><p>编辑master节点/var/named/chroot/etc/yjscloud.com.zone，在文件末尾添加记录</p>
<pre><code>cname       CNAME   a.yjs.com.
将serial + 1
</code></pre><p>执行rndc reload</p>
<p>检查从DNS主机，slave.yjscloud.com.zone文件已同步更新。</p>
<p>测试 host a.swj.com 127.0.0.1</p>
<h3 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h3><p>编辑master节点/var/named/chroot/etc/shhnwangjian.com.zone，在文件末尾添加记录</p>
<pre><code>mx      MX 5    192.168.1.101
将serial + 1
</code></pre><p>执行rndc reload</p>
<p>检查从DNS主机，slave.shhnwangjian.com.zone文件已同步更新。</p>
<p>测试 host mx.swj.com 127.0.0.1</p>
<h2 id="PTR记录（反向解析）"><a href="#PTR记录（反向解析）" class="headerlink" title="PTR记录（反向解析）"></a>PTR记录（反向解析）</h2><p>编辑master节点/var/named/chroot/etc/view.conf，加入ptr的zone配置</p>
<pre><code>zone &quot;168.192.in-addr.arpa&quot; {
  type    master;
 file    &quot;168.192.zone&quot;;
 allow-transfer{
       192.168.16.1112;
 };
 notify  yes;
 also-notify{
     192.168.16.112;
 };
};
</code></pre><p>在下面这个位置加入代码：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-25.png" alt="3-25"></p>
<p>编辑master节点/var/named/chroot/etc/168.192.zone</p>
<pre><code>$TTL 3600       ; 1 hour
@                   IN SOA  op.yjs.com. dns.yjs.com. (
                            2003       ; serial
                            900        ; refresh (15 minutes)
                            600        ; retry (10 minutes)
                            86400      ; expire (1 day)
                            3600       ; minimum (1 hour)
                            )
                    NS      op.yjs.com.
100.1               IN  PTR a.yjs.com.
</code></pre><p>修改168.192.zone文件属主</p>
<pre><code>chown named.named 168.192.zone
rndc reload
</code></pre><p>编辑slave节点/var/named/chroot/etc/view.conf，加入ptr的zone配置</p>
<pre><code>zone &quot;168.192.in-addr.arpa&quot; {
     type    slave;
     masters {192.168.16.111; };
     file    &quot;slave.168.192.zone&quot;;
};
</code></pre><p>在下面的这个位置加入代码：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-26.png" alt="3-26"></p>
<p>执行rndc reload</p>
<p>slava节点/var/named/chroot/etc目录下生成slave.168.192.zone文件。</p>
<p>解析测试: host 192.168.1.100 127.0.0.1</p>
<h2 id="DNS实现服务的负载均衡"><a href="#DNS实现服务的负载均衡" class="headerlink" title="DNS实现服务的负载均衡"></a>DNS实现服务的负载均衡</h2><p>编辑master节点/var/named/chroot/etc/yjscloud.com.zone，在文件末尾添加记录</p>
<pre><code>a               A       192.168.1.102
将serial + 1
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-27.png" alt="3-27"></p>
<p>执行rndc reload</p>
<p>master和slave执行解析：nslookup a.yjs.com 127.0.0.1，结果如下（轮询）</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-28.png" alt="3-28"></p>
<h3 id="配置DNS视图（智能DNS）"><a href="#配置DNS视图（智能DNS）" class="headerlink" title="配置DNS视图（智能DNS）"></a>配置DNS视图（智能DNS）</h3><p>编辑master节点/var/named/chroot/etc/named.conf，在include上面添加（对客户端IP分组）</p>
<pre><code>acl group1 {
 192.168.137.13;
};

acl group2 {
 192.168.137.14;
};
</code></pre><p>编辑master节点/var/named/chroot/etc/view.conf（清空原view.conf文件的内容再添加）</p>
<pre><code>view &quot;GROUP1&quot; {
 match-clients { group1; };
 zone &quot;viewyjs.com&quot; {
    type master;
    file &quot;group1.viewyjs.com.zone&quot;;
  };
};

view &quot;GROUP2&quot; {
 match-clients { group2; };
 zone &quot;viewyjs.com&quot; {
    type master;
    file &quot;group2.viewyjs.com.zone&quot;;
 };
};
</code></pre><p>编辑master节点/var/named/chroot/etc/group1.viewyjs.com.zone</p>
<pre><code>$ORIGIN .
$TTL 3600       ; 1 hour
viewyjs.com                  IN SOA  op.viewyjs.com. dns.viewyjs.com. (
                            2000       ; serial
                            900        ; refresh (15 minutes)
                            600        ; retry (10 minutes)
                            86400      ; expire (1 day)
                            3600       ; minimum (1 hour)
                            )
                    NS      op.viewyjs.com.
$ORIGIN viewyjs.com.
view              A       192.168.122.1
op              A       192.168.122.1
</code></pre><p>编辑master节点/var/named/chroot/etc/group2.viewyjs.com.zone</p>
<pre><code>$ORIGIN .
$TTL 3600       ; 1 hour
viewyjs.com                  IN SOA  op.viewyjs.com. dns.viewyjs.com. (
                            2000       ; serial
                            900        ; refresh (15 minutes)
                            600        ; retry (10 minutes)
                            86400      ; expire (1 day)
                            3600       ; minimum (1 hour)
                            )
                    NS      op.viewyjs.com.
$ORIGIN viewyjs.com.
view              A       192.168.122.2
op              A       192.168.122.2
</code></pre><p>修改文件属主，加载配置</p>
<pre><code>chown named.named /var/named/chroot/etc/group*.zone
rndc reload
</code></pre><p>测试，在192.168.16.111主机上执行host view.viewyjs.com 192.168.16.111</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-29.png" alt="3-29"></p>
<p>在192.168.16.112主机上执行host view.viewyjs.com 192.168.16.111</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-30.png" alt="3-30"></p>
<h1 id="构建DNS（企业级）"><a href="#构建DNS（企业级）" class="headerlink" title="构建DNS（企业级）"></a>构建DNS（企业级）</h1><h2 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h2><p>CPU：12C以上配置</p>
<p>内存：16G</p>
<p>网络：千兆</p>
<h2 id="初始化系统配置"><a href="#初始化系统配置" class="headerlink" title="初始化系统配置"></a>初始化系统配置</h2><p>关闭 iptables</p>
<p>service iptables stop<br>chkconfig iptables off<br>关闭 selinux<br>vi /etc/sysconfig/selinux<br>SELINUX=disabled</p>
<h2 id="高性能、高可用DNS"><a href="#高性能、高可用DNS" class="headerlink" title="高性能、高可用DNS"></a>高性能、高可用DNS</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/3-31.png" alt="3-31"></p>
<p>1）高可用</p>
<p>物理层：首先确保两台lvs不在同一机柜、同一物理交换机接入；其次确保将所有dns服务器也做到不在同一机柜、同一物理交换机接入；在不通的idc构建多套dns集群，为客户端提供可切换的配置。</p>
<p>服务层：坚决摒弃lvs上端口检测这种方式，采用自定义脚本检测，为dns的健康检测单独设置一个域名，为了lvs检测dns是否存活而设计。</p>
<p>客户端层：多idc之间的流量切换是通过客户端的健康检测cron实现的，脚本可以按分钟运行一次，分别检测每个dns集群虚地址的可用性。</p>
<pre><code>#!/bin/sh
timeout=5
Q=&quot;&quot;
host=&quot;/usr/bin/host&quot;
if test -z &quot;$1&quot; ; then
    echo &quot;You need to supply a DNS server to check. Quittind&quot;
    exit;
fi
SERVER=$10
ERC=`$host -s -w $timeout $Q SERVER &gt; /dev/null 2&gt;$1; echo $?`
if [ $ERC -eq 0 ] ; then
    exit 0
else
    exit 10
fi
</code></pre><p>2）高性能</p>
<p>   通过lvs可以对每个集群做横向扩容，是否需要扩容的依据是对现有系统的压测结果，以及实时的监控数据。或者可以在最靠近应用层处，加上一次cache-only集群，但前提是你的线上环境中，没有任何系统依赖于dns负载均衡。</p>
<h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><p>将bind-9.9.9-P1.tar.gz下载到合适的目录下</p>
<p>下载bind源码:</p>
<pre><code>wget http://ftp.isc.org/isc/bind9/9.9.1-P1/bind-9.9.9-P1.tar.gz
</code></pre><p>解压: </p>
<pre><code>tar -xvf bind-9.9.9-P1.tar.gz
cd /bind-9.9.9-P1/contrib/queryperf
</code></pre><p>编译:</p>
<pre><code>./configure
make
</code></pre><p>此目录下生成queryperf文件</p>
<pre><code>cp queryperf /usr/bin
</code></pre><p>压测自己创建的DNS服务，创建一个文件test.txt，内容如下（前面为域名，后面为A记录）</p>
<pre><code>view.viewyjs.com A
view.viewyjs.com A
view.viewyjs.com A
view.viewyjs.com A
view.viewyjs.com A
</code></pre><p>执行命令： </p>
<pre><code>queryperf -d test.txt -s 192.168.16.111
</code></pre><p>结果：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/3-32.png" alt="3-32"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DNS简介&quot;&gt;&lt;a href=&quot;#DNS简介&quot; class=&quot;headerlink&quot; title=&quot;DNS简介&quot;&gt;&lt;/a&gt;DNS简介&lt;/h1&gt;&lt;h2 id=&quot;DNS概况&quot;&gt;&lt;a href=&quot;#DNS概况&quot; class=&quot;headerlink&quot; title=&quot;DNS
    
    </summary>
    
      <category term="运维技能" scheme="http://yjscloud.com/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Linux技术" scheme="http://yjscloud.com/tags/Linux%E6%8A%80%E6%9C%AF/"/>
    
      <category term="DNS" scheme="http://yjscloud.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>saltstack自动化运维（一）</title>
    <link href="http://yjscloud.com/2018/03/01/saltstack%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yjscloud.com/2018/03/01/saltstack自动化运维（一）/</id>
    <published>2018-03-01T04:39:43.000Z</published>
    <updated>2018-03-01T05:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="saltstack简介"><a href="#saltstack简介" class="headerlink" title="saltstack简介"></a>saltstack简介</h1><p>（1）saltstack介绍</p>
<p>SaltStack是一个新的基础平台管理工具，只需要花费数分钟即可运行起来，可以支撑管理上万台服务器的规模，数秒钟即可完成数据传递。SaltStack是使用Python语言开发的，同时提供Rest API方便二次开发以及和其它平台进行集成，同时官方也发布了一个Web管理界面halite。</p>
<p>（2）saltstack运行方式</p>
<p>saltstack有三种运行方式</p>
<ul>
<li>Local</li>
<li>Master/Minion</li>
<li>Salt SSH<br>SaltStack的传统运行模式为Master/Minion（C/S结构），需要在被管理的节点上安装Minion。同时SaltStack也支持SSH的方式，无需安装Agent，通过SSH实现管理。</li>
</ul>
<p>（3）saltstack目前拥有三大功能</p>
<ul>
<li>远程执行</li>
<li>配置管理</li>
<li>云管理</li>
</ul>
<h1 id="saltstack实战部署"><a href="#saltstack实战部署" class="headerlink" title="saltstack实战部署"></a>saltstack实战部署</h1><p>SaltStack支持多种操作系统，如CentOS、RedHat、Debian、Ubuntu、FreeBSD、Solaris、Fedora、SuSe、Gentoo、MAC OS X、Archlinux等，以及Windows（仅支持Minion）。</p>
<p>saltstack服务器基本设置：CentOS7.2最小化安装，关闭防火墙，selinux设置为disabled，虚拟机网卡这里为桥接模式</p>
<h2 id="安装saltstack源"><a href="#安装saltstack源" class="headerlink" title="安装saltstack源"></a>安装saltstack源</h2><p>对于Centos和RedHat用户，使用yum安装时最直接和快捷的。首先需要CentOS和epel仓库。saltstack官方源在国外下载使用需要vpn，我直接将saltstack2016.3的源同步到本地搭建了一个本地yum源，需要下载saltstack源的朋友请自带小飞机到<code>https://repo.saltstack.com</code>去下载，以下是我的repo的配置文件：</p>
<p>CentOS和epel的repo：</p>
<pre><code>[centos]
name=centos7.2
baseurl= http://192.168.16.198:8080/centos7.2/7.2/os/x86_64/
enabled=1
gpgcheck=0

[epel]
name=epel
baseurl= http://192.168.16.198:8080/epel/7/x86_64/
enabled=1
gpgcheck=0
</code></pre><p>saltstack的repo：</p>
<pre><code>[saltstack]
name=saltstack-2016.3
baseurl= http://192.168.16.198:8080/saltstack-2016.3/
enabled=1
gpgcheck=0
</code></pre><h2 id="安装saltstack"><a href="#安装saltstack" class="headerlink" title="安装saltstack"></a>安装saltstack</h2><p>saltstack01为master，saltstack02为minion</p>
<p>在saltstack01</p>
<pre><code>yum -y install salt-master salt-minion
</code></pre><p>在saltstack02</p>
<pre><code>yum -y install salt-minion
</code></pre><h2 id="启动saltstack"><a href="#启动saltstack" class="headerlink" title="启动saltstack"></a>启动saltstack</h2><p>在saltstack01上</p>
<pre><code>systemctl start salt-master
systemctl enable salt-master
</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>在saltstack01上</p>
<pre><code>vim /etc/salt/minion
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-1.png" alt="2-1"></p>
<p>启动salt-minion</p>
<pre><code>systemctl start salt-minion
systemctl enable salt-minion
</code></pre><p>在saltstack02上</p>
<pre><code>vim /etc/salt/minion2
</code></pre><p>启动salt-minion</p>
<pre><code>systemctl start salt-minion
systemctl enable salt-minion
</code></pre><h2 id="远程执行"><a href="#远程执行" class="headerlink" title="远程执行"></a>远程执行</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-2.png" alt="2-2"></p>
<p>认证命令：salt-key</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-3.png" alt="2-3"></p>
<p>同意公钥key</p>
<pre><code>salt-key -a saltstack01
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-4.png" alt="2-4"></p>
<p>还可以使用通配符：</p>
<pre><code>salt-key -a saltstack*  #-A表示同意所有
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-5.png" alt="2-5"></p>
<p>同意后查看pki</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-6.png" alt="2-6"></p>
<p>远程执行命令:</p>
<pre><code>语法： 命令 目标 模块.方法 方法参数
salt &apos;*&apos; test.ping
</code></pre><p> 上面的命令用来查看有哪些Minion节点连接到Master。* 指的是选定的目标Minion，很显然代表所有。就是所有Minion端了。test.ping是salt远程执行的一个模块。（注意：这并不是一个ICMP ping。）</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-7.png" alt="2-7"></p>
<pre><code>salt &apos;saltstack01&apos; cmd.run &apos;w&apos;
</code></pre><p> <img src="http://opnq5yeqm.bkt.clouddn.com/2-8.png" alt="2-8"></p>
<pre><code>salt &apos;saltstack01&apos; cmd.run &apos;mkdir /tmp/yjscloud&apos;
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-9.png" alt="2-9"></p>
<h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p> Salt使用State模块文件进行配置管理，使用YAML编写，以.sls结尾。如果进行配置管理首先需要再Master的配置文件中指定”file roots”的选项，Salt支持环境的配置，比如开发环节、测试环境、生产环境，但是base环境是必须的。而且Base环境必须包含入口文件top.sls。</p>
<p>YAML: 三板斧</p>
<pre><code>1.缩进
     2个空格，不能试用Tab。
2.冒号 
     key: value
3.短横线  
      - list1
      - list2
</code></pre><p>第一步：设置file_roots<br>在saltstack01修改Master配置文件，指定file_roots：vim /etc/salt/master</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-10.png" alt="2-10"></p>
<p>重启master: systemctl restart salt-master</p>
<p>创建目录：mkdir /srv/salt</p>
<p>第二步：设置top.sls</p>
<p>在top.sls入口文件设置环境（如生产、开发、测试对应不同的minion和模块）。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-11.png" alt="2-11"></p>
<p>解释：所有的Minion均执行base目录下的init模块下的pkg-init.sls。我们可以把很多的sls放在一个目录中，方便管理。在top.sls只需要指定目录结构即可。</p>
<p>第三步：编写状态文件<br>在这个目录下创建web目录，在这个目录下编辑文件apache.sls，文件内容为：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-12.png" alt="2-12"></p>
<p>第四步：执行状态</p>
<p>执行这个文件：salt ‘*’ state.sls web.apache</p>
<p>根据上面的设置，执行完状态后。Salt会检查Minion上是否有上面编写的三个软件包。如果没有就会自动使用Yum安装上。</p>
<p>在saltstack02端查看：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-13.png" alt="2-13"></p>
<p>saltstack01将描述文件发往saltstack02让其执行</p>
<h1 id="saltstack与ZeroMQ"><a href="#saltstack与ZeroMQ" class="headerlink" title="saltstack与ZeroMQ"></a>saltstack与ZeroMQ</h1><p>saltstack底层是基于ZeroMQ进行高效的网络通信</p>
<h2 id="ZeroMQ简介"><a href="#ZeroMQ简介" class="headerlink" title="ZeroMQ简介"></a>ZeroMQ简介</h2><p>ØMQ （也拼写作ZeroMQ，0MQ或ZMQ)是一个为可伸缩的分布式或并发应用程序设计的高性能异步消息库。它提供一个消息队列, 但是与面向消息的中间件不同，ZeroMQ的运行不需要专门的消息代理（message broker）。该库设计成常见的套接字风格的API。能够提供进程内(inproc)、进程间(IPC)、网络(TCP)和广播方式的消息信道， 并支持扇出(fan-out)、发布-订阅(pub-sub)、任务分发（task distribution）、请求/响应（request-reply）等通信模式。</p>
<h2 id="saltstack第一种模式：发布与订阅"><a href="#saltstack第一种模式：发布与订阅" class="headerlink" title="saltstack第一种模式：发布与订阅"></a>saltstack第一种模式：发布与订阅</h2><p>ZeroMQ支持Publish/Subscribe，即发布与订阅模式，我们经常简称Pub/Sub。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-14.png" alt="2-14"></p>
<p>Salt Master运行两个网络服务，其中一个是ZeroMQ PUB系统，默认监听4505端口。可以通过修改/etc/salt/master配置文件的publish_port参数设置。它是salt的消息发布系统，如果查看4505端口，会发现所有的Minion连接到Master的4505端口，TCP状态持续保持为ESTABLISHED。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-15.png" alt="2-15"></p>
<h2 id="saltstack第一种模式：请求与响应"><a href="#saltstack第一种模式：请求与响应" class="headerlink" title="saltstack第一种模式：请求与响应"></a>saltstack第一种模式：请求与响应</h2><p>ZeroMQ支持Request-Reply，即请求与响应模式，我们经常简称REQ/REP。</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-16.png" alt="2-16"></p>
<p>Salt Master运行的第二个网络服务就是ZeroMQ REP系统，默认监听4506端口，可以通过修改/etc/salt/master配置文件的ret_port参数设置。</p>
<p>它是salt客户端与服务端通信的端口。比如说Minion执行某个命令后的返回值就是发送给Master的4506这个REP端口</p>
<p>如果安装了python-setproctitle软件包，所以我们可以直接看到Salt Master启动的进程的名称。</p>
<pre><code>yum  install  -y python-setproctitle
</code></pre><p>重启master和minion</p>
<pre><code>systemctl restart salt-master
systemctl restart salt-minion
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-17.png" alt="2-17"></p>
<p>备注：</p>
<pre><code>/usr/bin/salt-master  -d ProcessManager   # 中心进程管理器
/usr/bin/salt-master  -d _clear_old_jobs   # 清除旧的Jobs文件及更新fileserver
/usr/bin/salt-master  -d Publisher        # 将任务PUB到Minion端
/usr/bin/salt-master  -d EventPublisher   # Event Publisher进程
/usr/bin/salt-master  -d ReqServer_ProcessManager  # ReqServer进程管理器
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorker   # 工作进程
/usr/bin/salt-master  -d MWorkerQueue  # 将Ret接口(ROUTER)数据转发到Worker(DEALER)
</code></pre><h1 id="saltstack数据系统"><a href="#saltstack数据系统" class="headerlink" title="saltstack数据系统"></a>saltstack数据系统</h1><p>saltstack数据系统分为Grian和Pillar</p>
<h2 id="Grains"><a href="#Grains" class="headerlink" title="Grains"></a>Grains</h2><p>静态数据，当Minion启动的时候收集的MInion本地的相关信息。（包含操作系统版本、内核版本、CPU、内存、硬盘、设备型号等）</p>
<p>备注：不重启minion，这些信息数据是不会改变的。</p>
<p> 1)信息管理，包括资产管理</p>
<p> eg:</p>
<pre><code>salt  &apos;saltstack01&apos;  grains. ls   # 列出ID为saltstack01的主机，grains的所有key
salt  &apos; saltstack*&apos;  grains.items   # 列出主机的详细信息，可用于资产管理
salt  &apos;*&apos;  grains.item os   # 列出所有主机的系统版本
salt  &apos;*&apos;  grains.item fqdn_ip4   # 列出所有主机的IP地址
</code></pre><p>2)用于目标选择（查询具体id的主机，查询系统版本为centos的主机等场景）</p>
<p>eg:</p>
<pre><code>salt -G  &apos;os:Centos&apos;  test . ping   # 所有主机系统为centos版本ping测试
salt -G  &apos;os:Centos&apos;  cmd.run  &apos;echo 123&apos;   # 所有主机系统为centos版本执行命令&apos;echo 123&apos;
</code></pre><p>3)配置管理中使用</p>
<p>自定义grains的item</p>
<p>方式一：修改配置文件 vim /etc/salt/minion</p>
<p> 重启：systemctl restart salt-minion</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-18.png" alt="2-18"></p>
<p>通过自定义的item，可以实现重启所有角色为apache的主机</p>
<pre><code>salt  &apos;*&apos;  grains.item roles   # 获取所有主机的roles
salt -G  &apos;roles:apache&apos;  cmd.run  &apos;systemctl restart httpd&apos;   # 所有主机roles为apache的执行命令systemctl restart httpd
</code></pre><p>方式二：（生产环境使用）</p>
<p>修改配置文件 vim /etc/salt/grains，写法</p>
<pre><code>cloud: openstack
</code></pre><p>重启:</p>
<pre><code>systemctl restart salt-minion
salt  &apos;*&apos;  grains.item cloud   # 获取所有主机的cloud
</code></pre><p>修改/etc/salt/grains不重启服务的方法，刷新命令如下（备注：方式一和方式二修改配置文件，通过此命令都可以不用重启服务）</p>
<pre><code>salt &apos;*&apos; saltutil.sync_grains
</code></pre><p>3）grains在top file中的使用案例</p>
<pre><code>vim /srv/salt/top.sls
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-19.png" alt="2-19"></p>
<p>grains脚本目录，必须是base下创建_grains目录（如：/srv/salt/_grains）</p>
<p>创建一个python脚本在/srv/salt/_grains目录下</p>
<p>脚本名：my_grains.py</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-20.png" alt="2-20"></p>
<p>通过master同步脚本文件至每台minion</p>
<pre><code>salt &apos;*&apos; saltutil.sync_grains
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-21.png" alt="2-21"></p>
<p>文件放在minion主机的/var/cache/salt/minion/extmods/grains目录下</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-22.png" alt="2-22"></p>
<pre><code>salt  &apos;*&apos;  grains.item edu   # 获取所有主机的edu
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-23.png" alt="2-23"></p>
<p>grains优先级（item名称相同的情况下）： </p>
<ul>
<li>系统自带 </li>
<li>grains文件写到 </li>
<li>minion配置文件写的</li>
<li>自己写的脚本</li>
</ul>
<h2 id="Pillar"><a href="#Pillar" class="headerlink" title="Pillar"></a>Pillar</h2><p>动态数据，给特定的minion指定特定的数据。只有指定的minion自己能看到自己的数据。</p>
<pre><code>salt  &apos;*&apos;  pillar.items
</code></pre><p>开启系统自带，修改配置文件</p>
<pre><code>vim /etc/salt/master
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-24.png" alt="2-24"></p>
<p>重启systemctl restart salt-master</p>
<p>执行salt ‘*’ pillar.items 可以看到系统自带的item</p>
<p>piller存在文件路径设置</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-25.png" alt="2-25"></p>
<pre><code>mkdir /srv/pillar
</code></pre><p>重启systemctl restart salt-master</p>
<p>实现pillar流程</p>
<p>1）创建一个piller文件，python jinja2写法</p>
<pre><code>mkdir  /srv/pillar/web
cd  /srv/pillar/web
vim apache.sls
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-26.png" alt="2-26"></p>
<p>2）创建top file文件</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/2-27.png" alt="2-27"></p>
<pre><code>salt  &apos;*&apos;  saltutil.refresh_pillar   # 刷新
salt  &apos;*&apos;  pillar.items apache
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-28.png" alt="2-28"></p>
<p>目标选择</p>
<pre><code>salt -I  &apos;apache:httpd&apos;  test . ping
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-29.png" alt="2-29"></p>
<h2 id="Grains-VS-Pillar"><a href="#Grains-VS-Pillar" class="headerlink" title="Grains VS Pillar"></a>Grains VS Pillar</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-30.png" alt="2-30"></p>
<h1 id="深入学习saltstack远程执行"><a href="#深入学习saltstack远程执行" class="headerlink" title="深入学习saltstack远程执行"></a>深入学习saltstack远程执行</h1><p>语法例： salt ‘*’ cmd.run ‘w’</p>
<p>命令：  salt</p>
<p>目标： ‘*’</p>
<p>模块： cmd.run  自带150+模块。  自己写模块</p>
<p>返回： 执行后结果返回，Returnners</p>
<h2 id="目标：Targeting"><a href="#目标：Targeting" class="headerlink" title="目标：Targeting"></a>目标：Targeting</h2><p>两种：一种和Minion　ID有关</p>
<p>　　　一种和Minion　ID无关</p>
<p>1)Minion ID有关的方法</p>
<p> 指定具体的minion ID    </p>
<pre><code>salt &apos;saltstack01&apos; test.ping
</code></pre><p> 通配符</p>
<pre><code>salt  &apos;*&apos;  test . ping 
salt  &apos;saltstack *&apos;  test . ping
salt  &apos; saltstack[1|2]&apos;  test . ping
salt  &apos; saltstack[1-2]&apos;  test . ping
salt  &apos; saltstack[!2]&apos;  test . ping
salt  &apos; saltstack?&apos;  test . ping
</code></pre><p> 列表</p>
<pre><code>salt -L  &apos;saltstack01 ,saltstack02 &apos;  test . ping
</code></pre><p> 正则表达式</p>
<pre><code>salt -E &apos;saltstack(01|02)&apos; test.ping
salt -E &apos;saltstack(01|02)*&apos; test.ping
</code></pre><p>备注: 所有匹配目标的方式，都可以用到top file里面来指定目标。minion ID设置方案：IP地址、根据业务来进行设置</p>
<p>eg:</p>
<pre><code>redis-node1-redis04-idc04-h5web.example.com
redis-node1   # redis第一个节点
redis04   # 集群
idc04   # 机房
h5web   # 业务线
</code></pre><p> 2）minion ID无关的方法</p>
<p>   IP地址、子网</p>
<pre><code>salt -S 192.168.16.100 test.ping
salt -S 192.168.16.0/24 test.ping
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-31.png" alt="2-31"></p>
<p>分组，需要配置master文件</p>
<pre><code>vim  /etc/salt/master
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/2-32.png" alt="2-32"></p>
<p>重启systemctl restart salt-master</p>
<p>混合匹配</p>
<p>具体内容查看<a href="https://docs.saltstack.com/en/latest/topics/targeting/compound.html" target="_blank" rel="external">官方文档</a></p>
<p> 批处理</p>
<p> 可用于重启所有主机或进程场景，百分比或固定数量的一点一点重启主机或进程</p>
<p> 具体内容查看<a href="https://docs.saltstack.com/en/latest/topics/targeting/batch.html" target="_blank" rel="external">官方文档</a></p>
<h1 id="执行模块"><a href="#执行模块" class="headerlink" title="执行模块"></a>执行模块</h1><p>具体内容查看<a href="https://docs.saltstack.com/en/latest/ref/modules/all/index.html#all-salt-modules" target="_blank" rel="external">官方文档</a></p>
<p>列出salt所有模块，以及如何使用的帮助文档</p>
<p>通过yum默认安装salt所有模块存放路径 /usr/lib/python2.7/site-packages/salt/modules（centos 7）</p>
<p>eg:</p>
<pre><code>salt  &apos;*&apos;  network.active_tcp   # 列出所有主机运行的tcp连接
salt  &apos;*&apos;  network.arp   # 列出所有主机arp
salt  &apos;*&apos;  service.available sshd   # 列出所有主机sshd
salt  &apos;*&apos;  service.get_all   # 列出所有主机的所有运行服务
salt  &apos;*&apos;  service.status sshd   # 列出所有主机sshd运行状态
salt- cp  &apos;*&apos;  /etc/hosts  /tmp/test   # 将master上/etc/hosts文件拷贝到所有主机的/tmp/test 
salt  &apos;*&apos;  state.show_top   # 查看top
salt  &apos;*&apos;  state.single pkg.installed name= lsof   # 所有主机安装lsof
</code></pre><h1 id="编写执行模块"><a href="#编写执行模块" class="headerlink" title="编写执行模块"></a>编写执行模块</h1><h2 id="放置路径"><a href="#放置路径" class="headerlink" title="放置路径"></a>放置路径</h2><pre><code>cd  /srv/salt
mkdir  _modules
</code></pre><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>文件名就是模块名</p>
<p>eg:</p>
<pre><code> my_disk.py

vim  /srv/salt/_modules/my_disk .py
def list():
     cmd =  &apos;df -h&apos;
     ret = __salt__[ &apos;cmd.run&apos; ](cmd)
     return  ret
</code></pre><h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><pre><code>salt  &apos;*&apos;  saltutil.sync_modules
</code></pre><p> <img src="http://opnq5yeqm.bkt.clouddn.com/2-33.png" alt="2-33"></p>
<p> 会放到指定目标的/var/cache/salt/minion下:</p>
<p> <img src="http://opnq5yeqm.bkt.clouddn.com/2-34.png" alt="2-34"></p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><pre><code>salt  &apos;*&apos;  my_disk.list
</code></pre><p> <img src="http://opnq5yeqm.bkt.clouddn.com/2-35.png" alt="2-35"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;saltstack简介&quot;&gt;&lt;a href=&quot;#saltstack简介&quot; class=&quot;headerlink&quot; title=&quot;saltstack简介&quot;&gt;&lt;/a&gt;saltstack简介&lt;/h1&gt;&lt;p&gt;（1）saltstack介绍&lt;/p&gt;
&lt;p&gt;SaltStack是一个
    
    </summary>
    
      <category term="运维技能" scheme="http://yjscloud.com/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Linux技术" scheme="http://yjscloud.com/tags/Linux%E6%8A%80%E6%9C%AF/"/>
    
      <category term="saltstack" scheme="http://yjscloud.com/tags/saltstack/"/>
    
  </entry>
  
  <entry>
    <title>cobbler实践指南</title>
    <link href="http://yjscloud.com/2018/03/01/cobbler%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"/>
    <id>http://yjscloud.com/2018/03/01/cobbler实践指南/</id>
    <published>2018-03-01T01:48:05.000Z</published>
    <updated>2018-03-01T04:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cobbler简介"><a href="#cobbler简介" class="headerlink" title="cobbler简介"></a>cobbler简介</h1><h2 id="cobbler介绍"><a href="#cobbler介绍" class="headerlink" title="cobbler介绍"></a>cobbler介绍</h2><p>Cobbler是一个Linux服务器安装的服务，可以通过网络启动(PXE)的方式来快速安装、重装物理服务器和虚拟机，同时还可以管理DHCP，DNS等。</p>
<p>Cobbler可以使用命令行方式管理，也提供了基于Web的界面管理工具(cobbler-web)，还提供了API接口，可以方便二次开发使用。</p>
<p>Cobbler是较早前的kickstart的升级版，优点是比较容易配置，还自带web界面比较易于管理。</p>
<p>Cobbler内置了一个轻量级配置管理系统，但它也支持和其它配置管理系统集成，如Puppet，暂时不支持SaltStack。</p>
<h2 id="cobbler集成的服务"><a href="#cobbler集成的服务" class="headerlink" title="cobbler集成的服务"></a>cobbler集成的服务</h2><ul>
<li>PXE服务支持</li>
<li>DHCP服务管理</li>
<li>DNS服务管理(可选bind,dnsmasq)</li>
<li>电源管理</li>
<li>Kickstart服务支持</li>
<li>YUM仓库管理</li>
<li>TFTP(PXE启动时需要)</li>
<li>Apache(提供kickstart的安装源，并提供定制化的kickstart配置）</li>
</ul>
<h1 id="cobbler部署"><a href="#cobbler部署" class="headerlink" title="cobbler部署"></a>cobbler部署</h1><p>cobbler服务器基本设置：CentOS7最小化安装，关闭防火墙，selinux设置为disabled，虚拟机网卡这里为桥接模式</p>
<h2 id="安装EPEL源"><a href="#安装EPEL源" class="headerlink" title="安装EPEL源"></a>安装EPEL源</h2><pre><code>rpm -ivh http://mirrors.kernel.org/fedora-epel/7/x86_64/e/epel-release-7-10.noarch.rpm
yum repolist
</code></pre><h2 id="yum安装cobbler"><a href="#yum安装cobbler" class="headerlink" title="yum安装cobbler"></a>yum安装cobbler</h2><pre><code>yum install -y httpd dhcp tftp cobbler cobbler-web pykickstart
</code></pre><p>用命令（rpm -ql cobbler）查看安装的文件，下面列出部分。</p>
<p>配置文件目录 /etc/cobbler</p>
<pre><code>/etc/cobbler                  # 配置文件目录
/etc/cobbler/settings         # cobbler主配置文件，这个文件是YAML格式，Cobbler是python写的程序。
/etc/cobbler/dhcp.template    # DHCP服务的配置模板
/etc/cobbler/tftpd.template   # tftp服务的配置模板
/etc/cobbler/rsync.template   # rsync服务的配置模板
/etc/cobbler/iso              # iso模板配置文件目录
/etc/cobbler/pxe              # pxe模板文件目录/etc/cobbler/power            # 电源的配置文件目录
/etc/cobbler/users.conf       # Web服务授权配置文件
/etc/cobbler/users.digest     # 用于web访问的用户名密码配置文件
/etc/cobbler/dnsmasq.template # DNS服务的配置模板
/etc/cobbler/modules.conf     # Cobbler模块配置文件
</code></pre><p> 数据目录</p>
<pre><code>/var/lib/cobbler              # Cobbler数据目录
/var/lib/cobbler/config       # 用于存放distros,system,profiles等信息配置文件
/var/lib/cobbler/kickstarts   # 默认存放kickstart文件
/var/lib/cobbler/loaders      # 存放的各种引导程序
</code></pre><p> 镜像目录</p>
<pre><code>/var/www/cobbler              # 系统安装镜像目录
/var/www/cobbler/ks_mirror    # 导入的发行版系统的所有数据
/var/www/cobbler/images       # 导入发行版的kernel和initrd镜像用于远程网络启动
/var/www/cobbler/repo_mirror  # yum源存储目录
</code></pre><p> 日志目录</p>
<pre><code>/var/log/cobbler              # 日志目录
/var/log/cobbler/install.log  # 客户端系统安装日志
/var/log/cobbler/cobbler.log  # cobbler日志
</code></pre><h2 id="启动并检测cobbler"><a href="#启动并检测cobbler" class="headerlink" title="启动并检测cobbler"></a>启动并检测cobbler</h2><pre><code>systemctl start httpd
systemctl enable httpd
systemctl start cobblerd
systemctl enable cobblerd
cobbler check
</code></pre><p>附加解析：</p>
<pre><code>cobbler check 核对当前设置是否有问题
cobbler list 列出所有的cobbler元素
cobbler report 列出元素的详细信息
cobbler sync 同步配置到数据目录,更改配置最好都要执行下
cobbler reposync 同步yum仓库
cobbler distro 查看导入的发行版系统信息
cobbler system 查看添加的系统信息
cobbler profile 查看配置信息
</code></pre><h2 id="修改cobbler主配置文件"><a href="#修改cobbler主配置文件" class="headerlink" title="修改cobbler主配置文件"></a>修改cobbler主配置文件</h2><pre><code>vim /etc/cobbler/settings
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-1.png" alt="1-1"></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-2.png" alt="1-2"></p>
<h2 id="保证xinetd服务为开机自动启动状态"><a href="#保证xinetd服务为开机自动启动状态" class="headerlink" title="保证xinetd服务为开机自动启动状态"></a>保证xinetd服务为开机自动启动状态</h2><pre><code>vim /etc/xinetd.d/tftp
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-3.png" alt="1-3"></p>
<h2 id="启动rsyncd服务"><a href="#启动rsyncd服务" class="headerlink" title="启动rsyncd服务"></a>启动rsyncd服务</h2><pre><code>systemctl start rsyncd
cobbler get-loaders
</code></pre><h2 id="生成cobbler安装系统root初始密码"><a href="#生成cobbler安装系统root初始密码" class="headerlink" title="生成cobbler安装系统root初始密码"></a>生成cobbler安装系统root初始密码</h2><pre><code>openssl passwd -1 -salt &apos;cobler&apos; &apos;cobler&apos;
$1$cobler$XJnisBweZJlhL651HxAM00
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-4.png" alt="1-4"></p>
<h2 id="将上面的加密串加入cobbler配置文件中"><a href="#将上面的加密串加入cobbler配置文件中" class="headerlink" title="将上面的加密串加入cobbler配置文件中"></a>将上面的加密串加入cobbler配置文件中</h2><pre><code>vim /etc/cobbler/settings
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-5.png" alt="1-5"></p>
<h2 id="重启cobblerd服务："><a href="#重启cobblerd服务：" class="headerlink" title="重启cobblerd服务："></a>重启cobblerd服务：</h2><pre><code>systemctl restart cobblerd
cobbler check
</code></pre><h2 id="让cobblerd管理dhcp"><a href="#让cobblerd管理dhcp" class="headerlink" title="让cobblerd管理dhcp"></a>让cobblerd管理dhcp</h2><pre><code>vim /etc/cobbler/settings
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-6.png" alt="1-6"></p>
<h2 id="修改dhcp模板文件："><a href="#修改dhcp模板文件：" class="headerlink" title="修改dhcp模板文件："></a>修改dhcp模板文件：</h2><pre><code>vim /etc/cobbler/dhcp.template
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-7.png" alt="1-7"></p>
<h2 id="重启cobblerd"><a href="#重启cobblerd" class="headerlink" title="重启cobblerd"></a>重启cobblerd</h2><pre><code>systemctl restart cobblerd
</code></pre><p>同步：</p>
<pre><code>cobbler sync
</code></pre><h2 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h2><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-8.png" alt="1-8"></p>
<pre><code>mount /dev/cdrom /mnt
cobbler import --path=/mnt/ --name=CentOS-7-x86_64 --arch=x86_64
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-9.png" alt="1-9"></p>
<p>导入centos6的步骤在这里略去！</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-10.png" alt="1-10"></p>
<p>CentOS-6-x86_64.cfg配置文件：</p>
<pre><code># Kickstart file automatically generated by anaconda.

#version=DEVEL

install  #表示是安装，而不是升级

text #文本方式安装

cdrom #安装方式，如果是网络安装的话可以写成 url ––url ftp://192.168.1.254/dir 或者 nfs --server=192.168.0.241 --dir=/centosinstall

key –skip #这个是我另外添加的，如果是RedHat的系统，会要求输入key，这里配置为跳过，如果不配置安装时会停在那里要求用户输入key

lang en_US.UTF-8  #语言

keyboard us #键盘样式

network --onboot no --device eth0 --noipv4 --noipv6 #网络配置 配置具体参数样例：network –onboot yes --bootproto=static --ip=192.168.1.1 --netmask=255.255.255.0 其他网关，DNS等格式和ifcfg-ethx的方式一样

rootpw  --iscrypted $6$PEJ49S7OkrNra3UM #管理员密码，是加密过的 要是使用不加密的方式则这样写：rootpw 123456

firewall --service=ssh #开启防火墙，并打开ssh端口

authconfig --enableshadow --passalgo=sha512 #用户认证和密码加密方式

selinux --enforcing #强制打开selinux

timezone --utc Etc/GMT+8 #时区设置

zerombr yes #清空磁盘的mbr

bootloader --location=mbr --driveorder=sda #引导程序相关参数

# The following is the partition information you requested
# Note that any partitions you deleted are not expressed
# here so unless you clear all partitions first, this is
# not guaranteed to work

clearpart –all –initlabel #初始化磁盘

part / --fstype=ext4 --size=18000 #开始分区
part swap --grow --size=1024
repo --name=&quot;CentOS&quot;  --baseurl=cdrom:sr0 --cost=100

reboot


%packages --nobase #安装的软件包，这里由于我安装的是最小mini版，所以只安装了核心软件包组
@core


%post #后安装脚本（这里是我另外添加的，原来文件中没有）
id lustlost &amp;&gt;; /dev/null || useradd lustlost #检查是否有lustlost用户，如果没有则添加
echo 123456 | passwd –stdin lustlost #配置密码

cat &gt;&gt; /etc/yum.repos.d/base.repo &lt;&lt; eof
[base]
name=baseserver
baseurl=http://192.168.1.254/yum
gpgcheck=0
enable=1
eof                                 #这里在安装系统成功后执行脚本自动配置一个yum源,其他脚本可以按照需要定义

%end
</code></pre><p>CentOS-7-x86_64.cfg配置文件：</p>
<pre><code># Cobbler for Kickstart Configurator for CentOS 7 by clsn
install
url --url=$tree
text
lang en_US.UTF-8
keyboard us
zerombr
bootloader --location=mbr --driveorder=sda --append=&quot;crashkernel=auto rhgb quiet&quot;
#Network information
$SNIPPET(&apos;network_config&apos;)
#network --bootproto=dhcp --device=eth0 --onboot=yes --noipv6 --    hostname=CentOS7
timezone --utc Asia/Shanghai
authconfig --enableshadow --passalgo=sha512
rootpw  --iscrypted $default_password_crypted
clearpart --all --initlabel
part /boot --fstype xfs --size 1024
part swap --size 1024
part / --fstype xfs --size 1 --grow
firstboot --disable
selinux --disabled
firewall --disabled
logging --level=info
reboot

%pre
$SNIPPET(&apos;log_ks_pre&apos;)
$SNIPPET(&apos;kickstart_start&apos;)
$SNIPPET(&apos;pre_install_network_config&apos;)
# Enable installation monitoring
$SNIPPET(&apos;pre_anamon&apos;)
%end

%packages
@^minimal
@compat-libraries
@core
@debugging
@development
bash-completion
chrony
dos2unix
kexec-tools
lrzsz
nmap
sysstat
telnet
tree
vim
wget
%end

%post
systemctl disable postfix.service

$yum_config_stanza
%end
</code></pre><p>上传配置文件到/var/lib/cobbler/kickstarts目录下</p>
<p>修改自定义配置文件：</p>
<pre><code>cobbler profile edit --name=CentOS-7-x86_64 --kickstart=/var/lib/cobbler/kickstarts/CentOS-7-x86_64.cfg
cobbler profile edit --name=CentOS-6-x86_64 --kickstart=/var/lib/cobbler/kickstarts/CentOS-6-x86_64.cfg
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-11.png" alt="1-11">    </p>
<p>定义自动化安装时centos7的网卡信息文件（自动生成eth1,eth2）</p>
<pre><code>cobbler profile edit --name=CentOS-7-x86_64 --kopts=&apos;net.ifnames=O biosdevname=O&apos;
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-12.png" alt="1-12"></p>
<p>cobbler sync #使修改的配置文件生效</p>
<p>然后随便添加一台虚拟机，开机！</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-13.png" alt="1-13">    </p>
<p>cobbler服务器端查看日志</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-14.png" alt="1-14"></p>
<p>（14）安装xinetd</p>
<pre><code>yum -y install xinetd
systemctl start xinetd
</code></pre><p>安装好后就会可以选择安装centos版本，选择对应版本后就会自动执行安装程序！</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-15.png" alt="1-15"><br><img src="http://opnq5yeqm.bkt.clouddn.com/1-16.png" alt="1-16">    </p>
<h1 id="自动重装和cobbler-web"><a href="#自动重装和cobbler-web" class="headerlink" title="自动重装和cobbler-web"></a>自动重装和cobbler-web</h1><h2 id="安装koan"><a href="#安装koan" class="headerlink" title="安装koan"></a>安装koan</h2><pre><code>yum -y install koan
</code></pre><p>查看可以重装的系统：</p>
<pre><code>koan --server=192.168.0.100 --list=profiles    
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-17.png" alt="1-17">    </p>
<h2 id="指定要重装成centos6："><a href="#指定要重装成centos6：" class="headerlink" title="指定要重装成centos6："></a>指定要重装成centos6：</h2><pre><code>koan --replace-self --server=192.168.0.100 --profile=CentOS-6-x86_64
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-18.png" alt="1-18"></p>
<h2 id="通过web访问cobbler"><a href="#通过web访问cobbler" class="headerlink" title="通过web访问cobbler"></a>通过web访问cobbler</h2><p>在浏览器输入：<a href="https://192.168.0.100/cobbler_web，用户名和密码都是默认的cobbler" target="_blank" rel="external">https://192.168.0.100/cobbler_web，用户名和密码都是默认的cobbler</a></p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-19.png" alt="1-19"></p>
<h2 id="cobbler修改密码"><a href="#cobbler修改密码" class="headerlink" title="cobbler修改密码"></a>cobbler修改密码</h2><pre><code>htdigest /etc/cobbler/users.digest &quot;Cobbler&quot; cobbler
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-20.png" alt="1-20"></p>
<p>所有操作都可在web界面进行</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-21.png" alt="1-21"><br><img src="http://opnq5yeqm.bkt.clouddn.com/1-22.png" alt="1-22"></p>
<h2 id="修改提示信息的选单"><a href="#修改提示信息的选单" class="headerlink" title="修改提示信息的选单"></a>修改提示信息的选单</h2><pre><code>vim /etc/cobbler/pxe/pxedefault.template
</code></pre><p>修改前:</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-23.png" alt="1-23"></p>
<p>修改后：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-24.png" alt="1-24"></p>
<p>然后执行命令：cobbler sync</p>
<p>新建一台虚拟机查看效果：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-25.png" alt="1-25"></p>
<h1 id="cobbler自定义yum源"><a href="#cobbler自定义yum源" class="headerlink" title="cobbler自定义yum源"></a>cobbler自定义yum源</h1><h2 id="添加repo"><a href="#添加repo" class="headerlink" title="添加repo"></a>添加repo</h2><pre><code>cobbler repo add --name=openstack-ocata --mirror=http://192.168.0.5:8080/openstack-ocata/ --arch=x86_64 --breed=yum
</code></pre><p>注：<a href="http://192.168.0.5:8080/openstack-ocata/为我本地搭建的本地yum源" target="_blank" rel="external">http://192.168.0.5:8080/openstack-ocata/为我本地搭建的本地yum源</a></p>
<h2 id="同步repo"><a href="#同步repo" class="headerlink" title="同步repo"></a>同步repo</h2><pre><code>cobbler reposync
</code></pre><h2 id="添加repo到对应的repolist"><a href="#添加repo到对应的repolist" class="headerlink" title="添加repo到对应的repolist"></a>添加repo到对应的repolist</h2><pre><code>cobbler profile edit --name=CentOS-7-x86_64 --repos=&quot;openstack-ocata&quot;
</code></pre><h2 id="修改kicstart文件"><a href="#修改kicstart文件" class="headerlink" title="修改kicstart文件"></a>修改kicstart文件</h2><pre><code>%post
systemctl disable postfix.service

$yum_config_stanza
%end
</code></pre><h2 id="添加定时任务，定期同步repo"><a href="#添加定时任务，定期同步repo" class="headerlink" title="添加定时任务，定期同步repo"></a>添加定时任务，定期同步repo</h2><pre><code>echo &quot;1 3 * * * /usr/bin/cobbler reposync --tries=3 --no-fail&quot; &gt;&gt; /var/spool/cron/root
</code></pre><h1 id="cobbler自定义系统安装"><a href="#cobbler自定义系统安装" class="headerlink" title="cobbler自定义系统安装"></a>cobbler自定义系统安装</h1><h2 id="自动化装机平台基本信息"><a href="#自动化装机平台基本信息" class="headerlink" title="自动化装机平台基本信息"></a>自动化装机平台基本信息</h2><p>mac地址：00:50:56:3E:3D:06</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-26.png" alt="1-26"></p>
<p>主机名：cobbler-test03<br>IP：192.168.0.111<br>掩码：255.255.255.0<br>网关：192.168.0.1<br>DNS：192.168.0.1</p>
<h2 id="执行安装的命令"><a href="#执行安装的命令" class="headerlink" title="执行安装的命令"></a>执行安装的命令</h2><pre><code>cobbler system add --name=cobbler-test03 --mac=00:50:56:3E:3D:06 --profile=CentOS-7-x86_64 \
--ip-address=192.168.0.111 --subnet=255.255.255.0 --gateway=192.168.0.1 --intterface=eth0 \
--static=1 --hostname=cobbler-test03 --name-servers=&quot;192.168.0.1&quot; \
--kickstart=/var/lib/cobbler/kickstarts/CentOS-7-x86_64.cfg
</code></pre><p><img src="http://opnq5yeqm.bkt.clouddn.com/1-27.png" alt="1-27"></p>
<p>同步：cobbler sync</p>
<p>启动虚拟机跳过选择界面自动安装：</p>
<p><img src="http://opnq5yeqm.bkt.clouddn.com/1-28.png" alt="1-28"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;cobbler简介&quot;&gt;&lt;a href=&quot;#cobbler简介&quot; class=&quot;headerlink&quot; title=&quot;cobbler简介&quot;&gt;&lt;/a&gt;cobbler简介&lt;/h1&gt;&lt;h2 id=&quot;cobbler介绍&quot;&gt;&lt;a href=&quot;#cobbler介绍&quot; class
    
    </summary>
    
      <category term="运维技能" scheme="http://yjscloud.com/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Linux技术" scheme="http://yjscloud.com/tags/Linux%E6%8A%80%E6%9C%AF/"/>
    
      <category term="cobbler" scheme="http://yjscloud.com/tags/cobbler/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（十）：面向对象（基础篇）</title>
    <link href="http://yjscloud.com/2018/01/23/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>http://yjscloud.com/2018/01/23/Python当歌（十）：面向对象（基础篇）/</id>
    <published>2018-01-23T02:30:17.000Z</published>
    <updated>2018-02-08T10:27:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>（1）面向过程：根据业务逻辑从上到下写垒代码</p>
<p>（2）函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可</p>
<p>（3）面向对象：对函数进行分类和封装，让开发“更快更好更强…”</p>
<p>面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程中最常见的操作就是粘贴复制，即：将之前实现的代码块复制到现需功能处。</p>
<pre><code>while True：
    if cpu利用率 &gt; 90%:
        #发送邮件提醒
        连接邮箱服务器
        发送邮件
        关闭连接

    if 硬盘使用空间 &gt; 90%:
        #发送邮件提醒
        连接邮箱服务器
        发送邮件
        关闭连接

    if 内存占用 &gt; 80%:
        #发送邮件提醒
        连接邮箱服务器
        发送邮件
        关闭连接
</code></pre><p>随着时间的推移，开始使用了函数式编程，增强代码的重用性和可读性，就变成了这样：</p>
<pre><code>def 发送邮件(内容)
    #发送邮件提醒
    连接邮箱服务器
    发送邮件
    关闭连接

while True：

    if cpu利用率 &gt; 90%:
        发送邮件(&apos;CPU报警&apos;)

    if 硬盘使用空间 &gt; 90%:
        发送邮件(&apos;硬盘报警&apos;)

    if 内存占用 &gt; 80%:
        发送邮件(&apos;内存报警&apos;)
</code></pre><h1 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h1><p>面向对象编程是一种编程方式，此编程方式的落地需要使用 “类” 和 “对象” 来实现，所以，面向对象编程其实就是对 “类” 和 “对象” 的使用。</p>
<p>类就是一个模板，模板里可以包含多个函数，函数里实现一些功能</p>
<p>对象则是根据模板创建的实例，通过实例对象可以执行类中的函数</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-1.png" alt="10-1"></p>
<p>（1）class是关键字，表示类</p>
<p>（2）创建对象，类名称后加括号即可</p>
<p>ps：类中的函数第一个参数必须是self（详细见：类的三大特性之封装）<br>　　 类中定义的函数叫做 “方法”</p>
<pre><code># 创建类
class Foo:

    def Bar(self):
        print &apos;Bar&apos;

    def Hello(self, name):
        print &apos;i am %s&apos; %name

# 根据类Foo创建对象obj
obj = Foo()
obj.Bar()            #执行Bar方法
obj.Hello(‘Pan&apos;) #执行Hello方法　
</code></pre><h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><p>面向对象的三大特性是指：封装、继承和多态。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。要明确的区分内外,内部的实现逻辑，外部无法知晓，并且为封装到内部的逻辑提供一个访问接口给外部使用，类中定义私有的，只在类的内部使用，外部无法访问。所以，在使用面向对象的封装特性时，需要：</p>
<ul>
<li>将内容封装到某处</li>
<li>从某处调用被封装的内容</li>
</ul>
<p>第一步：将内容封装到某处</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-2.png" alt="10-2"></p>
<p>self 是一个形式参数，当执行 obj1 = Foo(‘Pan’, 18 ) 时，self 等于 obj1；</p>
<p>   当执行 obj2 = Foo(‘xwq’, 78 ) 时，self 等于 obj2</p>
<p>所以，内容其实被封装到了对象 obj1 和 obj2 中，每个对象中都有 name 和 age 属性，在内存里类似于下图来保存。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-3.png" alt="10-3"></p>
<p>第二步：从某处调用被封装的内容</p>
<p>调用被封装的内容时，有两种情况：</p>
<ul>
<li>通过对象直接调用</li>
<li>通过self间接调用</li>
</ul>
<p>（1）通过对象直接调用被封装的内容</p>
<p>上图展示了对象 obj1 和 obj2 在内存中保存的方式，根据保存格式可以如此调用被封装的内容：对象.属性名</p>
<pre><code>class Foo:

    def __init__(self, name, age):
        self.name = name
        self.age = age

obj1 = Foo(&apos;Pan&apos;, 18)
print obj1.name    # 直接调用obj1对象的name属性
print obj1.age     # 直接调用obj1对象的age属性

obj2 = Foo(&apos;xwq&apos;, 19)
print obj2.name    # 直接调用obj2对象的name属性
print obj2.age     # 直接调用obj2对象的age属性
</code></pre><p>（2）通过self间接调用被封装的内容</p>
<p>执行类中的方法时，需要通过self间接调用被封装的内容</p>
<pre><code>class Foo:

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def detail(self):
        print self.name
        print self.age

obj1 = Foo(&apos;Pan&apos;, 18)
obj1.detail()  # Python默认会将obj1传给self参数，即：obj1.detail(obj1)，所以，此时方法内部的 self ＝ obj1，即：self.name 是 Pan ；self.age 是 18

obj2 = Foo(&apos;xwq&apos;, 73)
obj2.detail()  # Python默认会将obj2传给self参数，即：obj1.detail(obj2)，所以，此时方法内部的 self ＝ obj2，即：self.name 是 xwq ； self.age 是 78
</code></pre><p>综上所述，对于面向对象的封装来说，其实就是使用构造方法将内容封装到对象 中，然后通过对象直接或者self间接获取被封装的内容。</p>
<p>（3）如何隐藏类的内部属性</p>
<p>在python中用双下划线开头的方式将属性隐藏起来（设置成私有的），其实这仅仅这是一种变形操作且仅仅只在类定义阶段发生变形，类中所有双下划线开头的名称如<strong>x都会在类定义时自动变形成：_类名</strong>x的形式：</p>
<pre><code>class A:
    __N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N
    def __init__(self):
        self.__X=10 #变形为self._A__X
    def __foo(self): #变形为_A__foo
        print(&apos;from A&apos;)
    def bar(self):
        self.__foo() #只有在类内部才可以通过__foo的形式访问到.

 #A._A__N是可以访问到的，这种，在外部是无法通过__x这个名字访问到。
</code></pre><p>这种变形需要注意的问题是：</p>
<p>1.这种机制也并没有真正意义上限制我们从外部直接访问属性，知道了类名和属性名就可以拼出名字：_类名<strong>属性，然后就可以访问了，如a._A</strong>N，即这种操作并不是严格意义上的限制外部访问，仅仅只是一种语法意义上的变形，主要用来限制外部的直接访问。</p>
<p>2.变形的过程只在类的定义时发生一次,在定义后的赋值操作，不会变形</p>
<p>3.在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-4.png" alt="10-4"></p>
<p>（4）封装不是单纯意义的隐藏</p>
<p>1：封装数据：将数据隐藏起来这不是目的。隐藏起来然后对外提供操作该数据的接口，然后我们可以在接口附加上对该数据操作的限制，以此完成对数据属性操作的严格控制。</p>
<pre><code>class Teacher:
    def __init__(self,name,age):
        # self.__name=name
        # self.__age=age
        self.set_info(name,age)

    def tell_info(self):
        print(&apos;姓名:%s,年龄:%s&apos; %(self.__name,self.__age))
    def set_info(self,name,age):
        if not isinstance(name,str):
            raise TypeError(&apos;姓名必须是字符串类型&apos;)
        if not isinstance(age,int):
            raise TypeError(&apos;年龄必须是整型&apos;)
        self.__name=name
        self.__age=age


t=Teacher(&apos;egon&apos;,18)
t.tell_info()

t.set_info(&apos;egon&apos;,19)
t.tell_info()
</code></pre><p>2：封装方法：目的是隔离复杂度</p>
<p>取款是功能,而这个功能有很多功能组成:插卡、密码认证、输入金额、打印账单、取钱。对使用者来说,只需要知道取款这个功能即可,其余功能我们都可以隐藏起来,很明显这么做。隔离了复杂度,同时也提升了安全性</p>
<pre><code>class ATM:
    def __card(self):
        print(&apos;插卡&apos;)
    def __auth(self):
        print(&apos;用户认证&apos;)
    def __input(self):
        print(&apos;输入取款金额&apos;)
    def __print_bill(self):
        print(&apos;打印账单&apos;)
    def __take_money(self):
        print(&apos;取款&apos;)

    def withdraw(self):
        self.__card()
        self.__auth()
        self.__input()
        self.__print_bill()
        self.__take_money()

a=ATM()
a.withdraw()
</code></pre><p>（5）封装与扩展性</p>
<p>封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用用者只知道一个接口(函数)，只要接口（函数）名、参数不变，使用者的代码永远无需改变。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。</p>
<pre><code>#类的设计者
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    def tell_area(self): #对外提供的接口，隐藏了内部的实现细节，此时我们想求的是面积
        return self.__width * self.__length

#使用者
&gt;&gt;&gt; r1=Room(&apos;卧室&apos;,&apos;egon&apos;,20,20,20)
&gt;&gt;&gt; r1.tell_area() #使用者调用接口tell_area


#类的设计者，轻松的扩展了功能，而类的使用者完全不需要改变自己的代码
class Room:
    def __init__(self,name,owner,width,length,high):
        self.name=name
        self.owner=owner
        self.__width=width
        self.__length=length
        self.__high=high
    def tell_area(self): #对外提供的接口，隐藏内部实现，此时我们想求的是体积,内部逻辑变了,只需求修该下列一行就可以很简答的实现,而且外部调用感知不到,仍然使用该方法，但是功能已经变了

       return self.__width * self.__length * self.__high

#对于仍然在使用tell_area接口的人来说，根本无需改动自己的代码，就可以用上新功能
&gt;&gt;&gt; r1.tell_area()
</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容。</p>
<p>例如：<br>　　<br>　　猫可以：喵喵叫、吃、喝、拉、撒</p>
<p>狗可以：汪汪叫、吃、喝、拉、撒</p>
<p>如果我们要分别为猫和狗创建一个类，那么就需要为 猫 和 狗 实现他们所有的功能，如下所示：</p>
<pre><code>(伪代码)
class cat：

    def cat_mews(self):
        print (‘喵喵叫’)

    def eat(self):
        # do something

    def drink(self):
        # do something

    def pull(self):
        # do something

    def cast(self):
        # do something

class dog：

    def bark(self):
        print (‘汪汪叫’)

    def eat(self):
        # do something

    def drink(self):
        # do something

    def pull(self):
        # do something

    def cast(self):
        # do something
</code></pre><p>上述代码不难看出，吃、喝、拉、撒是猫和狗都具有的功能，而我们却分别的猫和狗的类中编写了两次。如果使用 继承 的思想，如下实现：</p>
<p>　　动物：吃、喝、拉、撒</p>
<p>　　   猫：喵喵叫（猫继承动物的功能）</p>
<p>　　   狗：汪汪叫（狗继承动物的功能）</p>
<pre><code>（伪代码）
class animal:

    def eat(self):
        # do something

    def drink(self):
        # do something

    def pull(self):
        # do something

    def cast(self):
        # do something

# 在类后面括号中写入另外一个类名，表示当前类继承另外一个类

class cat(animal)：

    def cat_mews(self):
        print &apos;喵喵叫&apos;

# 在类后面括号中写入另外一个类名，表示当前类继承另外一个类
class dog(animal)：

    def bark(self):
        print &apos;汪汪叫&apos;

（代码实现）
class Animal:
    def eat(self):
        print(&apos;%s eat&apos;%(self.name))

    def drink(self):
        print(&apos;%s drink&apos; %(self.name))

    def shit(self):
        print(&apos;%s pull&apos; %(self.name))

    def pee(self):
        print(&apos;%s cast&apos; %(self.name))


class Cat(Animal):
    def __init__(self, name):
        self.name = name
        self.breed = &apos;猫&apos;

    def cry(self):
        print(&apos;喵喵叫&apos;)


class Dog(Animal):
    def __init__(self, name):
        self.name = name
        self.breed = &apos;狗&apos;

    def cry(self):
        print(&apos;汪汪叫&apos;)
</code></pre><p># ######### 执行 #########</p>
<pre><code>c1 = Cat(&apos;小白家的小黑猫&apos;)
c1.eat()

c2 = Cat(&apos;小黑的小白猫&apos;)
c2.drink()

d1 = Dog(&apos;胖子家的小瘦狗&apos;)
d1.eat()
</code></pre><p>所以，对于面向对象的继承来说，其实就是将多个类共有的方法提取到父类中，子类仅需继承父类而不必一一实现每个方法。</p>
<p>注：除了子类和父类的称谓，你可能看到过 派生类 和 基类 ，他们与子类和父类只是叫法不同而已。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-5.png" alt="10-5"></p>
<p>那么问题又来了，多继承呢？</p>
<p>是否可以继承多个类</p>
<p>如果继承的多个类每个类中都定了相同的函数，那么那一个会被使用呢？</p>
<p>1、Python的类可以继承多个类，Java和C#中则只能继承一个类</p>
<p>2、Python的类如果继承了多个类，那么其寻找方法的方式有两种，分别是：深度优先和广度优先</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-6.png" alt="10-6"></p>
<p>当类是经典类时，多继承情况下，会按照深度优先方式查找</p>
<p>当类是新式类时，多继承情况下，会按照广度优先方式查找</p>
<p>经典类和新式类，从字面上可以看出一个老一个新，新的必然包含了跟多的功能，也是之后推荐的写法，从写法上区分的话，如果当前类或者父类继承了object类，那么该类便是新式类，否则便是经典类。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-7.png" alt="10-7"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/10-8.png" alt="10-8"></p>
<p>（经典类多继承）<br>class D:</p>
<pre><code>def bar(self):
    print (&apos;D.bar&apos;)
</code></pre><p>class C(D):</p>
<pre><code>def bar(self):
    print (&apos;C.bar&apos;)
</code></pre><p>class B(D):</p>
<pre><code>def bar(self):
    print (&apos;B.bar&apos;)
</code></pre><p>class A(B, C):</p>
<pre><code>def bar(self):
    print (&apos;A.bar&apos;)

a = A()
</code></pre><p>执行bar方法时首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错,所以，查找顺序：A –&gt; B –&gt; D –&gt; C。在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了a.bar()</p>
<pre><code>(新式类多继承)
class D(object):

    def bar(self):
        print (&apos;D.bar&apos;)

class C(D):

    def bar(self):
        print (&apos;C.bar&apos;)

class B(D):

    def bar(self):
        print (&apos;B.bar&apos;)

class A(B, C):

    def bar(self):
        print (&apos;A.bar&apos;)

a = A()
</code></pre><p>执行bar方法时，首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错，所以，查找顺序：A –&gt; B –&gt; C –&gt; D，在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了a.bar()</p>
<p>经典类：首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错</p>
<p>新式类：首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错</p>
<p>注意：在上述查找过程中，一旦找到，则寻找过程立即中断，便不会再继续找了</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>类的继承有两层意义：1、改变  2、扩展</p>
<p>多态就是类的这两层意义的一个具体的实现机制。即调用不同的类实例化的对象下的相同的方法，实现的过程不一样。python中的标准类型就是多态概念的一个很好的示范。</p>
<p>多态的概念指出了对象如何通过他们共同的属性和动作来操作及访问，而不需要考虑他们的具体的类。多态一定是反应在运行时的状态。</p>
<p>（1）理解多态</p>
<p>多态指的是一类事物有多种形态</p>
<p>动物有多种形态：人，狗，猪</p>
<pre><code>import abc
class Animal(metaclass=abc.ABCMeta): #同一类事物:动物
    @abc.abstractmethod
    def talk(self):
        pass

class People(Animal): #动物的形态之一:人
    def talk(self):
        print(&apos;say hello&apos;)

class Dog(Animal): #动物的形态之二:狗
    def talk(self):
        print(&apos;say wangwang&apos;)

class Pig(Animal): #动物的形态之三:猪
    def talk(self):
        print(&apos;say aoao&apos;)
</code></pre><p>文件有多种形态：文本文件，可执行文件</p>
<pre><code>import abc
class File(metaclass=abc.ABCMeta): #同一类事物:文件
    @abc.abstractmethod
    def click(self):
        pass

class Text(File): #文件的形态之一:文本文件
    def click(self):
        print(&apos;open file&apos;)

class ExeFile(File): #文件的形态之二:可执行文件
    def click(self):
        print(&apos;execute file&apos;)
</code></pre><p>（2）多态性</p>
<p>多态性是指在不考虑实例类型的情况下使用实例</p>
<p>在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p>
<p>比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同。</p>
<p>多态性分为静态多态性和动态多态性</p>
<p>静态多态性：如任何类型都可以用运算符+进行运算</p>
<p>动态多态性：如下</p>
<pre><code>peo=People()
dog=Dog()
pig=Pig()

#peo、dog、pig都是动物,只要是动物肯定有talk方法
#于是我们可以不用考虑它们三者的具体是什么类型,而直接使用
peo.talk()
dog.talk()
pig.talk()

#更进一步,我们可以定义一个统一的接口来使用
def func(obj):
    obj.talk()
</code></pre><p>（3）为什么要使用多态性</p>
<p>1.增加了程序的灵活性</p>
<p>以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal)</p>
<p>2.增加了程序额可扩展性</p>
<p>通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用</p>
<pre><code>class Cat(Animal): #属于动物的另外一种形态：猫
     def talk(self):
         print(&apos;say miao&apos;)

def func(animal): #对于使用者来说，自己的代码根本无需改动
     animal.talk()

cat1=Cat() #实例出一只猫
func(cat1) #甚至连调用方式也无需改变，就能调用猫的talk功能
</code></pre><p>这样我们新增了一个形态Cat，由Cat类产生的实例cat1，使用者可以在完全不需要修改自己代码的情况下。使用和人、狗、猪一样的方式调用cat1的talk方法，即func(cat1)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;（1）面向过程：根据业务逻辑从上到下写垒代码&lt;/p&gt;
&lt;p&gt;（2）函数式：将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可&lt;/p
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（九）：模块</title>
    <link href="http://yjscloud.com/2018/01/22/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9D%97/"/>
    <id>http://yjscloud.com/2018/01/22/Python当歌（九）：模块/</id>
    <published>2018-01-22T09:37:20.000Z</published>
    <updated>2018-02-07T11:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块-amp-包"><a href="#模块-amp-包" class="headerlink" title="模块&amp;包"></a>模块&amp;包</h1><h2 id="模块-modue-的概念："><a href="#模块-modue-的概念：" class="headerlink" title="模块(modue)的概念："></a>模块(modue)的概念：</h2><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。</p>
<p>使用模块有什么好处？<br>最大的好处是大大提高了代码的可维护性。</p>
<p>其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Python内置的模块和来自第三方的模块。<br>所以，模块一共三种：</p>
<ul>
<li>python标准库</li>
<li>第三方模块</li>
<li>应用程序自定义模块</li>
</ul>
<p>另外，使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。</p>
<h2 id="模块导入方法"><a href="#模块导入方法" class="headerlink" title="模块导入方法"></a>模块导入方法</h2><p>（1）import语法</p>
<pre><code>import module1[, module2[,... moduleN]
</code></pre><p>（2）from…import语句</p>
<pre><code>from modname import name1[, name2[, ... nameN]]
</code></pre><p>（3）From…import* 语句</p>
<pre><code>from modname import *
</code></pre><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义</p>
<p>（4）运行本质</p>
<pre><code>import test
from test import add
</code></pre><p>无论1还是2，首先通过sys.path找到test.py,然后执行test脚本（全部执行），区别是1会将test这个变量名加载到名字空间，而2只会将add这个变量名加载进来。　</p>
<h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><p>如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。</p>
<p>举个例子，一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的模块。</p>
<p>现在，假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-1.png" alt="9-1"></p>
<p>引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，view.py模块的名字就变成了hello_django.app01.views，类似的，manage.py的模块名则是hello_django.manage。</p>
<p>请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录(文件夹)，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是对应包的名字。</p>
<p>调用包就是执行包下的__init__.py文件</p>
<h2 id="注意点（important）"><a href="#注意点（important）" class="headerlink" title="注意点（important）"></a>注意点（important）</h2><p>1、——————-</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-2.png" alt="9-2"></p>
<p>在nod1里import  hello是找不到的，有同学说可以找到呀，那是因为你的pycharm为你把myapp这一层路径加入到了sys.path里面，所以可以找到，然而程序一旦在命令行运行，则报错。有同学问那怎么办？简单啊，自己把这个路径加进去不就OK啦：</p>
<pre><code>import sys,os
BASE_DIR=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(BASE_DIR)
import hello
hello.hello1()
</code></pre><p>2、————————–</p>
<pre><code>if __name__==&apos;__main__&apos;:
    print(&apos;ok&apos;)

“Make a .py both importable and executable”
</code></pre><p>如果我们是直接执行某个.py文件的时候，该文件中那么”__name__ == ‘__main__’“是True,但是我们如果从另外一个.py文件通过import导入该文件的时候，这时__name__的值就是我们这个py文件的名字而不是__main__。</p>
<p>这个功能还有一个用处：调试代码的时候，在”if __name__ == ‘__main__’“中加入一些我们的调试代码，我们可以让外部模块调用的时候不执行我们的调试代码，但是如果我们想排查问题的时候，直接执行该模块文件，调试代码能够正常运行！</p>
<h1 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h1><p>三种时间表示</p>
<p>在Python中，通常有这几种方式来表示时间：</p>
<p>（1）时间戳(timestamp)：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</p>
<p>（2）格式化的时间字符串</p>
<p>（3）元组(struct_time)：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天，夏令时)<br>import time</p>
<p>#    1 time() :返回当前时间的时间戳</p>
<p>time.time()  #1473525444.037215</p>
<p>#———————————————————-</p>
<p># 2 localtime([secs])</p>
<p># 将一个时间戳转换为当前时区的struct_time。secs参数未提供，则以当前时间为准。</p>
<p>time.localtime() #time.struct_time(tm_year=2016, tm_mon=9, tm_mday=11, tm_hour=0,</p>
<p># tm_min=38, tm_sec=39, tm_wday=6, tm_yday=255, tm_isdst=0)</p>
<p>time.localtime(1473525444.037215)</p>
<p>#———————————————————-</p>
<p># 3 gmtime([secs]) 和localtime()方法类似，gmtime()方法是将一个时间戳转换为UTC时区（0时区）的struct_time。</p>
<p>#———————————————————-</p>
<p># 4 mktime(t) : 将一个struct_time转化为时间戳。</p>
<p>print(time.mktime(time.localtime()))#1473525749.0</p>
<p>#———————————————————-</p>
<p># 5 asctime([t]) : 把一个表示时间的元组或者struct_time表示为这种形式：’Sun Jun 20 23:21:05 1993’。</p>
<p># 如果没有参数，将会将time.localtime()作为参数传入。</p>
<p>print(time.asctime())#Sun Sep 11 00:43:43 2016</p>
<p>#———————————————————-</p>
<p># 6 ctime([secs]) : 把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果参数未给或者为None的时候，将会默认time.time()为参数。它的作用相当于time.asctime(time.localtime(secs))。</p>
<p>print(time.ctime())  # Sun Sep 11 00:46:38 2016</p>
<p>print(time.ctime(time.time()))  # Sun Sep 11 00:46:38 2016</p>
<p>#———————————————————-</p>
<p># 7 strftime(format[, t]) : 把一个代表时间的元组或者struct_time（如由time.localtime()和time.gmtime()返回）转化为格式化的时间字符串。如果t未指定，将传入<br>time.localtime()。如果元组中任何一个元素越界，ValueError的错误将会被抛出。</p>
<p>print(time.strftime(“%Y-%m-%d %X”, time.localtime()))#2016-09-11 00:49:56</p>
<p>#———————————————————-</p>
<p># 8 time.strptime(string[, format])</p>
<p># 把一个格式化时间字符串转化为struct_time。实际上它和strftime()是逆操作。</p>
<p>print(time.strptime(‘2011-05-05 16:37:06’, ‘%Y-%m-%d %X’))</p>
<p># time.struct_time(tm_year=2011, tm_mon=5, tm_mday=5, tm_hour=16, tm_min=37, tm_sec=6,</p>
<p>#  tm_wday=3, tm_yday=125, tm_isdst=-1)</p>
<p># 在这个函数中，format默认为：”%a %b %d %H:%M:%S %Y”。</p>
<p>#———————————————————-</p>
<p># 9 sleep(secs)<br># 线程推迟指定的时间运行，单位为秒。</p>
<p>#———————————————————-</p>
<p># 10 clock()<br># 这个需要注意，在不同的系统上含义不同。在UNIX系统上，它返回的是“进程时间”，它是用秒表示的浮点数（时间戳）。而在WINDOWS中，第一次调用，返回的是进程运行的实际时间。而第二次之后的调用是自第一次调用以后到现在的运行时间，即两次时间差。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-3.png" alt="9-3"><br><img src="http://p3q1rwnbl.bkt.clouddn.com/9-4.png" alt="9-4"></p>
<h1 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h1><pre><code>import random

print(random.random())    #(0,1)----float

print(random.randint(1,3))  #[1,3]

print(random.randrange(1,3)) #[1,3)

print(random.choice([1,&apos;23&apos;,[4,5]]))     #23

print(random.sample([1,&apos;23&apos;,[4,5]],2))  #[[4, 5], &apos;23&apos;]

print(random.uniform(1,3))  #1.927109612082716


item=[1,3,5,7,9]
random.shuffle(item)
print(item)
</code></pre><p>随机验证码代码:</p>
<pre><code>import random

def v_code():

    code = &apos;&apos;
    for i in range(5):

        num=random.randint(0,9)
        alf=chr(random.randint(65,90))
        add=random.choice([num,alf])
        code += str(add)
    return code

print(v_code())
</code></pre><h1 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h1><p>os模块是与操作系统交互的一个接口</p>
<p>os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</p>
<p>os.chdir(“dirname”)  改变当前脚本工作目录；相当于shell下cd</p>
<p>os.curdir  返回当前目录: (‘.’)</p>
<p>os.pardir  获取当前目录的父目录字符串名：(‘..’)</p>
<p>os.makedirs(‘dirname1/dirname2’)    可生成多层递归目录</p>
<p>os.removedirs(‘dirname1’)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</p>
<p>os.mkdir(‘dirname’)    生成单级目录；相当于shell中mkdir dirname</p>
<p>os.rmdir(‘dirname’)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</p>
<p>os.listdir(‘dirname’)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</p>
<p>os.remove()  删除一个文件</p>
<p>os.rename(“oldname”,”newname”)  重命名文件/目录</p>
<p>os.stat(‘path/filename’)  获取文件/目录信息</p>
<p>os.sep    输出操作系统特定的路径分隔符，win下为”\“,Linux下为”/“</p>
<p>os.linesep    输出当前平台使用的行终止符，win下为”\t\n”,Linux下为”\n”</p>
<p>os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</p>
<p>os.name    输出字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’</p>
<p>os.system(“bash command”)  运行shell命令，直接显示</p>
<p>os.environ  获取系统环境变量</p>
<p>os.path.abspath(path)  返回path规范化的绝对路径</p>
<p>os.path.split(path)  将path分割成目录和文件名二元组返回</p>
<p>os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素</p>
<p>os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</p>
<p>os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</p>
<p>os.path.isabs(path)  如果path是绝对路径，返回True</p>
<p>os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</p>
<p>os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</p>
<p>os.path.join(path1[, path2[, …]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</p>
<p>os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间</p>
<p>os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</p>
<h1 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h1><p>sys.argv           命令行参数List，第一个元素是程序本身路径</p>
<p>sys.exit(n)        退出程序，正常退出时exit(0)</p>
<p>sys.version        获取Python解释程序的版本信息</p>
<p>sys.maxint         最大的Int值</p>
<p>sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</p>
<p>sys.platform       返回操作系统平台名称</p>
<p>进度条代码：</p>
<pre><code>import sys,time
for i in range(10):
    sys.stdout.write(&apos;#&apos;)
    time.sleep(1)
    sys.stdout.flush()
</code></pre><h1 id="json-amp-pickle"><a href="#json-amp-pickle" class="headerlink" title="json&amp;pickle"></a>json&amp;pickle</h1><p>用eval内置方法可以将一个字符串转成python对象，不过，eval方法是有局限性的，对于普通的数据类型，json.loads和eval都能用，但遇到特殊类型的时候，eval就不管用了,所以eval的重点还是通常用来执行一个字符串表达式，并返回表达式的值。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-5.png" alt="9-5"></p>
<h2 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h2><p>我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。<br>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-6.png" alt="9-6"></p>
<p>#—————————-序列化</p>
<pre><code>import json

dic={&apos;name&apos;:&apos;alvin&apos;,&apos;age&apos;:23,&apos;sex&apos;:&apos;male&apos;}
print(type(dic))#&lt;class &apos;dict&apos;&gt;

j=json.dumps(dic)
print(type(j))#&lt;class &apos;str&apos;&gt;

f=open(&apos;序列化对象&apos;,&apos;w&apos;)
f.write(j)  #-------------------等价于json.dump(dic,f)
f.close()
</code></pre><p>#—————————–反序列化<br></p>
<pre><code>import json
f=open(&apos;序列化对象&apos;)
data=json.loads(f.read())#  等价于data=json.load(f)
</code></pre><p>注意：</p>
<pre><code>import json
#dct=&quot;{&apos;1&apos;:111}&quot;#json 不认单引号
#dct=str({&quot;1&quot;:111})#报错,因为生成的数据还是单引号:{&apos;one&apos;: 1}

dct=&apos;{&quot;1&quot;:&quot;111&quot;}&apos;
print(json.loads(dct))

#conclusion:
#无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads
</code></pre><h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><p>#—————————-序列化</p>
<pre><code>import pickle

dic={&apos;name&apos;:&apos;alvin&apos;,&apos;age&apos;:23,&apos;sex&apos;:&apos;male&apos;}

print(type(dic))#&lt;class &apos;dict&apos;&gt;

j=pickle.dumps(dic)
print(type(j))#&lt;class &apos;bytes&apos;&gt;

f=open(&apos;序列化对象_pickle&apos;,&apos;wb&apos;)#注意是w是写入str,wb是写入bytes,j是&apos;bytes&apos;
f.write(j)  #-------------------等价于pickle.dump(dic,f)

f.close()
</code></pre><p>#————————-反序列化</p>
<pre><code>import pickle
f=open(&apos;序列化对象_pickle&apos;,&apos;rb&apos;)

data=pickle.loads(f.read())#  等价于data=pickle.load(f)

print(data[&apos;age&apos;])  
</code></pre><p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>
<h1 id="xml模块"><a href="#xml模块" class="headerlink" title="xml模块"></a>xml模块</h1><p>xml是实现不同语言或程序之间进行数据交换的协议，跟json差不多，但json使用起来更简单，不过，在json还没诞生的黑暗年代，大家只能选择用xml，至今很多传统公司如金融行业的很多系统的接口还主要是xml。</p>
<p>xml的格式如下，就是通过&lt;&gt;节点来区别数据结构的:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;data&gt;
    &lt;country name=&quot;Liechtenstein&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;2&lt;/rank&gt;
        &lt;year&gt;2008&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor name=&quot;Austria&quot; direction=&quot;E&quot;/&gt;
        &lt;neighbor name=&quot;Switzerland&quot; direction=&quot;W&quot;/&gt;
    &lt;/country&gt;
    &lt;country name=&quot;Singapore&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;5&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor name=&quot;Malaysia&quot; direction=&quot;N&quot;/&gt;
    &lt;/country&gt;
    &lt;country name=&quot;Panama&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;69&lt;/rank&gt;
        &lt;year&gt;2011&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor name=&quot;Costa Rica&quot; direction=&quot;W&quot;/&gt;
        &lt;neighbor name=&quot;Colombia&quot; direction=&quot;E&quot;/&gt;
    &lt;/country&gt;
&lt;/data&gt;
</code></pre><p>xml协议在各个语言里的都 是支持的，在python中可以用以下模块操作xml：</p>
<pre><code>import xml.etree.ElementTree as ET 
tree = ET.parse(&quot;xmltest.xml&quot;)
root = tree.getroot()
print(root.tag)
</code></pre><p>#遍历xml文档</p>
<pre><code>for child in root:
    print(child.tag, child.attrib)
    for i in child:
        print(i.tag,i.text)
</code></pre><p>#只遍历year 节点</p>
<pre><code>for node in root.iter(&apos;year&apos;):
    print(node.tag,node.text)
</code></pre><p>#—————————————</p>
<pre><code>import xml.etree.ElementTree as ET

tree = ET.parse(&quot;xmltest.xml&quot;)
root = tree.getroot()
</code></pre><p>#修改</p>
<pre><code>for node in root.iter(&apos;year&apos;):
    new_year = int(node.text) + 1
    node.text = str(new_year)
    node.set(&quot;updated&quot;,&quot;yes&quot;)

tree.write(&quot;xmltest.xml&quot;)
</code></pre><p>#删除node</p>
<pre><code>for country in root.findall(&apos;country&apos;):
    rank = int(country.find(&apos;rank&apos;).text)
    if rank &gt; 50:
     root.remove(country)

tree.write(&apos;output.xml&apos;)
</code></pre><p>自己创建xml文档：</p>
<pre><code>import xml.etree.ElementTree as ET

new_xml = ET.Element(&quot;namelist&quot;)
name = ET.SubElement(new_xml,&quot;name&quot;,attrib={&quot;enrolled&quot;:&quot;yes&quot;})
age = ET.SubElement(name,&quot;age&quot;,attrib={&quot;checked&quot;:&quot;no&quot;})
sex = ET.SubElement(name,&quot;sex&quot;)
sex.text = &apos;33&apos;
name2 = ET.SubElement(new_xml,&quot;name&quot;,attrib={&quot;enrolled&quot;:&quot;no&quot;})
age = ET.SubElement(name2,&quot;age&quot;)
age.text = &apos;19&apos;

et = ET.ElementTree(new_xml) #生成文档对象
et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;,xml_declaration=True)

ET.dump(new_xml) #打印生成的格式
</code></pre><h1 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h1><p>(1)简单应用</p>
<pre><code>import logging  
logging.debug(&apos;debug message&apos;)  
logging.info(&apos;info message&apos;)  
logging.warning(&apos;warning message&apos;)  
logging.error(&apos;error message&apos;)  
logging.critical(&apos;critical message&apos;)
</code></pre><p>输出：</p>
<pre><code>WARNING:root:warning message
ERROR:root:error message
CRITICAL:root:critical message
</code></pre><p>可见，默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET），默认的日志格式为日志级别：Logger名称：用户输出消息。</p>
<p>（2)灵活配置日志级别，日志格式，输出位置</p>
<pre><code>import logging

logging.basicConfig(level=logging.DEBUG,
format=&apos;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&apos;,
datefmt=&apos;%a, %d %b %Y %H:%M:%S&apos;,
filename=&apos;test.log&apos;,
filemode=&apos;w&apos;)

logging.debug(&apos;debug message&apos;)
logging.info(&apos;info message&apos;)
logging.warning(&apos;warning message&apos;)
logging.error(&apos;error message&apos;)
logging.critical(&apos;critical message&apos;)
</code></pre><p>查看输出：</p>
<pre><code>Wed, 24 Jan 2018 16:48:57 logging_test.py[line:11] DEBUG debug message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:12] INFO info message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:13] WARNING warning message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:14] ERROR error message
Wed, 24 Jan 2018 16:48:57 logging_test.py[line:15] CRITICAL critical message
</code></pre><p>可见在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有:</p>
<p>filename：用指定的文件名创建FiledHandler（后边会具体讲解handler的概念），这样日志会被存储在指定的文件中。</p>
<p>filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。</p>
<p>format：指定handler使用的日志显示格式。 </p>
<p>datefmt：指定日期时间格式。 </p>
<p>level：设置rootlogger（后边会讲解具体概念）的日志级别 </p>
<p>stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</p>
<p>format参数中可能用到的格式化串：</p>
<p>%(name)s Logger的名字</p>
<p>%(levelno)s 数字形式的日志级别</p>
<p>%(levelname)s 文本形式的日志级别</p>
<p>%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</p>
<p>%(filename)s 调用日志输出函数的模块的文件名</p>
<p>%(module)s 调用日志输出函数的模块名</p>
<p>%(funcName)s 调用日志输出函数的函数名</p>
<p>%(lineno)d 调用日志输出函数的语句所在的代码行</p>
<p>%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</p>
<p>%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</p>
<p>%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</p>
<p>%(thread)d 线程ID。可能没有</p>
<p>%(threadName)s 线程名。可能没有</p>
<p>%(process)d 进程ID。可能没有</p>
<p>%(message)s用户输出的消息</p>
<p>（3)logger对象</p>
<p>上述几个例子中我们了解到了logging.debug()、logging.info()、logging.warning()、logging.error()、logging.critical()（分别用以记录不同级别的日志信息），logging.basicConfig()（用默认日志格式（Formatter）为日志系统建立一个默认的流处理器（StreamHandler），设置基础配置（如日志级别等）并加到root logger（根Logger）中）这几个logging模块级别的函数，另外还有一个模块级别的函数是logging.getLogger([name])（返回一个logger对象，如果没有指定名字将返回root logger）</p>
<p>先看一个最简单的过程：</p>
<pre><code>import logging

logger = logging.getLogger()
# 创建一个handler，用于写入日志文件
fh = logging.FileHandler(&apos;test.log&apos;)

# 再创建一个handler，用于输出到控制台
ch = logging.StreamHandler()

formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;)

fh.setFormatter(formatter)
ch.setFormatter(formatter)

logger.addHandler(fh) #logger对象可以添加多个fh和ch对象
logger.addHandler(ch)

logger.debug(&apos;logger debug message&apos;)
logger.info(&apos;logger info message&apos;)
logger.warning(&apos;logger warning message&apos;)
logger.error(&apos;logger error message&apos;)
logger.critical(&apos;logger critical message&apos;)
</code></pre><p>先简单介绍一下，logging库提供了多个组件：Logger、Handler、Filter、Formatter。Logger对象提供应用程序可直接使用的接口，Handler发送日志到适当的目的地，Filter提供了过滤日志信息的方法，Formatter指定日志显示格式。</p>
<p>Logger是一个树形层级结构，输出信息之前都要获得一个Logger（如果没有显示的获取则自动创建并使用root Logger，如第一个例子所示）。</p>
<p>logger = logging.getLogger()返回一个默认的Logger也即root Logger，并应用默认的日志级别、Handler和Formatter设置。</p>
<p>当然也可以通过Logger.setLevel(lel)指定最低的日志级别，可用的日志级别有logging.DEBUG、logging.INFO、logging.WARNING、logging.ERROR、logging.CRITICAL。</p>
<p>Logger.debug()、Logger.info()、Logger.warning()、Logger.error()、Logger.critical()输出不同级别的日志，只有日志等级大于或等于设置的日志级别的日志才会被输出。</p>
<pre><code>logger.debug(&apos;logger debug message&apos;)  
logger.info(&apos;logger info message&apos;)  
logger.warning(&apos;logger warning message&apos;)  
logger.error(&apos;logger error message&apos;)  
logger.critical(&apos;logger critical message&apos;)  
</code></pre><p>只输出了</p>
<pre><code>2018-01-24 12:54:43,222 - root - WARNING - logger warning message
2018-01-24 12:54:43,223 - root - ERROR - logger error message
2018-01-24 12:54:43,224 - root - CRITICAL - logger critical message
</code></pre><p>从这个输出可以看出logger = logging.getLogger()返回的Logger名为root。这里没有用logger.setLevel(logging.Debug)显示的为logger设置日志级别，所以使用默认的日志级别WARNIING，故结果只输出了大于等于WARNIING级别的信息。</p>
<p>如果我们再创建两个logger对象：</p>
<pre><code>logger1 = logging.getLogger(&apos;mylogger&apos;)
logger1.setLevel(logging.DEBUG)

logger2 = logging.getLogger(&apos;mylogger&apos;)
logger2.setLevel(logging.INFO)

logger1.addHandler(fh)
logger1.addHandler(ch)

logger2.addHandler(fh)
logger2.addHandler(ch)

logger1.debug(&apos;logger1 debug message&apos;)
logger1.info(&apos;logger1 info message&apos;)
logger1.warning(&apos;logger1 warning message&apos;)
logger1.error(&apos;logger1 error message&apos;)
logger1.critical(&apos;logger1 critical message&apos;)

logger2.debug(&apos;logger2 debug message&apos;)
logger2.info(&apos;logger2 info message&apos;)
logger2.warning(&apos;logger2 warning message&apos;)
logger2.error(&apos;logger2 error message&apos;)
logger2.critical(&apos;logger2 critical message&apos;)
</code></pre><p>结果：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-7.png" alt="9-7"></p>
<p>这里有两个个问题：</p>
<p><1>我们明明通过logger1.setLevel(logging.DEBUG)将logger1的日志级别设置为了DEBUG，为何显示的时候没有显示出DEBUG级别的日志信息，而是从INFO级别的日志开始显示呢？</1></p>
<p>原来logger1和logger2对应的是同一个Logger实例，只要logging.getLogger（name）中名称参数name相同则返回的Logger实例就是同一个，且仅有一个，也即name与Logger实例一一对应。在logger2实例中通过logger2.setLevel(logging.INFO)设置mylogger的日志级别为logging.INFO，所以最后logger1的输出遵从了后来设置的日志级别。</p>
<p><2>为什么logger1、logger2对应的每个输出分别显示两次?</2></p>
<p>这是因为我们通过logger = logging.getLogger()显示的创建了root Logger，而logger1 = logging.getLogger(‘mylogger’)创建了root Logger的孩子(root.)mylogger,logger2同样。而孩子,孙子，重孙……既会将消息分发给他的handler进行处理也会传递给所有的祖先Logger处理。</p>
<p>ok,那么现在我们把</p>
<p># logger.addHandler(fh)<br># logger.addHandler(ch)  注释掉，我们再来看效果：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-8.png" alt="9-8"></p>
<p>因为我们注释了logger对象显示的位置，所以才用了默认方式，即标准输出方式。因为它的父级没有设置文件显示方式，所以在这里只打印了一次。孩子,孙子，重孙……可逐层继承来自祖先的日志级别、Handler、Filter设置，也可以通过Logger.setLevel(lel)、Logger.addHandler(hdlr)、Logger.removeHandler(hdlr)、Logger.addFilter(filt)、Logger.removeFilter(filt)。设置自己特别的日志级别、Handler、Filter。若不设置则使用继承来的值。</p>
<p><3>Filter</3></p>
<p>限制只有满足过滤规则的日志才会输出。</p>
<p>比如我们定义了filter = logging.Filter(‘a.b.c’),并将这个Filter添加到了一个Handler上，则使用该Handler的Logger中只有名字带 a.b.c前缀的Logger才能输出其日志。</p>
<pre><code>filter = logging.Filter(&apos;mylogger&apos;) 

logger.addFilter(filter)
</code></pre><p>这是只对logger这个对象进行筛选,如果想对所有的对象进行筛选，则：</p>
<pre><code>filter = logging.Filter(&apos;mylogger&apos;) 

fh.addFilter(filter)

ch.addFilter(filter)
</code></pre><p> 这样，所有添加fh或者ch的logger对象都会进行筛选。</p>
<h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>就其本质而言，正则表达式（或 RE）是一种小型的、高度专业化的编程语言，（在Python中）它内嵌在Python中，并通过 re 模块实现。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。</p>
<p>字符匹配（普通字符，元字符）：</p>
<p>（1）普通字符：大多数字符和字母都会和自身匹配</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-9.png" alt="9-9"></p>
<p>(2)元字符：<code>. ^ $ * + ? { } [ ] | ( ) \</code></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-10.png" alt="9-10"></p>
<p>注意：前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配</p>
<p>（3）元字符之字符集［］：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-11.png" alt="9-11"></p>
<p>在字符集里有功能的符号: - ^ \</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-12.png" alt="9-12"></p>
<p>（4)元字符之转义符\</p>
<p>反斜杠后边跟元字符去除特殊功能,比如.</p>
<p>反斜杠后边跟普通字符实现特殊功能,比如\d</p>
<p>\d  匹配任何十进制数；它相当于类 [0-9]。</p>
<p>\D 匹配任何非数字字符；它相当于类 [^0-9]。</p>
<p>\s  匹配任何空白字符；它相当于类 [ \t\n\r\f\v]。</p>
<p>\S 匹配任何非空白字符；它相当于类 [^ \t\n\r\f\v]。</p>
<p>\w 匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。</p>
<p>\W 匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]</p>
<p>\b  匹配一个特殊字符边界，比如空格 ，&amp;，＃等</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-13.png" alt="9-13"></p>
<p>一个小坑：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-14.png" alt="9-14"></p>
<p>选择\b是因为\b在ASCII表中是有意义的</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-15.png" alt="9-15"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-16.png" alt="9-16"></p>
<p>（5)元字符之分组()</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-17.png" alt="9-17"></p>
<p>(6)元字符之｜</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-18.png" alt="9-18"></p>
<p>(7)re模块下的常用方法</p>
<pre><code>import  re

#1
re.findall(&apos;a&apos;,&apos;alvin yuan&apos;)    #返回所有满足匹配条件的结果,放在列表里

#2
re.search(&apos;a&apos;,&apos;alvin yuan&apos;).group()  #函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以
# 通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。

#3
re.match(&apos;a&apos;,&apos;abc&apos;).group()     #同search,不过尽在字符串开始处进行匹配

#4
ret=re.split(&apos;[ab]&apos;,&apos;abcd&apos;)     #先按&apos;a&apos;分割得到&apos;&apos;和&apos;bcd&apos;,在对&apos;&apos;和&apos;bcd&apos;分别按&apos;b&apos;分割
print(ret)#[&apos;&apos;, &apos;&apos;, &apos;cd&apos;]

#5
ret=re.sub(&apos;\d&apos;,&apos;abc&apos;,&apos;alvin5yuan6&apos;,1)
print(ret)#alvinabcyuan6
ret=re.subn(&apos;\d&apos;,&apos;abc&apos;,&apos;alvin5yuan6&apos;)
print(ret)#(&apos;alvinabcyuanabc&apos;, 2)

#6
obj=re.compile(&apos;\d{3}&apos;)
ret=obj.search(&apos;abc123eeee&apos;)
print(ret.group())#123

#7
ret=re.finditer(&apos;\d&apos;,&apos;ds3sy4784a&apos;)
print(ret)        #&lt;callable_iterator object at 0x10195f940&gt;
print(next(ret).group())
print(next(ret).group())

注意：
import re

ret=re.findall(&apos;www.(baidu|163).com&apos;,&apos;www.baidu.com&apos;)
print(ret)#[&apos;baidu&apos;]     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可

ret=re.findall(&apos;www.(?:baidu|163.com&apos;,&apos;www.163.com&apos;)
print(ret)#[&apos;www.163.com&apos;]
</code></pre><p>PS: Python支持的正则表达式元字符和语法汇总表</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/9-19.png" alt="9-19"></p>
<p>(8)正则表达式使用总结：</p>
<p>1、用法</p>
<p>^ 匹配字符串的开始。</p>
<p>$ 匹配字符串的结尾。</p>
<p>\b 匹配一个单词的边界。</p>
<p>\d 匹配任意数字。</p>
<p>\D 匹配任意非数字字符。</p>
<p>x? 匹配一个可选的 x 字符 (换言之，它匹配 1 次或者 0 次 x 字符)。</p>
<p>x* 匹配0次或者多次 x 字符。</p>
<p>x+ 匹配1次或者多次 x 字符。</p>
<p>x{n,m} 匹配 x 字符，至少 n 次，至多 m 次。</p>
<p>(a|b|c) 要么匹配 a，要么匹配 b，要么匹配 c。</p>
<p>(x) 一般情况下表示一个记忆组 (remembered group)。你可以利用 re.search 函数返回对象的 groups() 函数获取它的值。</p>
<p>正则表达式中的点号通常意味着 “匹配任意单字符”</p>
<p>2、解题思路：</p>
<p>匹配出所有的整数：1-2*(60+(-40.35/5)-(-4*3))</p>
<p>A、既然是提取数字，那么数字的形式一般是：整数，小数，整数加小数；</p>
<p>B、所以一般是形如：—-.—–或者就是—-</p>
<p>C、根据上述正则表达式的含义，可写出如下的表达式：“-?\d+.\d*|(-?\d+) “；</p>
<p>D、-？\d+匹配1次或者0次负号；.这个是匹配小数点的；\d*这个是匹配小数点之后的数字的，所以是0个或者多个；|表示左右表达式任意匹配一个 ；</p>
<p>3.代码</p>
<pre><code>import  re
ret=re.findall(r&quot;-?\d+\.\d*|(-?\d+)&quot;,&quot;1-2*(60+(-40.35/5)-(-4*3))&quot;)
ret.remove(&quot;&quot;)
print(ret)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模块-amp-包&quot;&gt;&lt;a href=&quot;#模块-amp-包&quot; class=&quot;headerlink&quot; title=&quot;模块&amp;amp;包&quot;&gt;&lt;/a&gt;模块&amp;amp;包&lt;/h1&gt;&lt;h2 id=&quot;模块-modue-的概念：&quot;&gt;&lt;a href=&quot;#模块-modue-的概念：&quot; c
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（八）：装饰器</title>
    <link href="http://yjscloud.com/2018/01/21/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yjscloud.com/2018/01/21/Python当歌（八）：装饰器/</id>
    <published>2018-01-21T08:04:24.000Z</published>
    <updated>2018-02-07T11:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>讲 Python 装饰器前，我想先举个例子，虽有点污，但跟装饰器这个话题很贴切。每个人都有的内裤主要功能是用来遮羞，但是到了冬天它没法为我们防风御寒，咋办？我们想到的一个办法就是把内裤改造一下，让它变得更厚更长，这样一来，它不仅有遮羞功能，还能提供保暖，不过有个问题，这个内裤被我们改造成了长裤后，虽然还有遮羞功能，但本质上它不再是一条真正的内裤了。于是聪明的人们发明长裤，在不影响内裤的前提下，直接把长裤套在了内裤外面，这样内裤还是内裤，有了长裤后宝宝再也不冷了。装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。</p>
<p>谈装饰器前，还要先要明白一件事，Python 中的函数和 Java、C++不太一样，Python 中的函数可以像普通变量一样当做参数传递给另外一个函数，例如：</p>
<pre><code>def foo():
    print(&quot;foo&quot;)

def bar(func):
    func()

bar(foo)
</code></pre><p>正式回到我们的主题。装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：时间计算、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<p>先来看一个简单例子：</p>
<pre><code>import time

def foo():
    time.sleep(3)
    print(&quot;运行时间是%s&quot; %(stop_time - start_time))
</code></pre><p>现在有一个新的需求，希望可以记录下函数运行的时间，于是在代码中添加计算时间的代码：</p>
<pre><code>import time

def foo():
    start_time = time.time()
    time.sleep(3)
    stop_time = time.time()
    print(&quot;运行时间是%s&quot; %(stop_time - start_time))
</code></pre><p>如果函数 bar()、bar2() 也有类似的需求，怎么做？再写一个 类似的代码在 bar 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门计算函数运行时间 ，时间计算完成之后再执行真正的业务代码。</p>
<pre><code>import time

def timmer(func): #func=test
    start_time=time.time()
    func() #就是在运行test()
    stop_time = time.time()
    print(&apos;运行时间是%s&apos; %(stop_time-start_time))

def test():
     time.sleep(3)
     print(&apos;test函数运行完毕&apos;)

timmer(test)
</code></pre><p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑test函数，而是换成了timmer函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个test函数作为参数传递给test函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>
<h1 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h1><pre><code>import time
def timmer(func): #func=test
    def wrapper():
        start_time=time.time()
        func() #就是在运行test()
        stop_time = time.time()
        print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper

def test():
    time.sleep(3)
print(&apos;test函数运行完毕&apos;)

test = timmer(test)  #因为装饰器 timmer(test) 返回的时函数对象 wrapper，这条语句相当于test = wrapper
test()    #执行test()就相当与执行wrapper()
</code></pre><p>timmer就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 test 被 timmer 装饰了一样，timmer返回的也是一个函数，这个函数的名字叫 wrapper。在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为面向切面的编程。</p>
<h1 id="语法糖"><a href="#语法糖" class="headerlink" title="@ 语法糖"></a>@ 语法糖</h1><p>如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。</p>
<pre><code>import time
def timmer(func): #func=test
    def wrapper():
        start_time=time.time()
        func() #就是在运行test()
        stop_time = time.time()
        print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper

@timmer
def test():
    time.sleep(3)
print(&apos;test函数运行完毕&apos;)

test()
</code></pre><p>如上所示，有了 @ ，我们就可以省去test = timmer(test)这一句了，直接调用 test() 即可得到想要的结果。你们看到了没有，test() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>
<p>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p>
<h1 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="*args、**kwargs"></a>*args、**kwargs</h1><p>如果我的业务逻辑函数 foo 需要参数怎么办？比如：</p>
<pre><code>def test(name):
    time.sleep(3)
    print(“test函数运行完毕,名字是【%s】” %name)
</code></pre><p>我们可以在定义 wrapper 函数的时候指定参数：</p>
<pre><code>def wrapper(name):
    start_time=time.time()
    func(name)        
     stop_time = time.time()
     print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper
</code></pre><p>这样 test的参数就可以定义在 wrapper 函数中。如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，就多个。当装饰器不知道 test个参数时，我们可以用 * args 来代替：</p>
<pre><code>def wrapper(*args):
    start_time=time.time()
    func(*args)        
    stop_time = time.time()
    print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper
</code></pre><p>如此一来，甭管 test定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 test的业务逻辑了。这时还有读者会问，如果 test函数还定义了一些关键字参数呢？比如：</p>
<pre><code>def test(name,age,gender):
    time.sleep(1)
    print(&apos;test1函数运行完毕,名字是【%s】 年龄是【%s】 性别【%s】&apos; %(name,age,gender))
    return &apos;这是test的返回值&apos;
</code></pre><p>这时，你就可以把 wrapper 函数指定关键字函数：</p>
<pre><code>def wrapper(*args,**kwargs):
    start_time=time.time()
    func(*args,**kwargs)
    stop_time = time.time()
    print(&apos;运行时间是%s&apos; %(stop_time-start_time))
    return wrapper
</code></pre><h1 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h1><p>装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数test 。装饰器的语法允许我们在调用时，提供其它参数，比如@timmer()。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定如何计算时间，因为不同业务函数可能需要的计算时间方式是不一样的。</p>
<pre><code>import time

def cal_time(timing):
    def timmer(func):
        def wrapper(*args, **kwargs):
                start_time = time.time()
                func(*args, **kwargs)
                stop_time = time.time()
                if timing == &quot;True&quot;:
                    print(&quot;运行时间是%s&quot; %(stop_time - start_time))
                else:
                    print(&quot;鬼知道他运行了多长时间&quot;)
        return wrapper
    return timmer

@cal_time(timing=&quot;True&quot;)
def test():
    time.sleep(3)
    print(&quot;test函数运行完毕&quot;)

test()
</code></pre><p>上面的cal_time是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用@cal_time(timing=”True”)调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。</p>
<p> @cal_time(timing=”True”等价于@timmer</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;讲 Python 装饰器前，我想先举个例子，虽有点污，但跟装饰器这个话题很贴切。每个人都有的内裤主要功能是用来遮羞，但是到了冬天它没法为我们
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（七）：闭包</title>
    <link href="http://yjscloud.com/2018/01/20/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E9%97%AD%E5%8C%85/"/>
    <id>http://yjscloud.com/2018/01/20/Python当歌（七）：闭包/</id>
    <published>2018-01-20T07:54:22.000Z</published>
    <updated>2018-02-07T11:14:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是程序运行时变量可被访问的范围，定义在函数内的变量是局部变量，局部变量的作用范围只能是函数内部范围内，它不能在函数外引用。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-1.png" alt="7-1"></p>
<p>定义在模块最外层的变量是全局变量，它是全局范围内可见的，当然在函数里面也可以读取到全局变量的。例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-2.png" alt="7-2"></p>
<h1 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h1><p>函数不仅可以定义在模块的最外层，还可以定义在另外一个函数的内部，像这种定义在函数里面的函数称之为嵌套函数（nested function）例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-3.png" alt="7-3"></p>
<p>对于嵌套函数，它可以访问到其外层作用域中声明的非局部（non-local）变量，比如代码示例中的变量 msg 可以被嵌套函数 printer 正常访问。</p>
<p>那么有没有一种可能即使脱离了函数本身的作用范围，局部变量还可以被访问得到呢？答案是闭包。</p>
<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>函数身为第一类对象，它可以作为函数的返回值返回，现在我们来考虑如下的例子：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-4.png" alt="7-4"></p>
<p>这段代码和前面例子的效果完全一样，同样输出 “python”。不同的地方在于内部函数 printer 直接作为返回值返回了。</p>
<p>一般情况下，函数中的局部变量仅在函数的执行期间可用，一旦 print_msg() 执行过后，我们会认为 msg变量将不再可用。然而，在这里我们发现 print_msg 执行完之后，在调用 another 的时候 msg 变量的值正常输出了，这就是闭包的作用，闭包使得局部变量在函数外被访问成为可能。<br>这里的 another 就是一个闭包，闭包本质上是一个函数，它有两部分组成，printer 函数和变量 msg。闭包使得这些变量的值始终保存在内存中。</p>
<p>闭包，顾名思义，就是一个封闭的包裹，里面包裹着自由变量，就像在类里面定义的属性值一样，自由变量的可见范围随同包裹，哪里可以访问到这个包裹，哪里就可以访问到这个自由变量。</p>
<h1 id="为什么要使用闭包"><a href="#为什么要使用闭包" class="headerlink" title="为什么要使用闭包"></a>为什么要使用闭包</h1><p>闭包避免了使用全局变量，此外，闭包允许将函数与其所操作的某些数据（环境）关连起来。这一点与面向对象编程是非常类似的，在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。一般来说，当对象中只有一个方法时，这时使用闭包是更好的选择。来看一个例子：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-5.png" alt="7-5"></p>
<p>这比用类来实现更优雅，此外装饰器也是基于闭包的一中应用场景。<br>所有函数都有一个 <strong>closure</strong>属性，如果这个函数是一个闭包的话，那么它返回的是一个由 cell 对象 组成的元组对象。cell 对象的cell_contents 属性就是闭包中的自由变量。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/7-6.png" alt="7-6"></p>
<p>这解释了为什么局部变量脱离函数之后，还可以在函数之外被访问的原因的，因为它存储在了闭包的 cell_contents中了。</p>
<p>原文地址：<a href="https://foofish.net/python-closure.html" target="_blank" rel="external">一步一步教你认识Python闭包</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包和函数紧密联系在一起，介绍闭包前有必要先介绍一些背景知识，诸如嵌套函数、变量的作用域等概念。&lt;/p&gt;
&lt;h1 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h1&gt;&lt;p&gt;作用域是程序运行时变
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（六）：迭代器、生成器</title>
    <link href="http://yjscloud.com/2018/01/19/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yjscloud.com/2018/01/19/Python当歌（六）：迭代器、生成器/</id>
    <published>2018-01-19T03:15:23.000Z</published>
    <updated>2018-02-07T11:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="迭代的概念"><a href="#迭代的概念" class="headerlink" title="迭代的概念"></a>迭代的概念</h2><p>迭代器即迭代的工具，那什么是迭代呢？</p>
<p>迭代是一个重复的过程，每次重复即一次迭代，并且每次迭代的结果都是下一次迭代的初始值</p>
<pre><code>while True: #只是单纯地重复，因而不是迭代
    print(&apos;===&gt;&apos;) 

l=[1,2,3]
count=0
while count &lt; len(l): #迭代
    print(l[count])
count+=1
</code></pre><h2 id="理解迭代器"><a href="#理解迭代器" class="headerlink" title="理解迭代器"></a>理解迭代器</h2><p>(1)为何要有迭代器？</p>
<p>对于序列类型：字符串、列表、元组，我们可以使用索引的方式迭代取出其包含的元素。但对于字典、集合、文件等类型是没有索引的，若还想取出其内部包含的元素，则必须找出一种不依赖于索引的迭代方式，这就是迭代器</p>
<p>(2)什么是可迭代对象？</p>
<p>可迭代对象指的是内置有<strong>iter</strong>方法的对象，即obj.<strong>iter</strong>，如下</p>
<pre><code>&apos;hello&apos;.__iter__
(1,2,3).__iter__
[1,2,3].__iter__
{&apos;a&apos;:1}.__iter__
{&apos;a&apos;,&apos;b&apos;}.__iter__
open(&apos;a.txt&apos;).__iter__
</code></pre><p>（3）什么是迭代器对象？</p>
<p>可迭代对象执行obj.<strong>iter</strong>()得到的结果就是迭代器对象</p>
<p>而迭代器对象指的是即内置有<strong>iter</strong>又内置有<strong>next</strong>方法的对象</p>
<p>文件类型是迭代器对象</p>
<pre><code>open(&apos;a.txt&apos;).__iter__()
open(&apos;a.txt&apos;).__next__()
</code></pre><p>（4）注意：</p>
<p>迭代器对象一定是可迭代对象，而可迭代对象不一定是迭代器对象</p>
<h2 id="迭代器对象的使用"><a href="#迭代器对象的使用" class="headerlink" title="迭代器对象的使用"></a>迭代器对象的使用</h2><pre><code>dic={&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3}
iter_dic=dic.__iter__() #得到迭代器对象，迭代器对象即有__iter__又有__next__，
</code></pre><p>但是：迭代器.<strong>iter</strong>()得到的仍然是迭代器本身</p>
<pre><code>iter_dic.__iter__() is iter_dic #True
print(iter_dic.__next__()) #等同于next(iter_dic)
print(iter_dic.__next__()) #等同于next(iter_dic)
print(iter_dic.__next__()) #等同于next(iter_dic)
print(iter_dic.__next__()) #抛出异常StopIteration，或者说结束标志
</code></pre><p>有了迭代器，我们就可以不依赖索引迭代取值了</p>
<pre><code>iter_dic=dic.__iter__()
while 1:
    try:
        k=next(iter_dic)
        print(dic[k])
    except StopIteration:
        break
</code></pre><p>这么写太丑陋了，需要我们自己捕捉异常，控制next，python这么牛逼，能不能帮我解决呢？能，请看for循环</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>基于for循环，我们可以完全不再依赖索引去取值了</p>
<pre><code>dic={&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3}
for k in dic:
    print(dic[k])
</code></pre><p>for循环的工作原理</p>
<p>1：执行in后对象的dic.<strong>iter</strong>()方法，得到一个迭代器对象iter_dic</p>
<p>2: 执行next(iter_dic),将得到的值赋值给k,然后执行循环体代码</p>
<p>3: 重复过程2，直到捕捉到异常StopIteration,结束循环</p>
<h2 id="迭代器的优缺点"><a href="#迭代器的优缺点" class="headerlink" title="迭代器的优缺点"></a>迭代器的优缺点</h2><p>优点：</p>
<ul>
<li>提供一种统一的、不依赖于索引的迭代方式</li>
<li>惰性计算，节省内存</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法获取长度（只有在next完毕才知道到底有几个值）</li>
<li>一次性的，只能往后走，不能往前退</li>
</ul>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h2><p>通函数用 return 返回一个值，和 Java 等其他语言是一样的，然而在 Python 中还有一种函数，用关键字 yield 来返回值，这种函数叫生成器函数，函数被调用时会返回一个生成器对象，生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁。</p>
<p>最简单的生成器函数：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-1.png" alt="6-1"></p>
<p>func 就是一个生成器函数，调用该函数时返回对象就是生成器 g ，这个生成器对象的行为和迭代器是非常相似的，可以用在 for 循环等场景中。注意 yield 对应的值在函数被调用时不会立刻返回，而是调用next方法时（本质上 for 循环也是调用 next 方法）才返回</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-2.png" alt="6-2"></p>
<p>那为什么要用生成器呢？显然，用生成器在逼格上要比迭代器高几个等级，它没有那么多冗长代码了，而且性能上一样的高效，为什么不用呢？来看看用生成器实现斐波那契数列有多简单。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-3.png" alt="6-3"></p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，但是它返回的是一个生成器对象而不是列表对象。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/6-4.png" alt="6-4"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;迭代器&quot;&gt;&lt;a href=&quot;#迭代器&quot; class=&quot;headerlink&quot; title=&quot;迭代器&quot;&gt;&lt;/a&gt;迭代器&lt;/h1&gt;&lt;h2 id=&quot;迭代的概念&quot;&gt;&lt;a href=&quot;#迭代的概念&quot; class=&quot;headerlink&quot; title=&quot;迭代的概念&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（五）：文件读写</title>
    <link href="http://yjscloud.com/2018/01/18/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://yjscloud.com/2018/01/18/Python当歌（五）：文件读写/</id>
    <published>2018-01-18T02:40:14.000Z</published>
    <updated>2018-02-07T11:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>计算机系统分为：计算机硬件，操作系统，应用程序三部分。</p>
<p>我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。<br>有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程：</p>
<ol>
<li>打开文件，得到文件句柄并赋值给一个变量</li>
<li>通过句柄对文件进行操作</li>
<li>关闭文件</li>
</ol>
<h1 id="在python中"><a href="#在python中" class="headerlink" title="在python中"></a>在python中</h1><p>(1)打开文件，得到文件句柄并赋值给一个变量</p>
<p>f=open(‘a.txt’,’r’,encoding=’utf-8’) #默认打开模式就为r</p>
<p>(2) 通过句柄对文件进行操作</p>
<p>data=f.read()</p>
<p>(3) 关闭文件</p>
<p>f.close()</p>
<p>分析一下f=open(‘a.txt’,’r’)过程：</p>
<p>1、由应用程序向操作系统发起系统调用open(…)</p>
<p>2、操作系统打开该文件，并返回一个文件句柄给应用程序</p>
<p>3、应用程序将文件句柄赋值给变量f</p>
<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p>1、强调第一点：</p>
<p>打开一个文件包含两部分资源：操作系统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源一个不落地回收，回收方法为：</p>
<p>（1）f.close() #回收操作系统级打开的文件</p>
<p>（2）del f #回收应用程序级的变量</p>
<p>其中del f一定要发生在f.close()之后，否则就会导致操作系统打开的文件还没有关闭，白白占用资源，而python自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close()。</p>
<p>但是每次都这么写实在太繁琐，所以，Python引入了with语句来自动帮我们调用close()方法：</p>
<pre><code>with open(&apos;a.txt&apos;,&apos;w&apos;) as f:
    pass

with open(&apos;a.txt&apos;,&apos;r&apos;) as read_f,open(&apos;b.txt&apos;,&apos;w&apos;) as write_f:
    data=read_f.read()
write_f.write(data)
</code></pre><p>2、强调第二点：</p>
<p>f=open(…)是由操作系统打开文件，那么如果我们没有为open指定编码，那么打开文件的默认编码很明显是操作系统说了算了，操作系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。若要保证不乱码，文件以什么方式存的，就要以什么方式打开。<br>f=open(‘a.txt’,’r’,encoding=’utf-8’)</p>
<p>3、强调第三点</p>
<p>由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try … finally来实现：</p>
<pre><code>try:
    f = open(&apos;/path/to/file&apos;, &apos;r&apos;)
    print(f.read())
finally:
    if f:
        f.close()
</code></pre><h1 id="打开文件的模式"><a href="#打开文件的模式" class="headerlink" title="打开文件的模式"></a>打开文件的模式</h1><p>（1）打开文件的模式有(默认为文本模式)：</p>
<ul>
<li>r ，只读模式【默认模式，文件必须存在，不存在则抛出异常】</li>
<li>w，只写模式【不可读；不存在则创建；存在则清空内容】</li>
<li>a， 之追加写模式【不可读；不存在则创建；存在则只追加内容】</li>
</ul>
<p>（2）对于非文本文件，我们只能使用b模式，”b”表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式）</p>
<ul>
<li>rb </li>
<li>wb</li>
<li>ab</li>
</ul>
<p>注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码</p>
<p>（3）了解部分</p>
<ul>
<li>“+” 表示可以同时读写某个文件</li>
<li>r+， 读写【可读，可写】</li>
<li>w+，写读【可读，可写】</li>
<li>a+， 写读【可读，可写】</li>
<li>x， 只写模式【不可读；不存在则创建，存在则报错】</li>
<li>x+ ，写读【可读，可写】</li>
</ul>
<h1 id="操作文件的方法"><a href="#操作文件的方法" class="headerlink" title="操作文件的方法"></a>操作文件的方法</h1><p>（1）掌握</p>
<ul>
<li>f.read() #读取所有内容,光标移动到文件末尾</li>
<li>f.readline() #读取一行内容,光标移动到第二行首部</li>
<li>f.readlines() #读取每一行内容,存放于列表中</li>
<li>f.write(‘1111\n222\n’) #针对文本模式的写,需要自己写换行符</li>
<li>f.write(‘1111\n222\n’.encode(‘utf-8’)) #针对b模式的写,需要自己写换行符</li>
<li>f.writelines([‘333\n’,’444\n’]) #文件模式</li>
<li>f.writelines([bytes(‘333\n’,encoding=’utf-8’),’444\n’.encode(‘utf-8’)]) #b模式</li>
</ul>
<p>（2）了解</p>
<ul>
<li>f.readable() #文件是否可读</li>
<li>f.writable() #文件是否可读</li>
<li>f.closed #文件是否关闭</li>
<li>f.encoding #如果文件打开模式为b,则没有该属性</li>
<li>f.flush() #立刻将文件内容从内存刷到硬盘</li>
<li>f.name</li>
</ul>
<h1 id="文件内光标移动"><a href="#文件内光标移动" class="headerlink" title="文件内光标移动"></a>文件内光标移动</h1><p>（1）read(3)：</p>
<ul>
<li>文件打开方式为文本模式时，代表读取3个字符</li>
<li>文件打开方式为b模式时，代表读取3个字节</li>
</ul>
<p>（2）其余的文件内光标移动都是以字节为单位如seek，tell，truncate</p>
<p>注意：</p>
<ul>
<li>seek有三种移动方式0，1，2，其中1和2必须在b模式下进行，但无论哪种模式，都是以bytes为单位移动的</li>
<li><p>truncate是截断文件，所以文件的打开方式必须可写，但是不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果：</p>
<pre><code>import time
with open(&apos;test.txt&apos;,&apos;rb&apos;) as f:
    f.seek(0,2)
while True:
    line=f.readline()
    if line:
        print(line.decode(&apos;utf-8&apos;))
    else:
        time.sleep(0.2)
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;计算机系统分为：计算机硬件，操作系统，应用程序三部分。&lt;/p&gt;
&lt;p&gt;我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（四）：函数</title>
    <link href="http://yjscloud.com/2018/01/17/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yjscloud.com/2018/01/17/Python当歌（四）：函数/</id>
    <published>2018-01-17T01:49:07.000Z</published>
    <updated>2018-02-07T11:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><p>函数是什么?</p>
<p>想象生活中的例子，修理工需要实现准备好工具箱里面放好锤子，扳手，钳子等工具，然后遇到锤钉子的场景，拿来锤子用就可以，而无需临时再制造一把锤子。</p>
<p>修理工===&gt;程序员</p>
<p>具备某一功能的工具===&gt;函数</p>
<p>要想使用工具，需要事先准备好，然后拿来就用且可以重复使用要想用函数，需要先定义，再使用。</p>
<h1 id="函数分类"><a href="#函数分类" class="headerlink" title="函数分类"></a>函数分类</h1><p>（1）内置函数</p>
<p>为了方便我们的开发，针对一些简单的功能，python解释器已经为我们定义好了的函数即内置函数。对于内置函数，我们可以拿来就用而无需事先定义，如len(),sum(),max()</p>
<p>（2）自定义函数</p>
<p>很明显内置函数所能提供的功能是有限的，这就需要我们自己根据需求，事先定制好我们自己的函数来实现某种功能，以后，在遇到应用场景时，调用自定义的函数即可。</p>
<p>（3）如何自定义函数？</p>
<pre><code>语法：
    def 函数名(参数1,参数2,参数3,...):
        &apos;&apos;&apos;注释&apos;&apos;&apos;
        函数体
        return 返回的值
</code></pre><p>ps:函数名要能反映其意义</p>
<p>（4）函数使用的原则：先定义，再调用</p>
<p>函数即“变量”，“变量”必须先定义后引用。未定义而直接引用函数，就相当于在引用一个不存在的变量名</p>
<p>测试一：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-1.png" alt="3-1"></p>
<p>测试二：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-2.png" alt="3-2"></p>
<p>结论:函数的使用,必须遵循原则:先定义,后调用；我们在使用函数时,一定要明确地区分定义阶段和调用阶段。</p>
<pre><code>#定义阶段
def foo():
    print(&apos;from foo&apos;)
    bar()
def bar():
    print(&apos;from bar&apos;)
#调用阶段
foo()
</code></pre><p>ps:函数在定义阶段只检测语法，不执行代码。也就说，语法错误在函数定义阶段就会检测出来，而代码的逻辑错误只有在执行时才会知道</p>
<p>(5)定义函数的三种形式</p>
<p>1、无参：应用场景仅仅只是执行一些操作，比如与用户交互，打印</p>
<p>2、有参：需要根据外部传进来的参数，才能执行相应的逻辑，比如统计长度，求最大值最小值</p>
<p>3、空函数：设计代码结构</p>
<p>例子：<br>    <img src="http://p3q1rwnbl.bkt.clouddn.com/3-3.png" alt="3-3"></p>
<p>结论：定义时无参，意味着调用时也无需传入参数；定义时有参，意味着调用时则必须传入参数</p>
<p>（6)调用函数</p>
<p>函数的调用：函数名加括号</p>
<ul>
<li><p>先找到名字</p>
</li>
<li><p>根据名字调用代码</p>
</li>
</ul>
<p>函数调用的三种形式：</p>
<ul>
<li><p>语句形式：foo()</p>
</li>
<li><p>表达式形式：3*len(‘hello’)</p>
</li>
<li><p>当中另外一个函数的参数：range(len(‘hello’))</p>
</li>
</ul>
<p>函数返回值：</p>
<ul>
<li><p>无return-&gt;None</p>
</li>
<li><p>return 1个值-&gt;返回1个值</p>
</li>
<li><p>return 逗号分隔多个值-&gt;元组</p>
</li>
</ul>
<p>什么时候该有返回值？</p>
<p>调用函数，经过一系列的操作，最后要拿到一个明确的结果，则必须要有返回值（通常有参函数需要有返回值，输入参数，经过计算，得到一个最终的结果）</p>
<p>什么时候不需要有返回值？</p>
<p>调用函数，仅仅只是执行一系列的操作，最后不需要得到什么结果，则无需有返回值（通常无参函数不需要有返回值）</p>
<p>（7）函数的参数<br>形参即变量名，实参即变量值，函数调用时，将值绑定到变量名上，函数调用结束，解除绑定。</p>
<p>1、位置参数：按照从左到右的顺序定义的参数</p>
<p>   位置形参：必选参数</p>
<p>   位置实参：按照位置给形参传值</p>
<p>2、关键字参数：按照key=value的形式定义的实参</p>
<p>   无需按照位置为形参传值</p>
<p>   注意的问题：</p>
<ul>
<li>关键字实参必须在位置实参右面</li>
<li>对同一个形参不能重复传值</li>
</ul>
<p>3、默认参数：形参在定义时就已经为其赋值</p>
<p>可以传值也可以不传值，经常需要变得参数定义成位置形参，变化较小的参数定义成默认参数（形参）</p>
<p> 注意的问题：</p>
<ul>
<li>只在定义时赋值一次</li>
<li>默认参数的定义应该在位置形参右面</li>
<li>默认参数通常应该定义成不可变类型</li>
</ul>
<p>4、可变长参数：</p>
<p>  可变长指的是实参值的个数不固定</p>
<p>  而实参有按位置和按关键字两种形式定义，针对这两种形式的可变长，形参对应有两种解决方案来完整地存放它们，分别是<em>args（列表），*</em>kwargs（字典）</p>
<p>测试：*args</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-4.png" alt="3-4"></p>
<p>测试：**kwargs</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-5.png" alt="3-5"></p>
<p>5、命名关键字参数：*后定义的参数，必须被传值（有默认值的除外），且必须按照关键字实参的形式传递可以保证，传入的参数中一定包含某些关键字。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-6.png" alt="3-6"></p>
<h1 id="函数的变量、递归以及内置函数"><a href="#函数的变量、递归以及内置函数" class="headerlink" title="函数的变量、递归以及内置函数"></a>函数的变量、递归以及内置函数</h1><h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>在子程序中定义的变量称为局部变量，在程序的一开始定义的变量称为全局变量。</p>
<p>全局变量作用域是整个程序，局部变量作用域是定义该变量的子程序。</p>
<p>当全局变量与局部变量同名时：在定义局部变量的子程序内，局部变量起作用；在其它地方全局变量起作用。</p>
<pre><code>name=&apos;xwq&apos;
def change_name():
    print(&apos;我的名字&apos;,name)    #全局变量起作用
change_name()

def change_name():
    name=&apos;帅了一笔&apos;
    print(&apos;我的名字&apos;,name)        #局部变量起作用
    change_name()
print(name)

def change_name():
    global name
    name=&apos;帅了一笔&apos;
    print(&apos;我的名字&apos;,name)        #因为global参数全局变量变为‘帅了一笔’而非xwq,
change_name()
</code></pre><p>ps：nonlocal参数</p>
<pre><code>name = &quot;lf&quot;
def weihou():
    name = &quot;xwq&quot;
    def weiweihou():
        nonlocal name   # nonlocal，指定上一级变量，如果没有就继续往上直到找到为止
        name = &quot;冷静&quot;    
    weiweihou()
    print(name)
print(name)
weihou()
print(name)
</code></pre><p>运行结果为：</p>
<pre><code>lf
冷静
lf
</code></pre><h2 id="嵌套函数和作用域"><a href="#嵌套函数和作用域" class="headerlink" title="嵌套函数和作用域"></a>嵌套函数和作用域</h2><pre><code>name = &quot;xwq&quot;

def change_name():
    name = &quot;xwq2&quot;

    def change_name2():
        name = &quot;xwq3&quot;
        print(&quot;第3层打印&quot;,name)

    change_name2() #调用内层函数
    print(&quot;第2层打印&quot;,name)

change_name()
print(&quot;最外层打印&quot;,name)
</code></pre><p>此时，在最外层调用change_name2()会出现什么效果？没错，出错了， 为什么呢？<br>作用域在定义函数时就已经固定住了，不会随着调用位置的改变而改变。</p>
<p>例一：</p>
<pre><code>name=&apos;alex&apos;

def foo():
    name=&apos;lhf&apos;
    def bar():
        print(name)
    return bar

func=foo()
func()
</code></pre><p>例二：</p>
<pre><code>name=&apos;alex&apos;

def foo():
    name=&apos;lhf&apos;
    def bar():
        name=&apos;wupeiqi&apos;
        def tt():
            print(name)
        return tt
    return bar

func=foo()
func()()
</code></pre><h2 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h2><p>在函数内部，可以调用其他函数。如果在调用一个函数的过程中直接或间接调用自身本身</p>
<pre><code>def calc(n):
    print(n)
    if int(n/2) ==0:
        return n
    return calc(int(n/2))

calc(10)
</code></pre><p>输出：</p>
<pre><code>10
5
2
1
</code></pre><p>递归特性:</p>
<ul>
<li>必须有一个明确的结束条件</li>
<li>每次进入更深一层递归时，问题规模相比上次递归都应有所减少</li>
<li>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）</li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>（1）zip()函数</p>
<p>zip()函数接受0个或多个序列作为参数，返回一个tuple列表。 </p>
<p>zip()函数具体的工作机制是，将每个列表中同一位置的元素取出来组成一个元组，存放到一个列表中，然后返回这个列表。举例说明：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-7.png" alt="3-7"></p>
<p>对于长度不同的seq，zip()函数处理;</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-8.png" alt="3-8"><br>从上面的例子可以看出，当seq的长度不一致时，zip()会以最短的那个seq为主，进行处理，然后将多余的舍弃掉.</p>
<p>zip()对只有一个seq的处理：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-9.png" alt="3-9"></p>
<p>(2)map()函数</p>
<p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。举例说明：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-10.png" alt="3-10"></p>
<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。</p>
<p>map（）可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-11.png" alt="3-11"></p>
<p>(3)reduce()函数</p>
<p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。举例说明：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-12.png" alt="3-12"></p>
<p>(4)filter()函数</p>
<p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
<p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-13.png" alt="3-13"></p>
<p>把一个序列中的空字符串删掉，可以这么写：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-14.png" alt="3-14"></p>
<p>可见用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。</p>
<p>注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。</p>
<p>(5)sorted() 函数对所有可迭代的对象进行排序操作。</p>
<p>sort 与 sorted 区别：sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-15.png" alt="3-15"></p>
<p>此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-16.png" alt="3-16"></p>
<p>(6)max()/min()函数</p>
<p>max(iterable, key, default) 求迭代器的最大值，其中iterable 为迭代器，max会for i in … 遍历一遍这个迭代器，然后将迭代器的每一个返回值当做参数传给key=func 中的func(一般用lambda表达式定义) ，然后将func的执行结果传给key，然后以key为标准进行大小的判断。</p>
<p>以下根据不同的判断条件返回最大值也不同</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/3-17.png" alt="3-17"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;函数基础&quot;&gt;&lt;a href=&quot;#函数基础&quot; class=&quot;headerlink&quot; title=&quot;函数基础&quot;&gt;&lt;/a&gt;函数基础&lt;/h1&gt;&lt;p&gt;函数是什么?&lt;/p&gt;
&lt;p&gt;想象生活中的例子，修理工需要实现准备好工具箱里面放好锤子，扳手，钳子等工具，然后遇到锤钉子的场景
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（三）：字符串格式化</title>
    <link href="http://yjscloud.com/2018/01/17/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>http://yjscloud.com/2018/01/17/Python当歌（三）：字符串格式化/</id>
    <published>2018-01-17T01:13:30.000Z</published>
    <updated>2018-02-07T11:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python的字符串格式化有两种方式: 百分号方式、format方式。</p>
<p>百分号的方式相对来说比较老，而format方式则是比较先进的方式，企图替换古老的方式，目前两者并存。</p>
<h1 id="百分号方式"><a href="#百分号方式" class="headerlink" title="百分号方式"></a>百分号方式</h1><p>格式：%[(name)][flags][width].[precision]typecode</p>
<p>（1）(name)     可选，用于选择指定的key</p>
<p>（2）flags       可选，可供选择的值有:</p>
<ul>
<li>“+”       右对齐；正数前加正好，负数前加负号；</li>
<li>“-“        左对齐；正数前无符号，负数前加负号；</li>
<li>空格    右对齐；正数前加空格，负数前加负号；</li>
<li>0    右对齐；正数前无符号，负数前加负号；用0填充空白处</li>
</ul>
<p>（3）    width         可选，占有宽度</p>
<p>（4）    precision   可选，小数点后保留的位数</p>
<p>（5） typecode    必选</p>
<ul>
<li>s，获取传入对象的<strong>str</strong>方法的返回值，并将其格式化到指定位置</li>
<li>r，获取传入对象的<strong>repr</strong>方法的返回值，并将其格式化到指定位置</li>
<li>c，整数：将数字转换成其unicode对应的值，10进制范围为 0 &lt;= i &lt;= 1114111（py27则只支持0-255）；字符：将字符添加到指定位置</li>
<li>o，将整数转换成 八  进制表示，并将其格式化到指定位置</li>
<li>x，将整数转换成十六进制表示，并将其格式化到指定位置</li>
<li>d，将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置</li>
<li>e，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e）</li>
<li>E，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E）</li>
<li>f， 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位）</li>
<li>F，同上</li>
<li>g，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；）</li>
<li>G，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；）</li>
<li>%，当字符串中存在格式化标志时，需要用 %%表示一个百分号</li>
</ul>
<p>注：Python中百分号格式化是不存在自动将整数转换成二进制表示的方式</p>
<p>常用格式化：</p>
<pre><code>tpl = &quot;i am %s&quot; % &quot;alex&quot; 

tpl = &quot;i am %s age %d&quot; % (&quot;alex&quot;, 18)

tpl = &quot;i am %(name)s age %(age)d&quot; % {&quot;name&quot;: &quot;alex&quot;, &quot;age&quot;: 18}

tpl = &quot;percent %.2f&quot; % 99.97623

tpl = &quot;i am %(pp).2f&quot; % {&quot;pp&quot;: 123.425556, }

tpl = &quot;i am %.2f %%&quot; % {&quot;pp&quot;: 123.425556, }
</code></pre><h1 id="Format方式"><a href="#Format方式" class="headerlink" title="Format方式"></a>Format方式</h1><p>格式：[[fill]align][sign][#][0][width][,][.precision][type]</p>
<p>（1）fill    【可选】空白处填充的字符</p>
<p>（2）align   【可选】对齐方式（需配合width使用）</p>
<ul>
<li>“&lt;”，内容左对齐</li>
<li>“&gt;”，内容右对齐(默认)</li>
<li>“＝”，内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。 即使：符号+填充物+数字</li>
<li>“^”，内容居中</li>
</ul>
<p>（3）sign    【可选】有无符号数字</p>
<ul>
<li>“+”，正号加正，负号加负；</li>
<li>“-“，正号不变，负号加负；</li>
<li>空格 ，正号空格，负号加负；</li>
</ul>
<p>（4）”#”        【可选】对于二进制、八进制、十六进制，如果加上#，会显示 0b/0o/0x，否则不显示</p>
<p>（5)”,”      【可选】为数字添加分隔符，如：1,000,000</p>
<p>（6）width  【可选】格式化位所占宽度</p>
<p>（7）.precision 【可选】小数位保留精度</p>
<p>（8）type     【可选】格式化类型</p>
<p>传入” 字符串类型 “的参数</p>
<ul>
<li>s，格式化字符串类型数据</li>
<li>空白，未指定类型，则默认是None，同s</li>
</ul>
<p>传入“ 整数类型 ”的参数</p>
<ul>
<li>b，将10进制整数自动转换成2进制表示然后格式化</li>
<li>c，将10进制整数自动转换为其对应的unicode字符</li>
<li>d，十进制整数</li>
<li>o，将10进制整数自动转换成8进制表示然后格式化；</li>
<li>x，将10进制整数自动转换成16进制表示然后格式化（小写x）</li>
<li>X，将10进制整数自动转换成16进制表示然后格式化（大写X）</li>
</ul>
<p>传入“ 浮点型或小数类型 ”的参数</p>
<ul>
<li>e，转换为科学计数法（小写e）表示，然后格式化；</li>
<li>E，转换为科学计数法（大写E）表示，然后格式化;</li>
<li>f ，转换为浮点型（默认小数点后保留6位）表示，然后格式化；</li>
<li>F， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；</li>
<li>g，自动在e和f中切换</li>
<li>G，自动在E和F中切换</li>
<li>%  显示百分比（默认显示小数点后6位）</li>
</ul>
<p>常用格式化：</p>
<pre><code>tpl = &quot;i am {}, age {}, {}&quot;.format(&quot;seven&quot;, 18, &apos;alex&apos;)

tpl = &quot;i am {}, age {}, {}&quot;.format(*[&quot;seven&quot;, 18, &apos;alex&apos;])

tpl = &quot;i am {0}, age {1}, really {0}&quot;.format(&quot;seven&quot;, 18)

tpl = &quot;i am {0}, age {1}, really {0}&quot;.format(*[&quot;seven&quot;, 18])

tpl = &quot;i am {name}, age {age}, really {name}&quot;.format(name=&quot;seven&quot;, age=18)

tpl = &quot;i am {name}, age {age}, really {name}&quot;.format(**{&quot;name&quot;: &quot;seven&quot;, &quot;age&quot;: 18})

tpl = &quot;i am {0[0]}, age {0[1]}, really {0[2]}&quot;.format([1, 2, 3], [11, 22, 33])

tpl = &quot;i am {:s}, age {:d}, money {:f}&quot;.format(&quot;seven&quot;, 18, 88888.1)

tpl = &quot;i am {:s}, age {:d}&quot;.format(*[&quot;seven&quot;, 18])

tpl = &quot;i am {name:s}, age {age:d}&quot;.format(name=&quot;seven&quot;, age=18)

tpl = &quot;i am {name:s}, age {age:d}&quot;.format(**{&quot;name&quot;: &quot;seven&quot;, &quot;age&quot;: 18})

tpl = &quot;numbers: {:b},{:o},{:d},{:x},{:X}, {:%}&quot;.format(15, 15, 15, 15, 15, 15.87623, 2)

tpl = &quot;numbers: {:b},{:o},{:d},{:x},{:X}, {:%}&quot;.format(15, 15, 15, 15, 15, 15.87623, 2)

tpl = &quot;numbers: {0:b},{0:o},{0:d},{0:x},{0:X}, {0:%}&quot;.format(15)

tpl = &quot;numbers: {num:b},{num:o},{num:d},{num:x},{num:X}, {num:%}&quot;.format(num=15)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python的字符串格式化有两种方式: 百分号方式、format方式。&lt;/p&gt;
&lt;p&gt;百分号的方式相对来说比较老，而format方式则是比较先进的方式，企图替换古老的方式，目前两者并存。&lt;/p&gt;
&lt;h1 id=&quot;百分号方式&quot;&gt;&lt;a href=&quot;#百分号方式&quot; class=&quot;
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（二）：基础数值类型</title>
    <link href="http://yjscloud.com/2018/01/16/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yjscloud.com/2018/01/16/Python当歌（二）：基础数值类型/</id>
    <published>2018-01-16T10:31:58.000Z</published>
    <updated>2018-02-07T11:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h1><p>所有的功能，都放在int里</p>
<p>int:将字符串转换为数字</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%881%EF%BC%89.png" alt="二（1）"></p>
<p>bit_lenght：当前数字的二进制，至少用n位表示</p>
<pre><code>r = age.bit_length()
</code></pre><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%882%EF%BC%89.png" alt="二（2）"></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>如：’wupeiqi’、’alex’</p>
<p>注：字符串一旦创建，不可修改，一旦修改或者拼接，都会造成重新生成字符串。</p>
<p>每个字符串都具备如下功能：</p>
<p>（1）首字母大写</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%883%EF%BC%89.png" alt="二（3）"></p>
<p>（2）所有变小写，casefold（）更牛逼，很多未知的对相应变小写</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%884%EF%BC%89.png" alt="二（4）"></p>
<p>（3）设置宽度，并将内容居中</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%885%EF%BC%89.png" alt="二（5）"></p>
<p>注：20代指总长度，*空白未知填充，一个字符，可有可无</p>
<p>设置宽度，并将内容居右：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%886%EF%BC%89.png" alt="二（6）"></p>
<p>设置宽度，并将内容居左： </p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%887%EF%BC%89.png" alt="二（7）"></p>
<p>（4）去字符串中寻找，寻找子序列的出现次数：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%888%EF%BC%89.png" alt="二（8）"></p>
<p>也可在限定范围内寻找</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%889%EF%BC%89.png" alt="二（9）"></p>
<p>（5）以什么什么结尾：endswith（），以什么什么开始：startswith（）</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8810%EF%BC%89.png" alt="二（10）"></p>
<p>（6）断句方法</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8811%EF%BC%89.png" alt="二（11）"></p>
<p>注：20的意思是以20个字符为空格作为断句</p>
<p>（7）从开始往后找，找到第一个之后，获取其未知</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8812%EF%BC%89.png" alt="二（12）"></p>
<p>（8）Index（）找不到，报错 </p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8813%EF%BC%89.png" alt="二（13）"></p>
<p>（9）格式化，将一个字符串中的占位符替换为指定的值 </p>
<p>使用关键字进行匹配</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8814%EF%BC%89.png" alt="二（14）"></p>
<p>使用数字进行匹配</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%BA%8C%EF%BC%8815%EF%BC%89.png" alt="二（15）"></p>
<p>(10)格式化，传入的值 {“name”: ‘alex’, “a”: 19} </p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-16.png" alt="2-16"></p>
<p>（11）字符串中是否只包含字母和数字</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-17.png" alt="2-17"></p>
<p>（12）是否是字母和汉字</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-18.png" alt="2-18"></p>
<p>（13）当前输入是否是数字</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-19.png" alt="2-19"></p>
<p>（14）是否存在不可显示的字符</p>
<pre><code># \t   制表符
# \n   换行
</code></pre><p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-20.png" alt="2-20"></p>
<p>(15)判断是否全部是空格</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-21.png" alt="2-21"></p>
<p>（16）判断是否是标题</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-22.png" alt="2-22"></p>
<p>(17)将字符串中的每一个元素按照指定分隔符进行拼接</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-23.png" alt="2-23"></p>
<p>（18)判断是否全部是大小写和转换为大小写</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-24.png" alt="2-24"></p>
<p>(19)移除指定字符串，有限最多匹配</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-25.png" alt="2-25"></p>
<p>lstrip()和rstrip()去除左右空白，也可以去除去除\t \n</p>
<p>（20）分割为三部分</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-26.png" alt="2-26"></p>
<p>（21）分割为指定个数</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-27.png" alt="2-27"></p>
<p>（22）分割，只能根据，true，false：是否保留换行</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-28.png" alt="2-28"></p>
<p>(23)以xxx开头，以xx结尾</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-29.png" alt="2-29"></p>
<p>(24)大小写转换</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-30.png" alt="2-30"></p>
<p>(25)字母，数字，下划线 ： 标识符 def  class</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-31.png" alt="2-31"></p>
<p>(26)将指定字符串替换为指定字符串</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-32.png" alt="2-32"></p>
<p>以上方法中join、split、find、strip、upper、lower、replace这7个方法比较常用</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>如：[11,22,33]、[‘wupeiqi’, ‘alex’]</p>
<p>每个列表都具备如下功能：</p>
<p>（1)原来值最后追加</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-33.png" alt="2-33"></p>
<p>(2)清空列表</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-34.png" alt="2-34"></p>
<p>(3)拷贝，浅拷贝</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-35.png" alt="2-35"></p>
<p>(4)计算元素出现的次数</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-36.png" alt="2-36"></p>
<p>(5)根据值获取当前值索引位置（左边优先）</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-37.png" alt="2-37"></p>
<p>(6)在指定索引位置插入元素</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-38.png" alt="2-38"></p>
<p>(7)删除某个值(1.指定索引；2. 默认最后一个)，并获取删除的值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-39.png" alt="2-39"></p>
<p>还可以指定索引来删除</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-40.png" alt="2-40"></p>
<p>(8)删除列表中的指定值，左边优先</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-41.png" alt="2-41"></p>
<p>(9)将当前列表进行翻转</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-42.png" alt="2-42"></p>
<p>(10)列表的排序</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-43-1.png" alt="2-43"></p>
<p>注：列表中可以嵌套任何类型，列表是有序的，列表中的元素可以是数字，字符串,列表，布尔值…所有的都能放进去，列表元素可以被查询、修改和删除，可以通过索引和切片进行查找，可以用in操作判断一个元素是否在列表中例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-43.png" alt="2-44"></p>
<p>取嵌套列表中的元素例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-44.png" alt="2-45"></p>
<p>也可以将字符串转换列表，其内部使用for循环，例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-45.png" alt="2-46"></p>
<p>也可以将列表转换成字符串，需要自己写for循环一个一个处理： 既有数字又有字符串，例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-46.png" alt="2-47"></p>
<p>也可以直接使用字符串join方法：列表中的元素只有字符串，例如：</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-47.png" alt="2-48"></p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>如：(11,22,33)、(‘wupeiqi’, ‘alex’)</p>
<p>元组，元素不可被修改，不能被增加或者删除，元组同样可以通过切片索引查询元素</p>
<p>每个元组都具备如下功能：</p>
<p>(1)可以被for循环，可迭代对象</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-48.png" alt="2-49"></p>
<p>(2)转换</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-49.png" alt="2-50"></p>
<p>(3)元组的一级元素不可修改/删除/增加，元组是有序的。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-50.png" alt="2-51"></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>如：{‘name’: ‘wupeiqi’, ‘age’: 18} 、{‘host’: ‘2.2.2.2’, ‘port’: 80]}</p>
<p>ps：循环时，默认循环key</p>
<p>字典两大特点：无序，键唯一</p>
<p>每个字典都具备如下功能：</p>
<p>(1)根据序列，创建字典，并指定统一的值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-51.png" alt="2-52"></p>
<p>(2)根据Key获取值，key不存在时，可以指定默认值（None）</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-52.png" alt="2-53"></p>
<p>(3)删除并获取值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-53.png" alt="2-54"></p>
<p>(4)设置值，已存在，不设置，获取当前key对应的值：不存在，设置，获取当前key对应的值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-54.png" alt="2-55"></p>
<p>(5)更新</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-55.png" alt="2-56"></p>
<p>(6)字典的value可以是任何值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-56.png" alt="2-57"></p>
<p>(7)布尔值(1,0)、列表、字典不能作为字典的key</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-57.png" alt="2-58"></p>
<p>(8)索引方式找到指定元素</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-58.png" alt="2-59"></p>
<p>(9)字典支持 del 删除</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-59.png" alt="2-60"></p>
<p>(10)for循环</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-60.png" alt="2-61"></p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>set是一个无序且不重复的元素集合</p>
<p>每个集合都具备如下功能：</p>
<p>(1)添加</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-61.png" alt="2-62"></p>
<p>(2)清空</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-62.png" alt="2-63"></p>
<p>(3)拷贝</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-63.png" alt="2-64"></p>
<p>(4)随机删</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-64.png" alt="2-65"></p>
<p>(5)指定删除</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-65.png" alt="2-66"></p>
<p>(6)求交集</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-66.png" alt="2-67"></p>
<p>(7)求并集</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-67.png" alt="2-68"></p>
<p>(8)差集</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-68.png" alt="2-69"></p>
<p>(9)交叉补集</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-69.png" alt="2-70"></p>
<p>(10)集合值更新</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-70.png" alt="2-71"></p>
<p>(11)去除集合中的重复值</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/2-71.png" alt="2-72"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数字&quot;&gt;&lt;a href=&quot;#数字&quot; class=&quot;headerlink&quot; title=&quot;数字&quot;&gt;&lt;/a&gt;数字&lt;/h1&gt;&lt;p&gt;所有的功能，都放在int里&lt;/p&gt;
&lt;p&gt;int:将字符串转换为数字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3q1rwnbl.b
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python当歌（一）：Python入门</title>
    <link href="http://yjscloud.com/2018/01/15/Python%E5%BD%93%E6%AD%8C%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9APython%E5%85%A5%E9%97%A8/"/>
    <id>http://yjscloud.com/2018/01/15/Python当歌（一）：Python入门/</id>
    <published>2018-01-15T08:47:45.000Z</published>
    <updated>2018-02-07T11:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一句Python代码"><a href="#第一句Python代码" class="headerlink" title="第一句Python代码"></a>第一句Python代码</h1><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%881%EF%BC%89.png" alt="一（1）"></p>
<p>python内部执行过程如下：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%882%EF%BC%89.png" alt="一（2）"></p>
<h1 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h1><p>python解释器在加载 .py 文件中的代码时，会对内容进行编码（默认ascill）<br>ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，其最多只能用 8 位来表示（一个字节），即：2**8 = 256，所以，ASCII码最多只能表示 256 个符号。</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%883%EF%BC%89.png" alt="一（3）"><br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%884%EF%BC%89.png" alt="一（4）"></p>
<p>显然ASCII码无法将世界上的各种文字和符号全部表示，所以，就需要新出一种可以代表所有字符和符号的编码，即：Unicode<br>Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，规定虽有的字符和符号最少由 16 位来表示（2个字节），即：2 **16 = 65536。</p>
<p>注：此处说的的是最少2个字节，可能更多UTF-8，是对Unicode编码的压缩和优化，他不再使用最少使用2个字节，而是将所有的字符和符号进行分类：ascii码中的内容用1个字节保存、欧洲的字符用2个字节保存，东亚的字符用3个字节保存。<br>注：在python2中如果在.py文中有中文会报错，需要在文件开头添加一行注释：# -<em>- coding: utf-8 -</em>-，就不会报错，而知python3中可以不用添加，python3已经可以很好的支持中文了。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>当行注视：# 被注释内容<br>多行注释：””” 被注释内容 “””</p>
<h1 id="执行脚本传入参数"><a href="#执行脚本传入参数" class="headerlink" title="执行脚本传入参数"></a>执行脚本传入参数</h1><p>Python有大量的模块，从而使得开发Python程序非常简洁。类库有包括三中：</p>
<p>•    Python内部提供的模块</p>
<p>•    业内开源的模块</p>
<p>•    程序员自己开发的模块</p>
<p>Python内部提供一个 sys 的模块，其中的 sys.argv 用来捕获执行执行python脚本时传入的参数</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%885%EF%BC%89.png" alt="一（5）"></p>
<h1 id="pyc-文件"><a href="#pyc-文件" class="headerlink" title="pyc 文件"></a>pyc 文件</h1><p>执行Python代码时，如果导入了其他的 .py 文件，那么，执行过程中会自动生成一个与其同名的 .pyc 文件，该文件就是Python解释器编译之后产生的字节码。<br>ps：代码经过编译可以产生字节码；字节码通过反编译也可以得到代码。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%886%EF%BC%89.png" alt="一（6）"></p>
<p>上述代码声明了一个变量，变量名为： name，变量name的值为：”xwq”<br>变量的作用：昵称，其代指内存里某个地址中保存的内容</p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%887%EF%BC%89.png" alt="一（7）"></p>
<p>变量定义的规则：</p>
<p>变量名只能是 字母、数字或下划线的任意组合，变量名的第一个字符不能是数字</p>
<p>以下关键字不能声明为变量名：[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</p>
<h2 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h2><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%888%EF%BC%89.png" alt="一（8）"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%809.png" alt="一9"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%889%EF%BC%89.png" alt="一（9）"></p>
<p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8810%EF%BC%89.png" alt="一（10）"></p>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8811%EF%BC%89.png" alt="一（11）"></p>
<h1 id="初识基本数据类型"><a href="#初识基本数据类型" class="headerlink" title="初识基本数据类型"></a>初识基本数据类型</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>2是一个整数的例子。<br>长整数不过是大一些的整数。</p>
<p>3.23和52.3E-4是浮点数的例子。E标记表示10的幂。在这里，52.3E-4表示52.3 * 10-4。<br>(-5+4j)和(2.3-4.6j)是复数的例子。</p>
<p>int（整型）</p>
<p>　　在32位机器上，整数的位数为32位，取值范围为-2<strong>31～2</strong>31-1，即-2147483648～2147483647<br>　　在64位系统上，整数的位数为64位，取值范围为-2<strong>63～2</strong>63-1，即-9223372036854775808～9223372036854775807<br>　　<br>long（长整型）<br>　　<br>　　跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，我们使用的长整数数值不可能无限大。<br>　　注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。</p>
<p>float（浮点型）<br>　　<br>　　浮点数用来处理实数，即带有小数的数字。类似于C语言中的double类型，占8个字节（64位），其中52位表示底，11位表示指数，剩下的一位表示符号。</p>
<p>complex（复数）<br>　　<br>　　复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数。<br>注：Python中存在小数字池：-5 ～ 257</p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>　　真或假<br>　　<br>　　1 或 0
　　</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>“hello world”</p>
<p>万恶的字符串拼接：python中的字符串在C语言中体现为是一个字符数组，每次创建字符串时候需要在内存中开辟一块连续的空，并且一旦需要修改字符串的话，就需要再次开辟空间，万恶的+号每出现一次就会在内从中重新开辟一块空间。</p>
<p>字符串格式化:<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8812%EF%BC%89.png" alt="一（12）"></p>
<p>PS: 字符串是 %s;整数 %d;浮点数%f</p>
<p>字符串常用功能：移除空白、分割、长度、索引、切片</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>创建列表：</p>
<p>name_list = [‘alex’, ‘seven’, ‘eric’]</p>
<p>基本操作：索引、切片、追加、删除、长度、切片、循环、包含</p>
<h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h2><p>创建元祖：ages = (11, 22, 33, 44, 55)</p>
<p>基本操作：索引、切片、循环、长度、包含</p>
<h2 id="字典（无序）"><a href="#字典（无序）" class="headerlink" title="字典（无序）"></a>字典（无序）</h2><p>创建字典：person = {“name”: “mr.wu”, ‘age’: 18}</p>
<p>常用操作：索引，新增，删除，键、值、键值对，循环，长度</p>
<p>PS：循环，range，continue 和 break</p>
<h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><p>算数运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8813%EF%BC%89.png" alt="一（13）"></p>
<p>比较运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8814%EF%BC%89.png" alt="一（14）"></p>
<p>赋值运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8815%EF%BC%89.png" alt="一（15）"></p>
<p>逻辑运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8816%EF%BC%89.png" alt="一（16）"></p>
<p>成员运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8818%EF%BC%89.png" alt="一（17）"></p>
<p>身份运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8818%EF%BC%89.png" alt="一（18）"></p>
<p>位运算：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8819%EF%BC%89.png" alt="一（19）"></p>
<p>运算符优先级：<br><img src="http://p3q1rwnbl.bkt.clouddn.com/%E4%B8%80%EF%BC%8820%EF%BC%89.png" alt="一（20）"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一句Python代码&quot;&gt;&lt;a href=&quot;#第一句Python代码&quot; class=&quot;headerlink&quot; title=&quot;第一句Python代码&quot;&gt;&lt;/a&gt;第一句Python代码&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://p3q1rwnbl.bkt.clo
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python学习笔记" scheme="http://yjscloud.com/tags/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何用九条命令在一分钟内检查Linux服务器性能?</title>
    <link href="http://yjscloud.com/2017/12/15/%E5%A6%82%E4%BD%95%E7%94%A8%E4%B9%9D%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%9C%A8%E4%B8%80%E5%88%86%E9%92%9F%E5%86%85%E6%A3%80%E6%9F%A5Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/"/>
    <id>http://yjscloud.com/2017/12/15/如何用九条命令在一分钟内检查Linux服务器性能/</id>
    <published>2017-12-15T14:52:37.000Z</published>
    <updated>2017-12-15T15:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uptime命令"><a href="#uptime命令" class="headerlink" title="uptime命令"></a>uptime命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-1.png" alt="1-1"></p>
<p>这个命令可以快速查看机器的负载情况。在Linux系统中，这些数据表示等待CPU资源的进程和阻塞在不可中断IO进程（进程状态为D）的数量。这些数据可以让我们对系统资源使用有一个宏观的了解。</p>
<p>命令的输出分别表示1分钟、5分钟、15分钟的平均负载情况。通过这三个数据，可以了解服务器负载是在趋于紧张还是趋于缓解。如果1分钟平均负载很高，而15分钟平均负载很低，说明服务器正在命令高负载情况，需要进一步排查CPU资源都消耗在了哪里。反之，如果15分钟平均负载很高，1分钟平均负载较低，则有可能是CPU资源紧张时刻已经过去。</p>
<h1 id="dmesg命令"><a href="#dmesg命令" class="headerlink" title="dmesg命令"></a>dmesg命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-2.png" alt="1-2"></p>
<p>该命令会输出系统日志的最后10行。示例中的输出，可以看见一次内核的oom kill和一次TCP丢包。这些日志可以帮助排查性能问题。千万不要忘了这一步。</p>
<h1 id="vmstat命令"><a href="#vmstat命令" class="headerlink" title="vmstat命令"></a>vmstat命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-3.png" alt="1-3"></p>
<p>vmstat(8) 命令，每行会输出一些系统核心指标，这些指标可以让我们更详细的了解系统状态。后面跟的参数1，表示每秒输出一次统计信息，表头提示了每一列的含义，这几介绍一些和性能调优相关的列：</p>
<p>r：等待在CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况，数据中不包含等待IO的进程。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。</p>
<p>free：系统可用内存数（以千字节为单位），如果剩余内存不足，也会导致系统性能问题。下文介绍到的free命令，可以更详细的了解系统内存的使用情况。</p>
<p>si，so：交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。</p>
<p>us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。</p>
<p>上述这些CPU时间，可以让我们很快了解CPU是否出于繁忙状态。一般情况下，如果用户时间和系统时间相加非常大，CPU出于忙于执行指令。如果IO等待时间很长，那么系统的瓶颈可能在磁盘IO。</p>
<p>示例命令的输出可以看见，大量CPU时间消耗在用户态，也就是用户应用程序消耗了CPU时间。这不一定是性能问题，需要结合r队列，一起分析。</p>
<h1 id="mpstat命令"><a href="#mpstat命令" class="headerlink" title="mpstat命令"></a>mpstat命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-4.png" alt="1-4"></p>
<p>该命令可以显示每个CPU的占用情况，如果有一个CPU占用率特别高，那么有可能是一个单线程应用程序引起的。</p>
<h1 id="pidstat命令"><a href="#pidstat命令" class="headerlink" title="pidstat命令"></a>pidstat命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-5.png" alt="1-5"></p>
<p>pidstat命令输出进程的CPU占用率，该命令会持续输出，并且不会覆盖之前的数据，可以方便观察系统动态。</p>
<h1 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-6.png" alt="1-6"></p>
<p>r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。</p>
<p>await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。</p>
<p>avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。</p>
<p>%util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。</p>
<p>如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。</p>
<h1 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-7.png" alt="1-7"></p>
<p>free命令可以查看系统内存的使用情况，-m参数表示按照兆字节展示。最后两列分别表示用于IO缓存的内存数，和用于文件系统页缓存的内存数。需要注意的是，第二行-/+ buffers/cache，看上去缓存占用了大量内存空间。</p>
<p>这是Linux系统的内存使用策略，尽可能的利用内存，如果应用程序需要内存，这部分内存会立即被回收并分配给应用程序。因此，这部分内存一般也被当成是可用内存。</p>
<p>如果可用内存非常少，系统可能会动用交换区（如果配置了的话），这样会增加IO开销（可以在iostat命令中提现），降低系统性能。</p>
<h1 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-8-1.png" alt="1-8-1"></p>
<p>sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和。</p>
<p><img src="http://p10cpl3za.bkt.clouddn.com/1-8-2.png" alt="1-8-2"></p>
<p>sar命令在这里用于查看TCP连接状态，其中包括：</p>
<p>active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；</p>
<p>passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；</p>
<p>retrans/s：每秒TCP重传数量；</p>
<p>TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压</p>
<h1 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h1><p><img src="http://p10cpl3za.bkt.clouddn.com/1-9.png" alt="1-9"></p>
<p>top命令包含了前面好几个命令的检查的内容。比如系统负载情况（uptime）、系统内存使用情况（free）、系统CPU使用情况（vmstat）等。因此通过这个命令，可以相对全面的查看系统负载的来源。同时，top命令支持排序，可以按照不同的列排序，方便查找出诸如内存占用最多的进程、CPU占用率最高的进程等。但是，top命令相对于前面一些命令，输出是一个瞬间值，如果不持续盯着，可能会错过一些线索。这时可能需要暂停top命令刷新，来记录和比对数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;uptime命令&quot;&gt;&lt;a href=&quot;#uptime命令&quot; class=&quot;headerlink&quot; title=&quot;uptime命令&quot;&gt;&lt;/a&gt;uptime命令&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://p10cpl3za.bkt.clouddn.com/1-1
    
    </summary>
    
      <category term="运维技能" scheme="http://yjscloud.com/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Linux运维技能" scheme="http://yjscloud.com/tags/Linux%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/"/>
    
      <category term="非原创系列" scheme="http://yjscloud.com/tags/%E9%9D%9E%E5%8E%9F%E5%88%9B%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LVS + Keepalived 实现高可用Web集群</title>
    <link href="http://yjscloud.com/2017/10/26/LVS-Keepalived-%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8Web%E9%9B%86%E7%BE%A4/"/>
    <id>http://yjscloud.com/2017/10/26/LVS-Keepalived-实现高可用Web集群/</id>
    <published>2017-10-26T05:23:40.000Z</published>
    <updated>2017-10-26T07:29:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高可用性技术简介"><a href="#高可用性技术简介" class="headerlink" title="高可用性技术简介"></a>高可用性技术简介</h1><p>高可用性（HighAvailability）通常是用来描述一个系统经过专门的设计，从而减少停工的时间，而保持其服务的高可用性。计算机系统的可用性定义为：MTTF/(MTTF+MTTR) * 100%，因此计算机系统的可用性定义为系统保持正常运行时间的百分比。而负载均衡服务器的高可用性是为了屏蔽负载均衡服务器的失效，需要建立一个备份机。主服务器和备份机上都运行高可用性监控程序，通过传送信息来监控对方的运行状况。当备份机不能在一定的时间里接收到从主服务器那里发送的它存活着（即它从事着主服务器的工作）的时候，备份服务器就会从主服务器那里接管器主服务器的服务IP并继续提供服务。当主服务器又开始接管服务时，它会给备份服务器发送它接管的消息，接着备份服务器就会释放服务IP地址，这样子主服务器又再一次接管了服务IP。这就实现了在主服务器失效的状况下，备份服务器可以接管主服务的工作，以此实现负载集群系统配置信息的同步与备份了。</p>
<a id="more"></a>
<h1 id="LVS-负载均衡技术"><a href="#LVS-负载均衡技术" class="headerlink" title="LVS 负载均衡技术"></a>LVS 负载均衡技术</h1><p>LVS即 Linux Virtual Server，是由中国一个Linux程序员章文嵩博士发起和领导的，基于Linux系统的服务器集群解决方案，其实现目标是创建一个具有良好的扩展性、高可靠性、高性能和高可用性的体系。使用LVS架设的服务器集群系统从体系结构上看是透明的，最终用户只感觉到一个虚拟服务器。物理服务器之间可以通过高速的 LAN或分布在各地的WAN相连。最前端是负载均衡器，它负责将各种服务请求分发给后面的物理服务器，让整个集群表现得像一个服务于同一IP地址的虚拟服务器。负载均衡（Load Balance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p>
<p>负载均衡可以通过软件实现也可以通过硬件实现，软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。而硬件负载均衡解决方案是直接在服务器和外部网络间安装负载均衡设备，这种设备我们通常称之为负载均衡器，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。LVS负载均衡的实现基础是IP交换，将IP层的TCP/IP请求均匀的转移到服务器池中不同的服务器上。而在 Linux平台下 IP的交换具备了一定的可扩展性,可以实现高性能、高可扩展性、易管理性等诸多特点,成为一个以负载均衡为核心的真正意义的集群系统。</p>
<p>LVS服务器集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。负载调度器可以运行在以下三种模式下：</p>
<p>（1）Virtual Server via NAT（VS-NAT）：用地址翻译实现虚拟服务器。地址转换器有能被外界访问到的合法IP地址，它修改来自专有网络的流出包的地址。外界看起来包是来自 地址转换器本身，当外界包送到转换器时，它能判断出应该将包送到内部网的哪个节点。优点是节省IP 地址，能对内部进行伪装；缺点是效率低，因为返回给请求方的流量经过转换器。</p>
<p>（2）Virtual Server via IP Tunneling （VS-TUN）：用IP隧道技术实现虚拟服务器。这种方式是在集群的节点不在同一个网段时可用的转发机制，是将IP包封装在其他网络流量中的方法。为了 安全的考虑，应该使用隧道技术中的VPN，也可使用租用专线。 集群所能提供的服务是基于TCP/IP的Web服务、Mail服务、News服务、DNS服务、Proxy服务器等。</p>
<p>（3）Virtual Server via Direct Routing（VS-DR）：用直接路由技术实现虚拟服务器。当参与集群的计算机和作为控制管理的计算机在同一个网段时可以用此法，控制管理的计算机接 收到请求包时直接送到参与集群的节点。优点是返回给客户的流量不经过控制主机，速度快开销少。<br>LVS本身是基于IP层的负载均衡，可以说是最高效的一种方式。其中VS- DR和VS-TUN两种工作模式可以由后端机器直接对外服务，负载均衡的性能很高，对资源占用很少，通过LVS服务器集群负载均衡技术，能够以很高的性价比解决网络访问量激增带来的服务器瓶颈问题。</p>
<h1 id="KEEPALIVED-技术"><a href="#KEEPALIVED-技术" class="headerlink" title="KEEPALIVED 技术"></a>KEEPALIVED 技术</h1><p>在 keepalived中，一个是master，其他的都是backup</p>
<p>vrrp:实现ip地址的高可用性，将除地址之外其他的功能也转移</p>
<p>通过状态的改变，keepalived检测到，执行相应的状态下定义的脚本，脚本中有服务的 关闭和开启的命令，来实现服务的转移。</p>
<p>keepalived不仅提供地址的转移功能，服务启动和关闭，还有监控功能具有两个核心组件：VRRP stack 和 checkers（用来监控服务）、还有对外围监控脚本调用的实现，节点之间只通过优先级来确定资源在哪个节点上运行，需要起始配置，虚拟地址转移需通过配置脚本来启动服务转移信息状态，有个通知机制，可以发短信或者邮件给管理员（需配置邮件服务器）</p>
<p>适用于用不到共享存储，节点少的且keepalived支持多节点，但是节点中启动服务的只能有一个节点（一主多从）让每个节点都活动起来（运行两组资源）</p>
<p>vrrp认证：1、明文认证、配置好预共享密钥  2、md5 sha1 散列</p>
<p>core：是keepalived的核心，复杂主进程的启动和维护，全局配置文件的加载解析等</p>
<p>check：负责healthchecker(健康检查)，包括了各种健康检查方式，以及对应的配置的解析包括<br>LVS的配置解析</p>
<p>vrrp：VRRPD子进程，VRRPD子进程就是来实现VRRP协议的</p>
<p>libipfwc：iptables(ipchains)库，配置LVS会用到</p>
<p>libipvs*：配置LVS会用到</p>
<p>注意，keepalived和LVS完全是两码事，只不过他们各负其责相互配合而已</p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-1.png" alt="k-1"></p>
<p>keepalived启动后会有三个进程</p>
<p>(1)父进程：内存管理，子进程管理等等</p>
<p>(2)子进程：VRRP子进程</p>
<p>(3)子进程：healthchecker子进程</p>
<h1 id="实验环境物理结构说明"><a href="#实验环境物理结构说明" class="headerlink" title="实验环境物理结构说明"></a>实验环境物理结构说明</h1><p><img src="http://ow78pfxd9.bkt.clouddn.com/k-2.png" alt="k-2"></p>
<h1 id="keepalived测试环境安装"><a href="#keepalived测试环境安装" class="headerlink" title="keepalived测试环境安装"></a>keepalived测试环境安装</h1><p>（1）关闭防火墙和selinux</p>
<pre><code># service iptables stop
# chkconfig iptables off
# vi /etc/selinux/config 
    把enforcing改为disabled
# setenforce 0
</code></pre><p>（2）分别给master和backup节点安装ipvsadm和keepalived</p>
<pre><code># yum –y install ipvsadm
# yum –y install keepalived
# service keepalived start
# chkconfig keepalived on
</code></pre><p>（3）配置 keepalived.conf</p>
<pre><code>#  vi /etc/keeplived/keepalived.conf
</code></pre><pre>
! Configuration File for keepalived

global_defs {
   router_id S208                ## keepalived 服务器标识符，可以随意设定（ 貌似也是全局唯一 ）
}

vrrp_instance NW3007 {            ## 定义一个名为 NW3007 的 VRRP 实例
    state MASTER                ## Keepalived 服务器角色，MASTER 为主、BACKUP 为备
    interface eth0                ## 指定 HA 监测网络接口
    virtual_router_id 51            ## 虚拟路由标识，同一个 VRRP 实例使用唯一的标识，主备必须一样
    priority 200                    ## 节点优先级，同一 VRRP 实例中 MASTER 的优先级必须大于 BACKUP
    advert_int 5                    ## MASTER / BACKUP 之间同步检查间隔时间，单位 秒
    track_interface {                ##指定监听数据的网口
        eth0
    }
    authentication {                ## 节点之间通信验证类型、密码 ，同一 VRRP 实例中，MASTER / BACKUP 必须使用相同的密码才可以通信
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {            ## 虚拟 IP 地址，又称漂移 IP 。可以通过 ip add 在 MASTER 上查看是否绑定
        192.168.2.100
    }
}

virtual_server 192.168.0.110 80 {        ## 定义虚拟服务器
    delay_loop 3                        ## 定义健康检查时间间隔，单位 秒
    lb_algo wlc                         ## 负载均衡调度算法，支持 rr 、wrr 、lc 、wlc 、lblc 、sh 、dh 等
    lb_kind DR                        ## LVS 负载均衡机制，支持 NAT 、TUN 、DR
    protocol TCP                    ## 转发协议类型，支持 TCP 、UDP
    ha_suspend                        

    real_server 192.168.0.30 80 {            ## 定义节点服务器
        weight 3                        ## 节点权重值，数字越大权重越高，分配到的连接越多。主要用于后端节点服务器性能不统一
        TCP_CHECK {                ## 健康检测方式，支持 HTTP_GET 、SSL_GET 、TCP_CHECK 、SMTP_CHECK 、MISC_CHECK
            connect_timeout 3        ## 无响应超时时间，单位 秒
        }
    }

    real_server 192.168.0.31 80 {        ## 第二台节点服务器
        weight 3
        TCP_CHECK {
            connect_timeout 3
        }
    }
}
</pre>

<p>在master节点配置好keepalived文件后将keepalived.conf拷贝到backup节点</p>
<pre><code># scp /etc/keepalived/keepalived.conf  192.168.0.29:/etc/keepalived/
</code></pre><p>然后将priority值改为100即可,最后重启keepalived服务</p>
<pre><code># service keepalived restart
</code></pre><p>（4）为master节点和backup节点添加vip</p>
<p>master节点</p>
<pre><code># ip addr add 192.168.0.110/32 dev eth0
</code></pre><p><img src="http://ow78pfxd9.bkt.clouddn.com/k-3.png" alt="k-3"></p>
<p>backup节点</p>
<pre><code># ip addr add 192.168.0.110/32 dev eth0
</code></pre><p><img src="http://ow78pfxd9.bkt.clouddn.com/k-4.png" alt="k-4"></p>
<p>（5）验证虚拟 IP 地址是否可以正常漂移</p>
<p>停用master节点网卡</p>
<pre><code># ifdown eth0
</code></pre><p>查看backup节点的日志文件</p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-5.png" alt="k-5"></p>
<p>查看backup的网卡</p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-6.png" alt="k-6"></p>
<p>重新激活master网卡,查看backup日志文件<br><img src="http://ow78pfxd9.bkt.clouddn.com/k-7.png" alt="k-7"></p>
<p>虚拟ip会自动移除，虚拟ip设置正常！</p>
<p>注意：停用master的网卡vip会自动消失需要重新为master添加vip</p>
<pre><code># ip addr add 192.168.0.110/32 dev eth0
</code></pre><h1 id="配置RS-1和RS-2"><a href="#配置RS-1和RS-2" class="headerlink" title="配置RS-1和RS-2"></a>配置RS-1和RS-2</h1><p>（1）关闭防火墙和selinux</p>
<pre><code># service iptables stop
# chkconfig iptables off
# vi /etc/selinux/config 
    把enforcing改为disabled
# setenforce 0
</code></pre><p>（2）安装httpd</p>
<p>分别在RS-1和RS-2上进行如下操作</p>
<pre><code># yum –y install httpd
# service httpd start
# chkconfig httpd on
</code></pre><p>在RS-1</p>
<pre><code>echo RS-1-Web11111111 &gt; /var/www/html/index.html
</code></pre><p>在RS-2</p>
<pre><code>echo RS-2-Web2222222 &gt; /var/www/html/index.html
</code></pre><p>（3）RS-1创建一个脚本文件</p>
<pre><code># vi /root/realserver.sh
</code></pre><pre>
#!/bin/bash
vip=192.168.0.110

case $1 in
start)
    echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore
    echo 1 > /proc/sys/net/ipv4/conf/eth0/arp_ignore
    echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce
    echo 2 > /proc/sys/net/ipv4/conf/eth0/arp_announce

    ifconfig lo:0 $vip netmask 255.255.255.255 broadcast $vip up

    ;;
stop)
    ifconfig lo:0 down
        echo 0 > /proc/sys/net/ipv4/conf/all/arp_ignore
        echo 0 > /proc/sys/net/ipv4/conf/eth0/arp_ignore
        echo 0 > /proc/sys/net/ipv4/conf/all/arp_announce
        echo 0 > /proc/sys/net/ipv4/conf/eth0/arp_announce
    ;;
esac
</pre>

<p>赋予运行权权限</p>
<pre><code># chmod a+x /root/realserver.sh
</code></pre><p>将脚本拷贝到RS-2</p>
<pre><code># scp /root/realserver.sh 192.168.0.31:/root/
</code></pre><p>在RS-1和RS-2执行脚本</p>
<pre><code># ./realserver start
</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>服务器之间可以自由调度</p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-9.png" alt="k-9"></p>
<p><img src="http://ow78pfxd9.bkt.clouddn.com/k-8.png" alt="k-8"></p>
<p>停用mater网卡也可以自由调度RS-1和RS-2，实验到此结束</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高可用性技术简介&quot;&gt;&lt;a href=&quot;#高可用性技术简介&quot; class=&quot;headerlink&quot; title=&quot;高可用性技术简介&quot;&gt;&lt;/a&gt;高可用性技术简介&lt;/h1&gt;&lt;p&gt;高可用性（HighAvailability）通常是用来描述一个系统经过专门的设计，从而减少停工的时间，而保持其服务的高可用性。计算机系统的可用性定义为：MTTF/(MTTF+MTTR) * 100%，因此计算机系统的可用性定义为系统保持正常运行时间的百分比。而负载均衡服务器的高可用性是为了屏蔽负载均衡服务器的失效，需要建立一个备份机。主服务器和备份机上都运行高可用性监控程序，通过传送信息来监控对方的运行状况。当备份机不能在一定的时间里接收到从主服务器那里发送的它存活着（即它从事着主服务器的工作）的时候，备份服务器就会从主服务器那里接管器主服务器的服务IP并继续提供服务。当主服务器又开始接管服务时，它会给备份服务器发送它接管的消息，接着备份服务器就会释放服务IP地址，这样子主服务器又再一次接管了服务IP。这就实现了在主服务器失效的状况下，备份服务器可以接管主服务的工作，以此实现负载集群系统配置信息的同步与备份了。&lt;/p&gt;
    
    </summary>
    
      <category term="技术分享" scheme="http://yjscloud.com/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Linux学习笔记" scheme="http://yjscloud.com/tags/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="keepalived" scheme="http://yjscloud.com/tags/keepalived/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（九）-cpu添加虚拟化功能</title>
    <link href="http://yjscloud.com/2017/10/21/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89-cpu%E6%B7%BB%E5%8A%A0%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8A%9F%E8%83%BD/"/>
    <id>http://yjscloud.com/2017/10/21/kvm学习笔记（九）-cpu添加虚拟化功能/</id>
    <published>2017-10-21T09:23:10.000Z</published>
    <updated>2017-12-02T09:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为只有一台物理机，物理机运行着centos7，需要测试虚拟化环境，就要在运行的kvm环境中的虚拟机增加kvm_intel模块！具体方法如下：</p>
<pre><code>[root@kvm~]# vim /etc/modprobe.d/kvm-nested.conf #此文件默认不存在，新建即可
options kvm_intel nested=1 #添加此行
[root@kvm ~]# modprobe -r kvm_intel #卸载模块
[root@kvm ~]# modprobe kvm_intel #重新加载模块
[root@kvm ~]# cat /sys/module/kvm_intel/parameters/nested 
Y
#返还Y即为支持nested KVM
[root@kvm ~]# virsh edit VM host name #修改虚拟机
</code></pre><p>修改如下区块</p>
<p>将如下代码</p>
<pre><code>&lt;cpu mode=’custom’ match=’exact’ &gt;
</code></pre><p>修改为</p>
<pre><code>&lt;cpu mode=&apos;host-passthrough&apos;&gt;
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/2.1.png" alt="2.1"></p>
<p>如果虚拟机的配置文件里没有<cpu mode="’custom’" match="’exact’">这一行代码就在如下位置添加一行代码即可</cpu></p>
<p><img src="http://oxysobnip.bkt.clouddn.com/2.2.png" alt="2.2"></p>
<p>查看一下虚拟机cpu已经支持虚拟化了</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/2.3.png" alt="2.3"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为只有一台物理机，物理机运行着centos7，需要测试虚拟化环境，就要在运行的kvm环境中的虚拟机增加kvm_intel模块！具体方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@kvm~]# vim /etc/modprobe.d/kvm-nested.conf #
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>kvm学习笔记（八）-kvm虚拟机存储池配置</title>
    <link href="http://yjscloud.com/2017/10/20/kvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89-kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%98%E5%82%A8%E6%B1%A0%E9%85%8D%E7%BD%AE/"/>
    <id>http://yjscloud.com/2017/10/20/kvm学习笔记（八）-kvm虚拟机存储池配置/</id>
    <published>2017-10-20T04:56:21.000Z</published>
    <updated>2017-12-02T09:34:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是存储池"><a href="#什么是存储池" class="headerlink" title="什么是存储池"></a>什么是存储池</h1><p>KVM平台以存储池的形式对存储进行统一管理，所谓存储池可以理解为本地目录、通过远端磁盘阵列（iSCSI、NFS）分配过来磁盘或目录，当然也支持各类分布式文件系统。通过virsh中pool命令能够查看、创建、激活、注册、删除存储池。</p>
<p>注1:KVM存储池主要是体现一种管理方式，可以通过挂载存储目录，lvm逻辑卷的方式创建存储池，虚拟机存储卷创建完成后，剩下的操作与无存储卷的方式无任何区别了。</p>
<p>注2:KVM存储池也要用于虚拟机迁移任务。</p>
<h1 id="存储池配置步骤"><a href="#存储池配置步骤" class="headerlink" title="存储池配置步骤"></a>存储池配置步骤</h1><h2 id="创建基于文件夹的存储池（目录）"><a href="#创建基于文件夹的存储池（目录）" class="headerlink" title="创建基于文件夹的存储池（目录）"></a>创建基于文件夹的存储池（目录）</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.102.png" alt="1.102"></p>
<h2 id="定义存储池与其目录"><a href="#定义存储池与其目录" class="headerlink" title="定义存储池与其目录"></a>定义存储池与其目录</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.103.png" alt="1.103"></p>
<h2 id="创建已定义的存储池"><a href="#创建已定义的存储池" class="headerlink" title="创建已定义的存储池"></a>创建已定义的存储池</h2><p>(1)创建已定义的存储池</p>
<pre><code># virsh pool-build vmdisk
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.104.png" alt="1.104"></p>
<p>(2)查看已定义的存储池，存储池不激活无法使用。</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.105.png" alt="1.105"></p>
<h2 id="激活并自动启动已定义的存储池"><a href="#激活并自动启动已定义的存储池" class="headerlink" title="激活并自动启动已定义的存储池"></a>激活并自动启动已定义的存储池</h2><p><img src="http://oxysobnip.bkt.clouddn.com/1.106.png" alt="1.106"></p>
<p>这里vmdisk存储池就已经创建好了，可以直接在这个存储池中创建虚拟磁盘文件了。</p>
<h2 id="在存储池中创建虚拟机存储卷"><a href="#在存储池中创建虚拟机存储卷" class="headerlink" title="在存储池中创建虚拟机存储卷"></a>在存储池中创建虚拟机存储卷</h2><p>(1)在存储池中创建虚拟机存储卷</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.107.png" alt="1.107"></p>
<p>(2)根据创建的虚拟机存储卷安装虚拟机</p>
<p><img src="http://oxysobnip.bkt.clouddn.com/1.108.png" alt="1.108"></p>
<p>安装过程略！</p>
<p>说明：KVM存储池主要是体现一种管理方式，可以通过挂载存储目录，lvm逻辑卷的方式创建存储池，虚拟机存储卷创建完成后，剩下的操作与无存储卷的方式无任何区别了。KVM存储池也要用于虚拟机迁移任务。</p>
<h2 id="存储池相关管理命令"><a href="#存储池相关管理命令" class="headerlink" title="存储池相关管理命令"></a>存储池相关管理命令</h2><p>(1)在存储池中删除虚拟机存储卷</p>
<pre><code># virsh vol-delete --pool vmdisk test-01.qcow2
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.109.png" alt="1.109"></p>
<p>(2)取消激活存储池</p>
<pre><code># virsh pool-destroy vmdisk
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.110.png" alt="1.110"></p>
<p>(3)删除存储池定义的目录/mnt/vmfs</p>
<pre><code># virsh pool-delete vmdisk
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.111.png" alt="1.111"></p>
<p>(4)取消定义存储池</p>
<pre><code># virsh pool-undefine vmdisk
</code></pre><p><img src="http://oxysobnip.bkt.clouddn.com/1.112.png" alt="1.112"></p>
<p>到此kvm存储池配置与管理操作完毕。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是存储池&quot;&gt;&lt;a href=&quot;#什么是存储池&quot; class=&quot;headerlink&quot; title=&quot;什么是存储池&quot;&gt;&lt;/a&gt;什么是存储池&lt;/h1&gt;&lt;p&gt;KVM平台以存储池的形式对存储进行统一管理，所谓存储池可以理解为本地目录、通过远端磁盘阵列（iSCSI、NF
    
    </summary>
    
      <category term="学习笔记" scheme="http://yjscloud.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="KVM学习笔记" scheme="http://yjscloud.com/tags/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
